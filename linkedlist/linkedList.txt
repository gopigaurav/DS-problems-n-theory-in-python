-- Merge Two sorted lists

-- https://www.interviewbit.com/problems/merge-two-sorted-lists/hints/
-- https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/

--
 # Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param A : head node of linked list
    # @param B : head node of linked list
    # @return the head node in the linked list
    def mergeTwoLists(self, A, B):
        root1 = A
        root2 = B
        res = ListNode(0)
        dummy = res
        while (root1 is not None) and (root2 is not None):
            if root1.val < root2.val:
                dummy.next = ListNode(root1.val)
                root1 = root1.next
                dummy = dummy.next
            else:
                dummy.next = ListNode(root2.val)
                root2 = root2.next
                dummy = dummy.next
        if root1 is not None :
            dummy.next = root1
        elif root2 is not None:
            dummy.next = root2
        return res.next


=====================================================================================================================================================

-- Reverse a ll
-- https://www.interviewbit.com/problems/reverse-linked-list/
-- https://www.geeksforgeeks.org/reverse-a-linked-list/


-- 

class Solution:
    # @param A : head node of linked list
    # @return the head node in the linked list
    def reverseList(self, A):
        prev = None
        cur = A
        nex = None
        while cur:
           nex = cur.next
           cur.next = prev
           prev = cur
           cur = nex
        head = prev
        return head   

===============================================================================================================================================================

-- delete without head pointer

-- https://practice.geeksforgeeks.org/problems/delete-without-head-pointer/1
-- https://www.geeksforgeeks.org/delete-a-node-from-linked-list-without-head-pointer/



-- 
class Solution:
    #Function to delete a node without any reference to head pointer.
    def deleteNode(self,curr_node):
        delpos = curr_node
        delpos.data = delpos.next.data
        delpos.next = delpos.next.next
        

=================================================================================================================================================================

-- Add two numbers in linked List (Reversed) code in book b5

(Refer Neetcode)

-- https://www.youtube.com/watch?v=wgFPrzTjm7s
-- https://www.interviewbit.com/problems/add-two-numbers-as-lists/

--
class Solution:
    # @param A : head node of linked list
    # @param B : head node of linked list
    # @return the head node in the linked list
    def addTwoNumbers(self, A, B):
        a, b = A, B
        head = ListNode(0)
        cur_sum = head
        while a != None or b != None or cur_sum.val > 9:
            carry = cur_sum.val / 10
            cur_sum.val %= 10
            a_val = 0 if a == None else a.val
            b_val = 0 if b == None else b.val
            next_val = a_val + b_val + carry
            cur_sum.next = ListNode(next_val)
            cur_sum = cur_sum.next
            a = None if a == None else a.next
            b = None if b == None else b.next
        return head.next

--

=========================================================================================================================================================================

-- Add two numbers in linked lists (not reversed)in book b5

(codehelp by babber)

-- https://practice.geeksforgeeks.org/problems/add-two-numbers-represented-by-linked-lists/1
-- https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/
-- https://www.youtube.com/watch?v=wgFPrzTjm7s
--

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, first, second):
        root1 = first
        root2 = second
        answer = Node(0)
        
        def reverse(root):
            prev = None
            cur = root
            nex = None
            while cur:
                nex = cur.next
                cur.next = prev
                prev = cur
                cur = nex
            root = prev
            return root
        revRoot1 = reverse(root1)
        revRoot2 = reverse(root2)
        carry = 0
        
        while revRoot1 or revRoot2 or carry:
            v1 = revRoot1.data if revRoot1 else 0
            v2 = revRoot2.data if revRoot2 else 0
            
            val = v1 + v2 +  carry
            carry = val // 10
            val = val % 10
            answer.next = Node(val)
            answer = answer.next
            revRoot1 = revRoot1.next if revRoot1 else None
            revRoot2 = revRoot2.next if revRoot2 else None
        dummy = Node(0)
        dummy.next = reverse(answer.next)
        return dummy.next

===================================================================================================================================

-- finding middle element

-- https://practice.geeksforgeeks.org/problems/finding-middle-element-in-a-linked-list/1/
-- https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/

-- 
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        fp = head
        sp = head
        while sp and sp.next != None:
            fp = fp.next
            sp = sp.next.next
        return fp.data
            
--

 
=====================================================================================================================================================

-- Palindrome linked list
-- https://leetcode.com/problems/palindrome-linked-list/submissions/
-- https://practice.geeksforgeeks.org/problems/check-if-linked-list-is-pallindrome/1/
-- https://www.youtube.com/watch?v=70tx7KcMROc&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=45

--
def isPalindrome(self, head):
        
        # get mid element function
        def getMid(head):
            fp = head
            sp = head
            while sp and sp.next!= None:
                fp = fp.next
                sp = sp.next.next
            return fp
        
        def reverse(second_half):
            prev = None
            current = second_half
            next = None
              
            while current != None:
                next = current.next
                current.next = prev
                prev = current
                current = next
            return prev
            
        # get the mid element 
        mid = getMid(head)
        headSecond = reverse(mid)
        
        while head and headSecond and head!= headSecond:
            if head.data != headSecond.data:
                return 0
            head = head.next
            headSecond = headSecond.next
        return 1

--

class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        fast = head
        slow = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        mid = slow
        prev = None  

        while mid:
            next_node = mid.next
            mid.next = prev
            prev = mid
            mid = next_node

        tail = prev

        while head and tail and tail != head:
            if tail.val != head.val:
                return False
            head = head.next
            tail = tail.next

        return True

-- 




