# BFS

graph = {
  1 : [2,3],
  6 : [4,5],
  2 : [1,4,5],
  3 : [1,5],
  4 : [2,5,6],
  5 : [2,3,4,6],
}
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
        if node not in graph:
            print("invalid")
            return
        visited.append(node)
        queue.append(node)
        while queue:          
            m = queue.pop(0) 
            print (m) 
            for neighbour in graph[m]:
                if neighbour not in visited:
                    visited.append(neighbour)
                    queue.append(neighbour)

# DFS 
def dfs(graph, start, visted):
    print(start)
    visited.append(start)
    for i in graph[start]:
        if i not in visited:
            dfs(graph, i, visited)
            
dfs(graph, 1, visited)
#bfs(visited, graph,0)


=============================== DFS ==================================================================

-- method -1 


--
from collections import defaultdict
class Solution:
    res = []
    #Function to return a list containing the DFS traversal of the graph.
    def dfsOfGraph(self, V, adj):
        vis = []
        def dfs(node, vis, adj):
            vis.append(node)
            self.res.append(node)
            for i in adj[node]:
                if i not in vis:
                    dfs(i, vis, adj)
                    
        
        dfs(0, vis, adj)
        #print(self.res)
        return self.res
--


-- method - 2

# Python program to print DFS traversal for complete graph
from collections import defaultdict

# This class represents a directed graph using adjacency
# list representation
class Graph:

	# Constructor
	def __init__(self):

		# default dictionary to store graph
		self.graph = defaultdict(list)

	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

	# A function used by DFS
	def DFSUtil(self, v, visited):

		# Mark the current node as visited and print it
		visited[v]= True
		print v,
		# or push the v into node

		# Recur for all the vertices adjacent to
		# this vertex
		for i in self.graph[v]:
			if visited[i] == False:
				self.DFSUtil(i, visited)


	# The function to do DFS traversal. It uses
	# recursive DFSUtil()
	def DFS(self):
		V = len(self.graph) #total vertices

		# Mark all the vertices as not visited
		visited =[False]*(V)

		# Call the recursive helper function to print
		# DFS traversal starting from all vertices one
		# by one
		for i in range(V):
			if visited[i] == False:
				self.DFSUtil(i, visited)


# Driver code
# Create a graph given in the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print "Following is Depth First Traversal"
g.DFS()

# This code is contributed by Neelam Yadav



=============================== cycle detetcion in directed graph =========================
-- 
=> https://www.youtube.com/watch?v=dc5Pn-YEPVY&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=8
=> https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1
--
class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def __init__(self):
        self.graph = {}
        self.visited = []
        self.instack = []
        
    def isCyclic(self, node):
        self.visited[node] = True
        self.instack[node] = True
        for i in self.graph[node]:
            if not self.visited[i] and self.isCyclic(i):
                return True
            elif self.instack[i]:
                return True
        self.instack[node] = False
        return False
        
    def solve(self, A, B):
        for i in range(1, A + 1):
            self.graph[i] = []
        for (src, dst) in B:
            self.graph[src].append(dst)
        
        self.visited = [False] * (A + 1)
        self.instack = [False] * (A + 1)
        
        for i in range(1, A + 1):
            if not self.visited[i]:
                if self.isCyclic(i):
                    return 1
        return 0

input == 
A = 5
B = [[1, 4],
  [2, 1],
  [4, 3],
  [4, 5],
  [2, 3],
  [2, 4],
  [1, 5],
  [5, 3],
  [2, 5],
  [5, 1],
  [4, 2],
  [3, 1],
  [5, 4],
  [3, 4],
  [1, 3],
  [4, 1],
  [3, 5],
  [3, 2],
  [5, 2],
]
================================================== cycle detection in undirected graph================================


--
=> https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1
=> https://www.youtube.com/watch?v=GLGsIZGLvA0&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=7



--
# cycle detetction in undirected graph
A = 5
B = [[1, 4],
  [2, 1],
  [4, 3],
  [4, 5],
  [2, 3],
  [2, 4],
  [1, 5],
  [5, 3],
  [2, 5],
  [5, 1],
  [4, 2],
  [3, 1],
  [5, 4],
  [3, 4],
  [1, 3],
  [4, 1],
  [3, 5],
  [3, 2],
  [5, 2],
]
from collections import defaultdict
class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def dfs(self,node,parent,visited):
        
        visited[node]=True
        
        for i in self.graph[node]:
            
            if visited[i]==True and i!=parent:
                return True
                
            elif visited[i]==False and self.dfs(i,node,visited)==True:
                return True
                
            
        return False
        
    def solve(self, v, a):
        
        self.graph=defaultdict(list)
        visited={}
        
        for i in a:
            self.graph[i[0]].append(i[1])
            self.graph[i[1]].append(i[0])
            visited[i[0]]=False
            visited[i[1]]=False
            
        for i in visited.keys():
            #print(i)
            if visited[i]==False:
                if self.dfs(i,-1,visited):
                    return 1
        return 0
        
    
===========================================================================================================

========================================= snakes ladder problem =======================================

class Solution:
    # @param A : list of list of integers
    # @param B : list of list of integers
    # @return an integer
    def snakeLadder(self, A, B):
        jump = {}
        for a in A:
            start, end = a
            jump[start] = end
            
        for b in B:
            start, end = b
            jump[start] = end
            
        initial = 1
        final = 100
        queue = []
        visited = set()
        queue.append((initial, 0))
        
        while queue:
            val, count = queue.pop(0)
            if val in jump:
                val = jump[val] 
            
            if val in visited:
                continue
            
            if val == final:
                return count
                
            visited.add(val)
            for i in range(val, val+7):
                if i not in visited and i <= 100:
                    queue.append((i, count+1))
                    
        return -1
            
================================================= Region in Binary matrix ==================================================
-- https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/


class Solution:
    # @param A : list of list of integers
    # @return an integer
    def solve(self, A):
        max_count = 0
        for i in range(len(A)):
            for j in range(len(A[0])):
                if A[i][j] == 1:
                    local_sep_count = self.countCells(A,i,j)
                    max_count = max(max_count, local_sep_count)
        return max_count
    
    def countCells(self, A, row, col):
        if any([row < 0, col< 0, row>=len(A), col>=len(A[0])]):
            return 0
        if A[row][col] == 0:
            return 0
        cell_count = 1
        A[row][col] = 0
        for r in range(row-1, row+2):
            for c in range(col-1, col+2):
                if (r!=row or c != col):
                    cell_count += self.countCells(A, r, c)
        return cell_count


A = [  [0, 0, 1, 1, 0],
        [1, 0, 1, 1, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 0, 0, 1],
    ]
test = Solution()
print(test.solve(A))


======================================================================================================
================================== Min cost path =====================================================

i/p  => 
 A = 3
 B = 3
 C = ["RRR","DDD","UUU"]

code = 
import collections
class Solution:
    # @param A : integer
    # @param B : integer
    # @param C : list of strings
    # @return an integer
    def solve(self, A, B, C):
        queue = collections.deque([])
        queue.append((0,0,0))
        #answer = 999
        completed = [[False for i in range(B)] for j in range(A)]
        
        while(len(queue) != 0):
            i,j,cost = queue.popleft()
            if(completed[i][j] == True):
                continue
            completed[i][j] = True
            if(i == A-1 and j == B-1):
                return cost
            
            if(j+1<B and (i<A and j<B)):   
                if(C[i][j] == 'R'):
                    queue.appendleft(( i, j+1,cost))
                else:
                    queue.append(( i, j+1,cost+1))    
                    
            if(i+1<A and (i<A and j<B)):  
                if(C[i][j] == 'D'):
                    queue.appendleft(( i+1, j,cost))
                else:
                    queue.append(( i+1, j,cost+1))
        
            
            if(j-1>=0 and (i<A and j<B)):
                if(C[i][j] == 'L'):
                    queue.appendleft(( i, j-1,cost))
                else:
                    queue.append(( i, j-1,cost+1))
        
            if(i-1>=0 and (i<A and j<B)):
                
                if(C[i][j] == 'U' ):
                    queue.appendleft(( i-1, j,cost))
                else:
                    queue.append(( i-1, j,cost+1))
            
        
            
        return cost
===============================================================================================================
=========================== path in directed graph =========================================

class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def solve(self, A, edges):
        
        if len(edges) == 0:
            return 0
            
        adj = {}
        
        for s,e in edges:
            if s not in adj:
                adj[s] = []
            if e not in adj:
                adj[e] = []
            adj[s].append(e)
            
        visited = {}
        
        
        q = [1]
        visited[1] = True
        while q:
            node = q.pop()
            if node == A:
                return 1
            for n in adj[node]:
                if n not in visited:
                    visited[n] = True
                    q.append(n)
            
            
        return 0 

==================================================== Number of islands ================================

-- https://www.geeksforgeeks.org/find-number-of-islands/
-- https://practice.geeksforgeeks.org/problems/find-the-number-of-islands/1
-- https://leetcode.com/problems/number-of-islands/submissions/


# Program to count islands in boolean 2D matrix
class Graph:

	def __init__(self, row, col, graph):
		self.ROW = row
		self.COL = col
		self.graph = graph

	# A utility function to do DFS for a 2D
	# boolean matrix. It only considers
	# the 8 neighbours as adjacent vertices
	def DFS(self, i, j):
		if i < 0 or i >= len(self.graph) or j < 0 or j >= len(self.graph[0]) or self.graph[i][j] != 1:
			return

		# mark it as visited
		self.graph[i][j] = -1

		# Recur for 8 neighbours
		self.DFS(i - 1, j - 1)
		self.DFS(i - 1, j)
		self.DFS(i - 1, j + 1)
		self.DFS(i, j - 1)
		self.DFS(i, j + 1)
		self.DFS(i + 1, j - 1)
		self.DFS(i + 1, j)
		self.DFS(i + 1, j + 1)

	# The main function that returns
	# count of islands in a given boolean
	# 2D matrix
	def countIslands(self):
		# Initialize count as 0 and traverse
		# through the all cells of
		# given matrix
		count = 0
		for i in range(self.ROW):
			for j in range(self.COL):
				# If a cell with value 1 is not visited yet,
				# then new island found
				if self.graph[i][j] == 1:
					# Visit all cells in this island
					# and increment island count
					self.DFS(i, j)
					count += 1

		return count


graph = [
	[1, 1, 0, 0, 0],
	[0, 1, 0, 0, 1],
	[1, 0, 0, 1, 1],
	[0, 0, 0, 0, 0],
	[1, 0, 1, 0, 1]
]


row = len(graph)
col = len(graph[0])

g = Graph(row, col, graph)

print("Number of islands is:", g.countIslands())

# This code is contributed by Shivam Shrey

========================================================================================================================

-- corona spread 

-- https://practice.geeksforgeeks.org/problems/269f61832b146dd5e6d89b4ca18cbd2a2654ebbe/1/#
-- https://www.geeksforgeeks.org/maximum-time-required-for-all-patients-to-get-infected/
class Solution:
    def helpaterp(self, hospital):
        r = len(hospital)
        c = len(hospital[0])
        time = 0
        q = []
        
        for i in range(r):
            for j in range(c):
                if hospital[i][j] == 2:
                    q.append((i,j))
        
        count = len(q)
        while count > 0:
            for i in range(count):
                i , j = q.pop(0)
                self.push_neighbours(i,j,q,r,c,hospital) # check if exists a neigbours and is 1 then push to queue
            count = len(q)
            if count > 0:
                time+=1
        for i in range(r):
            for j in range(c):
                if hospital[i][j] == 1:
                    return -1
                    
        return time
                
        
    def push_neighbours(self,i,j,q,r,c,grid):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        for l in range(len(x)):
            if (i + x[l]<0 or i+x[l] >= r or j+y[l] < 0 or j+y[l]>=c or grid[i+x[l]][j+y[l]] != 1 ):
                continue
            q.append((i+x[l],j+y[l]))
            grid[i+x[l]][j+y[l]] = 2
                    

=======================================================================================================================

-- Min cost path

-- https://www.geeksforgeeks.org/min-cost-path-dp-6/
-- https://practice.geeksforgeeks.org/problems/minimum-cost-path3833/1

================================================================================================================================

-- minimum number of swaps to sort an array

-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/

===================================================================================================================================

-- min steps to reach destination

-- https://www.geeksforgeeks.org/minimum-steps-to-reach-a-destination/
-- code in book b8(kashih mehindrata) 
-- https://www.youtube.com/watch?v=RrWpucR--wU&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=23


# python program to count number of
# steps to reach a point
import sys

# Function to count number of steps
# required to reach a destination
	
# source -> source vertex
# step -> value of last step taken
# dest -> destination vertex
def steps(source, step, dest):
	
	#base cases
	if (abs(source) > (dest)) :
		return sys.maxsize
	
	if (source == dest):
		return step

	# at each point we can go
	# either way

	# if we go on positive side
	pos = steps(source + step + 1,
					step + 1, dest)

	# if we go on negative side
	neg = steps(source - step - 1,
					step + 1, dest)

	# minimum of both cases
	return min(pos, neg)
	

# Driver Code
dest = 11;
print("No. of steps required",
			" to reach " ,dest ,
		" is " , steps(0, 0, dest));
	

# This code is contributed by Sam007.


======================================================================================================================================

-- find strings can chained from ciecle

-- geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/
-- https://www.youtube.com/watch?v=WY6Jsp3NxIk&t=98s

===========================================================================================================================

-- snakes and ladders

-- https://www.geeksforgeeks.org/snake-ladder-problem-2/
-- https://www.youtube.com/watch?v=6lH4nO3JfLk

=====================================================================================================================================

-- alien dictionary

-- https://www.youtube.com/watch?v=h_4_Xb1bLgs&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=28
-- https://practice.geeksforgeeks.org/problems/alien-dictionary/1
-- als a video from neetcode

======================================================================================================================================================

-- word ladder 

-- https://www.youtube.com/watch?v=h9iTnkgv05E&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=6
-- https://practice.geeksforgeeks.org/problems/word-ladder/0/?category[]=BFS&page=1&query=category[]BFSpage1

=============================================================================================================================================================

-- Topological sort

-- https://www.youtube.com/watch?v=eMVg3Gvnva4&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=9
-- https://www.geeksforgeeks.org/topological-sorting/

--
-- Using DFS

from collections import defaultdict
class Solution:
    
    #Function to return list containing vertices in Topological order.
    def topoSort(self, V, adj):
        # V is Number of vertices
        # adj ==> { vertices  : [adj] }
        print(V, adj)
        stack = []
        visited = [False] * V
        for i in range(v):
            if visited[i] == False:
                self.dfs(visited, adj, stack, i)
        res = stack[::-1]
        
        return res
    
    def dfs(self, vis, adj, stack, i):
        vis[i] = True
        for ind in adj[i]:
            if vis[ind] == False:
                self.dfs(vis, adj, stack, ind)
        stack.append(i)

--



# Python program to print topological sorting of a DAG
from collections import defaultdict

# Class to represent a graph


class Graph:
	def __init__(self, vertices):
		self.graph = defaultdict(list) # dictionary containing adjacency List
		self.V = vertices # No. of vertices

	# function to add an edge to graph
	def addEdge(self, u, v):
		self.graph[u].append(v)

	# A recursive function used by topologicalSort
	def topologicalSortUtil(self, v, visited, stack):

		# Mark the current node as visited.
		visited[v] = True

		# Recur for all the vertices adjacent to this vertex
		for i in self.graph[v]:
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)

		# Push current vertex to stack which stores result
		stack.append(v)

	# The function to do Topological Sort. It uses recursive
	# topologicalSortUtil()
	def topologicalSort(self):
		# Mark all the vertices as not visited
		visited = [False]*self.V
		stack = []

		# Call the recursive helper function to store Topological
		# Sort starting from all vertices one by one
		for i in range(self.V):
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)

		# Print contents of the stack
		print(stack[::-1]) # return list in reverse order


# Driver Code
g = Graph(6)
g.addEdge(5, 2)
g.addEdge(5, 0)
g.addEdge(4, 0)
g.addEdge(4, 1)
g.addEdge(2, 3)
g.addEdge(3, 1)

print ("Following is a Topological Sort of the given graph")

# Function Call
g.topologicalSort()

# This code is contributed by Neelam Yadav


===========================================================================================================================================================

-- dijkstra algo

-- (Use this) https://www.codingninjas.com/codestudio/problems/dijkstra-s-shortest-path_920469?leftPanelTab=1&utm_source=youtube&utm_medium=affiliate&utm_campaign=Lovebabbar
-- https://practice.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1


-- https://www.google.com/search?q=dijkstra+algo&oq=dijkstra+algo&aqs=chrome..69i57.6343j0j15&sourceid=chrome&ie=UTF-8
-- https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/
-- https://www.youtube.com/watch?v=0kiTAw4xvy4&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=10
-- https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/?ref=lbp
-- https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/?ref=gcse

-- undirected unweighted graph
-- https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/?ref=lbp
-- https://www.youtube.com/watch?v=hwCWi7-bRfI&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=16

-- print paths
-- https://sites.google.com/site/rajboston1951/shortest-paths/8
-- https://www.geeksforgeeks.org/printing-paths-dijkstras-shortest-path-algorithm/?ref=lbp

-- weighted undirected array
-- https://www.youtube.com/watch?v=dVUR3Rm6biE



--
using queue and set
--
-- queue
from collections import deque, defaultdict

def dijkstra1(vec, vertices, edges, source):
    # Write your code here.
    graph = defaultdict(list)
    for s, d, w in vec:
        graph[s].append((d, w))
        graph[d].append((s, w))

    distance = [2147483647] * vertices
    q = deque([source])
    distance[source] = 0
    res = []
    while q:
        curr = q.popleft()
        for node, weight in graph[curr]:
            if distance[curr] + weight < distance[node]:
                distance[node] = distance[curr] + weight
                q.append(node)
                print(q)

    return distance

-- set (use this)
def dijkstra(vec, vertices, edges, source):
    # Write your code here.
    graph = defaultdict(list)
    for s, d, w in vec:
        graph[s].append((d, w))
        graph[d].append((s, w))

    distance = [2147483647] * vertices
    s = set([source])
    distance[source] = 0
    res = []
    while s:
        curr = s.pop()
        for node, weight in graph[curr]:
            if distance[curr] + weight < distance[node]:
                distance[node] = distance[curr] + weight
                s.add(node)

    return distance
--

--
using matrix



class Graph():

	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]

	def printSolution(self, dist):
		print("Vertex \tDistance from Source")
		for node in range(self.V):
			print(node, "\t", dist[node])

	# A utility function to find the vertex with
	# minimum distance value, from the set of vertices
	# not yet included in shortest path tree
	def minDistance(self, dist, sptSet):

		# Initialize minimum distance for next node
		min = float("inf")

		# Search not nearest vertex not in the
		# shortest path tree
		for u in range(self.V):
			if dist[u] < min and sptSet[u] == False:
				min = dist[u]
				min_index = u

		return min_index

	# Function that implements Dijkstra's single source
	# shortest path algorithm for a graph represented
	# using adjacency matrix representation
	def dijkstra(self, src):

		dist = [float("inf")] * self.V
		dist[src] = 0
		sptSet = [False] * self.V

		for _ in range(self.V):

			# Pick the minimum distance vertex from
			# the set of vertices not yet processed.
			# x is always equal to src in first iteration
			x = self.minDistance(dist, sptSet)

			# Put the minimum distance vertex in the
			# shortest path tree
			sptSet[x] = True

			# Update dist value of the adjacent vertices
			# of the picked vertex only if the current
			# distance is greater than new distance and
			# the vertex in not in the shortest path tree
			for y in range(self.V):  
			    # becoz here dist is infinity
			    # if there is edge then the value is more than 0
				if (self.graph[x][y] > 0 and sptSet[y] == False and dist[y] > dist[x] + self.graph[x][y]):
				        
						dist[y] = dist[x] + self.graph[x][y]
						
		self.printSolution(dist)

# Driver program
g = Graph(9)
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 9, 14, 0, 0, 0],
		[0, 0, 0, 9, 0, 10, 0, 0, 0],
		[0, 0, 4, 14, 10, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		];

g.dijkstra(0);

--


---
gfg practice

from collections import defaultdict
class Solution:

    #Function to find the shortest distance of all the vertices
    #from the source vertex S.
    def dijkstra(self, V, adj, S):
        graph = defaultdict(list)
        for i in range(V):
            for nodes in adj[i]:
                graph[i].append((nodes[0],nodes[1]))
            
        distance = [float("inf")] * V
        s = set([S])
        distance[S] = 0
        res = []
        while s:
            curr = s.pop()
            for node, weight in graph[curr]:
                if distance[curr] + weight < distance[node]:
                    distance[node] = distance[curr] + weight
                    s.add(node)
    
        return distance
---

=====================================================================================================================================================

-- bellmon ford

-- https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
-- https://www.youtube.com/watch?v=-dlGfzdfHvM&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=14
-- https://www.youtube.com/watch?v=75yC1vbS8S8&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=28


--
# Python3 program for Bellman-Ford's single source
# shortest path algorithm.

# Class to represent a graph
class Graph:

	def __init__(self, vertices):
		self.V = vertices # No. of vertices
		self.graph = []

	# function to add an edge to graph
	def addEdge(self, u, v, w):
		self.graph.append([u, v, w])
		
	# utility function used to print the solution
	def printArr(self, dist):
		print("Vertex Distance from Source")
		for i in range(self.V):
			print("{0}\t\t{1}".format(i, dist[i]))
	
	# The main function that finds shortest distances from src to
	# all other vertices using Bellman-Ford algorithm. The function
	# also detects negative weight cycle
	def BellmanFord(self, src):

		# Step 1: Initialize distances from src to all other vertices
		# as INFINITE
		dist = [float("Inf")] * self.V
		dist[src] = 0


		# Step 2: Relax all edges |V| - 1 times. A simple shortest
		# path from src to any other vertex can have at-most |V| - 1
		# edges
		for _ in range(self.V - 1):
			# Update dist value and parent index of the adjacent vertices of
			# the picked vertex. Consider only those vertices which are still in
			# queue
			for u, v, w in self.graph:
				if dist[u] != float("Inf") and dist[u] + w < dist[v]:
						dist[v] = dist[u] + w

		# Step 3: check for negative-weight cycles. The above step
		# guarantees shortest distances if graph doesn't contain
		# negative weight cycle. If we get a shorter path, then there
		# is a cycle.

		for u, v, w in self.graph:
				if dist[u] != float("Inf") and dist[u] + w < dist[v]:
						print("Graph contains negative weight cycle")
						return
						
		# print all distance
		self.printArr(dist)

g = Graph(5)
g.addEdge(0, 1, -1)
g.addEdge(0, 2, 4)
g.addEdge(1, 2, 3)
g.addEdge(1, 3, 2)
g.addEdge(1, 4, 2)
g.addEdge(3, 2, 5)
g.addEdge(3, 1, 1)
g.addEdge(4, 3, -3)

# Print the solution
g.BellmanFord(0)

# Initially, Contributed by Neelam Yadav
# Later On, Edited by Himanshu Garg

--


-- bellmon ford in weighted directed graph (Negative weight cycle)
-- https://practice.geeksforgeeks.org/problems/negative-weight-cycle3504/1

-- ( Refer this )
class Solution:
	def isNegativeWeightCycle(self, n, edges):
        dist = [float("inf")] * (n)
        dist[0] = 0
        

	# edges in form (u, v, w)
        for _ in range(n-1):
            for u, v, w in edges:
                if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
        
        for u, v, w in edges:
            if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                return 1
        return 0
--



======================================================================================================================================================



-- Floyd warshell

-- https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/



==========================  IMPORTANT  ========================================================================================================================

-- Union find

-- https://www.geeksforgeeks.org/union-find/
-- https://practice.geeksforgeeks.org/problems/union-find/1

--
# Python Program for union-find algorithm to detect cycle in a undirected graph
# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both

from collections import defaultdict

#This class represents a undirected graph using adjacency list representation
class Graph:

	def __init__(self,vertices):
		self.V= vertices #No. of vertices
		self.graph = defaultdict(list) # default dictionary to store graph


	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

	# A utility function to find the subset of an element i
	def find_parent(self, parent,i):
		if parent[i] == -1:
			return i
		if parent[i]!= -1:
			return self.find_parent(parent,parent[i])

	# A utility function to do union of two subsets
	def union(self,parent,x,y):
		parent[x] = y



	# The main function to check whether a given graph
	# contains cycle or not
	def isCyclic(self):
		
		# Allocate memory for creating V subsets and
		# Initialize all subsets as single element sets
		parent = [-1]*(self.V)

		# Iterate through all edges of graph, find subset of both
		# vertices of every edge, if both subsets are same, then
		# there is cycle in graph.
		for i in self.graph:
			for j in self.graph[i]:
				x = self.find_parent(parent, i)
				y = self.find_parent(parent, j)
				if x == y:
					return True
				self.union(parent,x,y)


# Create a graph given in the above diagram
g = Graph(3)
g.addEdge(0, 1)
g.addEdge(1, 2)
g.addEdge(2, 0)

if g.isCyclic():
	print ("Graph contains cycle")
else :
	print ("Graph does not contain cycle ")

#This code is contributed by Neelam Yadav

--



====================================================================================================================================================

-- min spanning tree (n-1 edges of minimum spanning tree)

-- (Refer this)   https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ 


--

What is a Minimum Spanning Tree?


The cost of the spanning tree is the sum of the weights of all the edges in the tree.
 There can be many spanning trees. Minimum spanning tree is the spanning tree where the 
cost is minimum among all the spanning trees. There also can be many minimum spanning trees.


--



1). prims
-- https://www.youtube.com/watch?v=xsM8i0jVF1w&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=19
-- https://www.youtube.com/watch?v=HnD676J56ak&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=20
-- https://www.youtube.com/watch?v=oNTsS8lGDHw&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=21
-- https://pythonwife.com/kruskal-and-prims-algorithm-in-python/

-- https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp
-- https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1
-- https://takeuforward.org/data-structure/minimum-spanning-tree-mst-using-prims-algo/
-- https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/discuss/831786/minimum-weight-spanning-tree-prims-algorithm


-- prims algo code


--



2) kruskal
-- https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/



-- kruskals algo with heap

#Krushkal's Algorithm
import heapq
class Solution:
   
   #Function to find sum of weights of edges of the Minimum Spanning Tree.
   def spanningTree(self, V, adj):
       
       #code here
       #Krushkal Algorithm
       p=[0]*V
       rank=[0]*V
       for i in range(V):
           p[i]=i
       def par(node):
           if node==p[node]:
               return node
           p[node]=par(p[node])
           return  p[node]
       def union(u,v):
           a=par(u)
           b=par(v)
           if rank[a]<rank[b]:
               p[a]=b
           elif rank[b]<rank[a]:
               p[b]=a
           else:
               p[b]=a
               rank[b]+=1
       q=[]        
       for u in range(V):
           for v,w in adj[u]:
               q.append([u,v,w])
       q=sorted(q,key=lambda x:x[2])
       cost=0
       for u,v,w in q:
           if par(u) != par(v):
               cost+=w
               union(u,v)
       return cost


--





-- Kruskals algo
# Python program for Kruskal's algorithm to find
# Minimum Spanning Tree of a given connected,
# undirected and weighted graph

from collections import defaultdict

# Class to represent a graph


class Graph:

	def __init__(self, vertices):
		self.V = vertices # No. of vertices
		self.graph = [] # default dictionary
		# to store graph

	# function to add an edge to graph
	def addEdge(self, u, v, w):
		self.graph.append([u, v, w])

	# A utility function to find set of an element i
	# (uses path compression technique)
	def find(self, parent, i):
		if parent[i] == i:
			return i
		return self.find(parent, parent[i])

	# A function that does union of two sets of x and y
	# (uses union by rank)
	def union(self, parent, rank, x, y):
		xroot = self.find(parent, x)
		yroot = self.find(parent, y)

		# Attach smaller rank tree under root of
		# high rank tree (Union by Rank)
		if rank[xroot] < rank[yroot]:
			parent[xroot] = yroot
		elif rank[xroot] > rank[yroot]:
			parent[yroot] = xroot

		# If ranks are same, then make one as root
		# and increment its rank by one
		else:
			parent[yroot] = xroot
			rank[xroot] += 1

	# The main function to construct MST using Kruskal's
		# algorithm
	def KruskalMST(self):

		result = [] # This will store the resultant MST
		
		# An index variable, used for sorted edges
		i = 0
		
		# An index variable, used for result[]
		e = 0

		# Step 1: Sort all the edges in
		# non-decreasing order of their
		# weight. If we are not allowed to change the
		# given graph, we can create a copy of graph
		self.graph = sorted(self.graph,
							key=lambda item: item[2])

		parent = []
		rank = []

		# Create V subsets with single elements
		for node in range(self.V):
			parent.append(node)
			rank.append(0)

		# Number of edges to be taken is equal to V-1
		while e < self.V - 1:

			# Step 2: Pick the smallest edge and increment
			# the index for next iteration
			u, v, w = self.graph[i]
			i = i + 1
			x = self.find(parent, u)
			y = self.find(parent, v)

			# If including this edge doesn't
			# cause cycle, include it in result
			# and increment the indexof result
			# for next edge
			if x != y:
				e = e + 1
				result.append([u, v, w])
				self.union(parent, rank, x, y)
			# Else discard the edge

		minimumCost = 0
		print ("Edges in the constructed MST")
		for u, v, weight in result:
			minimumCost += weight
			print("%d -- %d == %d" % (u, v, weight))
		print("Minimum Spanning Tree" , minimumCost)

# Driver code
g = Graph(4)
g.addEdge(0, 1, 10)
g.addEdge(0, 2, 6)
g.addEdge(0, 3, 5)
g.addEdge(1, 3, 15)
g.addEdge(2, 3, 4)

# Function call
g.KruskalMST()

# This code is contributed by Neelam Yadav

--




========================================================================================================================================================


-- Connected Componets (also refer the code for ==> number of provences)   =>  O(V+E)

-- Given an undirected graph, print all connected components line by line.
 For example consider the following graph.


--
# Python program to print connected
# components in an undirected graph


class Graph:

	# init function to declare class variables
	def __init__(self, V):
		self.V = V
		self.adj = [[] for i in range(V)]

	def DFSUtil(self, temp, v, visited):

		# Mark the current vertex as visited
		visited[v] = True

		# Store the vertex to list
		temp.append(v)

		# Repeat for all vertices adjacent
		# to this vertex v
		for i in self.adj[v]:
			if visited[i] == False:

				# Update the list
				temp = self.DFSUtil(temp, i, visited)
		return temp

	# method to add an undirected edge
	def addEdge(self, v, w):
		self.adj[v].append(w)
		self.adj[w].append(v)

	# Method to retrieve connected components
	# in an undirected graph
	def connectedComponents(self):
		visited = []
		cc = []
		for i in range(self.V):
			visited.append(False)
		for v in range(self.V):
			if visited[v] == False:
				temp = []
				cc.append(self.DFSUtil(temp, v, visited))
		return cc


# Driver Code
if __name__ == "__main__":

	# Create a graph given in the above diagram
	# 5 vertices numbered from 0 to 4
	g = Graph(5)
	g.addEdge(1, 0)
	g.addEdge(2, 3)
	g.addEdge(3, 4)
	cc = g.connectedComponents()
	print("Following are connected components")
	print(cc)

# This code is contributed by Abhishek Valsan

--


-- Two types of algo to find and print SCC
 
1 ==> Kosaraju’s algorithm for strongly connected components. 
2 ==> Tarjan’s Algorithm to find Strongly Connected Components






-- Kosarajus Algo for strongly connected components O(V+E)

-- A directed graph is strongly connected if there is a path between all pairs of vertices. 
A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.
 For example, there arel 3 SCCs in the following graph.

==
-- https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1
-- https://www.geeksforgeeks.org/strongly-connected-components/
==

--

from collections import defaultdict
class Solution:
    # components
    res = []
    #Function to find number of strongly connected components in the graph.
    def kosaraju(self, V, adjacency):
        # dfs and stack for the first time
        vis = [False] * V
        stack = []
        adj = defaultdict(list)
        for i in range(V):
            for nodes in adjacency[i]:
                adj[i].append(nodes)
                
        def dfs(node, vis, adjc, stack, sec):
            if sec:
                self.res.append(node)
            vis[node] = True
            
            for i in adjc[node]:
                if not vis[i]:
                    dfs(i, vis, adjc, stack, sec)
            if not sec:      
                stack.append(node)
                
        # reverse the edges
        def getTranspose(adjc):
            g = defaultdict(list)
            for i in adjc:
			    for j in adjc[i]:
			        
			        g[j].append(i)
            return g
            
            
            
        # first loop
        for i in range(V):
            if not vis[i]:
                dfs(i, vis, adj, stack, False)
                
    
        # reverse the edges ==> get the tranpose
        g = getTranspose(adj)
        vis = [False] * V
        count = 0
        while stack:
            temp = stack.pop()
            if vis[temp] == False:
                dfs(temp, vis, g, stack, True)
                count += 1
                
        
        return count   
--



=====================================================================================================================================================


-- DFS

-- Min time to collect all apples

-- https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/



--
class Solution(object):
    def minTime(self, n, edges, hasApple):
        if len(edges) == 0 or n <= 0: return 0
        all_has_apple = False
        status = [-1] * len(hasApple)
        for i in range(len(hasApple)):
            status[i] = 1 if hasApple[i] else 0
            all_has_apple = all_has_apple and hasApple[i]
        graph = {}
        for f, t in edges:
            if f not in graph: graph[f] = []
            if t not in graph: graph[t] = []
            graph[f].append(t)
            graph[t].append(f)
        has, time = self.dfs(graph, 0, status)
        return time

    def dfs(self, graph, start, status):
        if status[start] == 1: has, time = True, 0
        else: has, time = False, 0
        if start not in graph:
            return has, time
        status[start] = -1
        for node in graph[start]:
            if status[node] >= 0:
                cur_has, cur_time = self.dfs(graph, node, status)
                if cur_has:
                    time += cur_time + 2
                has = has or cur_has
        return has, time
        
--

========================================================================================================================================================================================

-- Convert adjacency list to matrix


-- https://www.geeksforgeeks.org/convert-adjacency-list-to-adjacency-matrix-representation-of-a-graph/


--
# Python3 program to implement
# the above approach

# Function to insert vertices
# to adjacency list
def insert(adj, u, v):

	# Insert a vertex v to vertex u
	adj[u].append(v)
	return

# Function to display adjacency list
def printList(adj, V):
	
	for i in range(V):
		print(i, end = '')
		
		for j in adj[i]:
			print(' --> ' + str(j), end = '')
			
		print()
		
	print()
		
# Function to convert adjacency
# list to adjacency matrix
def convert(adj, V):

	# Initialize a matrix
	matrix = [[0 for j in range(V)]
				for i in range(V)]
	
	for i in range(V):
		for j in adj[i]:
			matrix[i][j] = 1
	
	return matrix

# Function to display adjacency matrix
def printMatrix(adj, V):
	
	for i in range(V):
		for j in range(V):
			print(adj[i][j], end = ' ')
			
		print()
		
	print()
		
# Driver code
if __name__=='__main__':

	V = 5

	adjList = [[] for i in range(V)]

	# Inserting edges
	insert(adjList, 0, 1)
	insert(adjList, 0, 4)
	insert(adjList, 1, 0)
	insert(adjList, 1, 2)
	insert(adjList, 1, 3)
	insert(adjList, 1, 4)
	insert(adjList, 2, 1)
	insert(adjList, 2, 3)
	insert(adjList, 3, 1)
	insert(adjList, 3, 2)
	insert(adjList, 3, 4)
	insert(adjList, 4, 0)
	insert(adjList, 4, 1)
	insert(adjList, 4, 3)

	# Display adjacency list
	print("Adjacency List: ")
	printList(adjList, V)

	# Function call which returns
	# adjacency matrix after conversion
	adjMatrix = convert(adjList, V)

	# Display adjacency matrix
	print("Adjacency Matrix: ")
	printMatrix(adjMatrix, V)

# This code is contributed by rutvik_56

--

============================================================================================================================================

-- Convert Matrix to Adjacency list


-- https://www.geeksforgeeks.org/convert-adjacency-matrix-to-adjacency-list-representation-of-graph/


--
# Python 3 program to convert Adjacency matrix
# representation to Adjacency List

from collections import defaultdict
# converts from adjacency matrix to adjacency list
def convert(a):
	adjList = defaultdict(list)
	for i in range(len(a)):
		for j in range(len(a[i])):
			if a[i][j]== 1:
				adjList[i].append(j)
	return adjList

# driver code
a =[[0, 0, 1], [0, 0, 1], [1, 1, 0]] # adjacency matrix
AdjList = convert(a)
print("Adjacency List:")
# print the adjacency list
for i in AdjList:
	print(i, end ="")
	for j in AdjList[i]:
		print(" -> {}".format(j), end ="")
	print()

# This code is contributed by Muskan Kalra.

--


==========================================================================================================================================================

-- Number of provices (Connected components) ==> O(V**2)


-- https://github.com/Prince-1501/Hello_world-Competiitve-Programming/blob/master/Leetcode/Graph/Number%20of%20Provinces.cpp
-- https://www.youtube.com/watch?v=W3YyfjxKcA0
-- https://practice.geeksforgeeks.org/problems/number-of-provinces/1
-- https://www.geeksforgeeks.org/connected-components-in-an-undirected-graph/
-- https://www.geeksforgeeks.org/convert-adjacency-list-to-adjacency-matrix-representation-of-a-graph/



--
class Solution:
    globalset = []
    def numProvinces(self, adj, V):
        def dfs(s, n, isConnected, visited):
            visited[s] = True;
            #s = 1
            
            # 0 1 2 3 4  -- index
            # 1 2 3 4 5  -- city name
            # 1 1 0 1 0  -- connection
            
            '''
            # for the adjacent nodes
            adj = []
            for i in range(n):
                x =  isConnected[s][i]  # x = connection
                if(x == 1):
                    adj.append(i)
            '''
            
            # run dfs only for the ones that has edges
            for i in range(n):
                if not visited[i] and isConnected[s][i] == 1:
                    dfs(i, n, isConnected, visited)
        
        n = len(adj)
        visited = [False] * V
        count = 0
        
        for i in range(n):
            if not visited[i]:
                count += 1
                dfs(i, len(adj), adj, visited)
        
        return count
--

===================================================================================================================================================
-- transpose a graph


-- https://www.geeksforgeeks.org/transpose-graph/#:~:text=We%20traverse%20the%20adjacency%20list,v%20of%20the%20new%20graph.


--
# Python3 program to find transpose of a graph.

# function to add an edge from vertex
# source to vertex dest
def addEdge(adj, src, dest):
	adj[src].append(dest)

# function to print adjacency list
# of a graph
def displayGraph(adj, v):
	for i in range(v):
		print(i, "--> ", end = "")
		for j in range(len(adj[i])):
			print(adj[i][j], end = " ")
		print()

# function to get Transpose of a graph
# taking adjacency list of given graph
# and that of Transpose graph
def transposeGraph(adj, transpose, v):
	
	# traverse the adjacency list of given
	# graph and for each edge (u, v) add
	# an edge (v, u) in the transpose graph's
	# adjacency list
	for i in range(v):
		for j in range(len(adj[i])):
			addEdge(transpose, adj[i][j], i)

# Driver Code
if __name__ == '__main__':

	v = 5
	adj = [[] for i in range(v)]
	addEdge(adj, 0, 1)
	addEdge(adj, 0, 4)
	addEdge(adj, 0, 3)
	addEdge(adj, 2, 0)
	addEdge(adj, 3, 2)
	addEdge(adj, 4, 1)
	addEdge(adj, 4, 3)

	# Finding transpose of graph represented
	# by adjacency list adj[]
	transpose = [[]for i in range(v)]
	transposeGraph(adj, transpose, v)

	# displaying adjacency list of
	# transpose graph i.e. b
	displayGraph(transpose, v)

# This code is contributed by PranchalK

--


============================================================================================================================================================================

-- Number of operations to make network connected

-- https://leetcode.com/problems/number-of-operations-to-make-network-connected/submissions/
-- https://leetcode.com/problems/number-of-operations-to-make-network-connected/discuss/477806/Python-Union-Find


--
from collections import defaultdict
class Solution(object):
    def makeConnected(self, n, connections):
        # important edges cases
        if len(connections) < n-1: # this is a edge condi. to connect n components we need min n-1 cables. 
            return -1
        g = defaultdict(list)
        for i in connections:
            g[i[0]].append(i[1])
            g[i[1]].append(i[0])
        
        def dfs(node, vis, g):
            vis[node] = True
            for i in g[node]:
                if not vis[i]:
                    dfs(i, vis, g)

        vis = [False] * n
        count =0
        for node in range(n):
            if not vis[node]:
                count += 1 
                dfs(node, vis, g)
                
        return count - 1
--

============================================================================================================================================================

-- Bridges in graph ( when removed edge, the graph is broken into two or more components)

-- An edge in an undirected connected graph is a bridge if removing it disconnects 
the graph. For a disconnected undirected graph, definition is similar, a bridge 
is an edge removing which increases number of disconnected components. 


-- https://www.geeksforgeeks.org/bridge-in-a-graph/
-- https://leetcode.com/problems/critical-connections-in-a-network/submissions/

-- two arrays used 

=> time array
=> lowest time array


--
from collections import defaultdict
class Solution(object):
    res = []
    def criticalConnections(self, n, connections):
        g = defaultdict(list)
        for i in connections:
            g[i[0]].append(i[1])
            g[i[1]].append(i[0])
        print(g)
        vis = [False] * n
        low = [float("inf")] * n
        time = 0
        tin = [float("inf")] * n
            
        def dfs(parent, node, low, tin, vis, g, time):
            vis[node] = True
            time = time + 1
            low[node] = time
            tin[node] = time
            
            for i in g[node]:  
                if i == parent: continue
                if not vis[i]:
                    # apply dfs for adjacents
                    dfs(node, i, low, tin, vis, g, time)
                    
                    # after returning to the node
                    # minimum between himself and the adjacent
                    
                    low[node] = min(low[node], low[i])
                    
                    # formulae for the bridge
                    # if low[adj] > time insertion of himself then its a bridge
                    if (low[i] > tin[node]):
                        print([i, node])
                        self.res.append([i,node])
                
                
                # if visited then min of himself and adjacent of time of insertion
                else:
                    low[node] = min(low[node], tin[i])
                     
        for i in range(n):
            if not vis[i]:
                dfs(-1, i, low, tin, vis, g, time)
        print(self.res)
        return self.res
            
--


======================================================================================================================================================================

-- Longest cycle in a graph

-- https://www.youtube.com/watch?v=vc_kz2M-jw4
-- https://leetcode.com/problems/longest-cycle-in-a-graph/submissions/


--

class Solution(object):
    ans = -1    
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        vis = [False] * n
        dis = [0] * n 
        extra = [False] * n # extra array for directed graph
        def dfs(node, dis, vis, edges, distance, extra):
            if node != -1:
                if not vis[node]: 
                    vis[node] = True
                    extra[node] = True
                    dis[node] = distance
                    dfs(edges[node], dis, vis, edges, distance + 1, extra)
                
                # already visited then
                elif extra[node]:
                    self.ans = max(self.ans, distance - dis[node])
                extra[node] = False
                          
        # run dfs for the entire edge list
        for i in range(n):
            if not vis[i]:
                dfs(i, dis, vis, edges, 0, extra)
        
        return self.ans
       
--


============================================================================================================================================================================================

-- Find the coleset node to given two nodes

-- https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/
-- https://www.youtube.com/watch?v=S0jZu7H7nQ0


---
class Solution:
    def dfs(self, node, dis, vis, distance, edges):
        if node != -1 and not vis[node]:
            vis[node] = True
            dis[node] = distance
            self.dfs(edges[node], dis, vis, distance + 1, edges)
            
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        dist_node2 = [-1] * len(edges)  # distance array for node1
        dist_node1 = [-1] * len(edges)  # distance array for node2
        vis = [False] * len(edges)
        
        # dfs for only two nodes
        self.dfs(node1, dist_node1, vis, 0, edges)
        
        # initialize visited array again
        vis = [False] * len(edges)
        self.dfs(node2, dist_node2, vis, 0, edges)
        
        print(dist_node1, dist_node2)
        # we have two distance arrays
        # extract the max of two arrays in that answer is min value
        
        ans = len(edges)
        res = -1
        for i in range(len(edges)):
            # only perform the action if the nodes can be visited by the nodes by -1 then dont perform operation
            if dist_node1[i] != -1 and dist_node2[i] != -1:
                if max(dist_node1[i], dist_node2[i]) < ans:
                    ans = max(dist_node1[i], dist_node2[i])
                    res = i
        return res
       

--
================================================================================================================================================================================
-- Disjoint set (Union find)

-- https://www.geeksforgeeks.org/union-find/
-- https://practice.geeksforgeeks.org/problems/union-find/1
-- https://www.youtube.com/watch?v=3gbO7FDYNFQ&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=22

--
class Solution:
    
    def findPar(self, par, node):
        # if node equal to himself
        
        # eg 7 => 6 => 5 => 3 and goes back
        if node == par[node]:
            return node
        par[node] = self.findPar(par, par[node]) # this is path compression
        return  par[node] 
        
    
    #Function to merge two nodes a and b.
    
    # Both functions has parent array and rank array 
    # initially parent array is ==> [0, 1, 2, ...n] parent of nodes at first has the same nodes
    
    # initially ranks of nodes are 1 or 0 either one [1, 1, 1, .... till n]
    def union_(self,a,b,par,rank):
        a = self.findPar(par, a)
        b = self.findPar(par, b)
        
        if rank[a] > rank[b]:
            par[b] = a
        elif rank[b] > rank[a]:
            par[a] = b
        else:
            par[a] = b
            rank[b] += 1
        
        
        
    #Function to check whether 2 nodes are connected or not.
    def isConnected(self,x,y,par,rank):
        if self.findPar(par, x) == self.findPar(par, y):
            return 1
        return 0

--


=========================================================================================================================================================================================

-- 