# BFS

graph = {
  1 : [2,3],
  6 : [4,5],
  2 : [1,4,5],
  3 : [1,5],
  4 : [2,5,6],
  5 : [2,3,4,6],
}
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
        if node not in graph:
            print("invalid")
            return
        visited.append(node)
        queue.append(node)
        while queue:          
            m = queue.pop(0) 
            print (m) 
            for neighbour in graph[m]:
                if neighbour not in visited:
                    visited.append(neighbour)
                    queue.append(neighbour)

# DFS 
def dfs(graph, start, visted):
    print(start)
    visited.append(start)
    for i in graph[start]:
        if i not in visited:
            dfs(graph, i, visited)
            
dfs(graph, 1, visited)
#bfs(visited, graph,0)


=============================== DFS ==================================================================

-- method -1 


--
from collections import defaultdict
class Solution:
    res = []
    #Function to return a list containing the DFS traversal of the graph.
    def dfsOfGraph(self, V, adj):
        vis = []
        def dfs(node, vis, adj):
            vis.append(node)
            self.res.append(node)
            for i in adj[node]:
                if i not in vis:
                    dfs(i, vis, adj)
                    
        
        dfs(0, vis, adj)
        #print(self.res)
        return self.res
--


-- method - 2

# Python program to print DFS traversal for complete graph
from collections import defaultdict

# This class represents a directed graph using adjacency
# list representation
class Graph:

	# Constructor
	def __init__(self):

		# default dictionary to store graph
		self.graph = defaultdict(list)

	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

	# A function used by DFS
	def DFSUtil(self, v, visited):

		# Mark the current node as visited and print it
		visited[v]= True
		print v,
		# or push the v into node

		# Recur for all the vertices adjacent to
		# this vertex
		for i in self.graph[v]:
			if visited[i] == False:
				self.DFSUtil(i, visited)


	# The function to do DFS traversal. It uses
	# recursive DFSUtil()
	def DFS(self):
		V = len(self.graph) #total vertices

		# Mark all the vertices as not visited
		visited =[False]*(V)

		# Call the recursive helper function to print
		# DFS traversal starting from all vertices one
		# by one
		for i in range(V):
			if visited[i] == False:
				self.DFSUtil(i, visited)


# Driver code
# Create a graph given in the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print "Following is Depth First Traversal"
g.DFS()

# This code is contributed by Neelam Yadav



=============================== cycle detetcion in directed graph =========================
-- 
=> https://www.youtube.com/watch?v=dc5Pn-YEPVY&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=8
=> https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1
--
class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def __init__(self):
        self.graph = {}
        self.visited = []
        self.instack = []
        
    def isCyclic(self, node):
        self.visited[node] = True
        self.instack[node] = True
        for i in self.graph[node]:
            if not self.visited[i] and self.isCyclic(i):
                return True
            elif self.instack[i]:
                return True
        self.instack[node] = False
        return False
        
    def solve(self, A, B):
        for i in range(1, A + 1):
            self.graph[i] = []
        for (src, dst) in B:
            self.graph[src].append(dst)
        
        self.visited = [False] * (A + 1)
        self.instack = [False] * (A + 1)
        
        for i in range(1, A + 1):
            if not self.visited[i]:
                if self.isCyclic(i):
                    return 1
        return 0

input == 
A = 5
B = [[1, 4],
  [2, 1],
  [4, 3],
  [4, 5],
  [2, 3],
  [2, 4],
  [1, 5],
  [5, 3],
  [2, 5],
  [5, 1],
  [4, 2],
  [3, 1],
  [5, 4],
  [3, 4],
  [1, 3],
  [4, 1],
  [3, 5],
  [3, 2],
  [5, 2],
]
================================================== cycle detection in undirected graph================================


--
=> https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1
=> https://www.youtube.com/watch?v=GLGsIZGLvA0&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=7



--
# cycle detetction in undirected graph
A = 5
B = [[1, 4],
  [2, 1],
  [4, 3],
  [4, 5],
  [2, 3],
  [2, 4],
  [1, 5],
  [5, 3],
  [2, 5],
  [5, 1],
  [4, 2],
  [3, 1],
  [5, 4],
  [3, 4],
  [1, 3],
  [4, 1],
  [3, 5],
  [3, 2],
  [5, 2],
]
from collections import defaultdict
class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def dfs(self,node,parent,visited):
        
        visited[node]=True
        
        for i in self.graph[node]:
            
            if visited[i]==True and i!=parent:
                return True
                
            elif visited[i]==False and self.dfs(i,node,visited)==True:
                return True
                
            
        return False
        
    def solve(self, v, a):
        
        self.graph=defaultdict(list)
        visited={}
        
        for i in a:
            self.graph[i[0]].append(i[1])
            self.graph[i[1]].append(i[0])
            visited[i[0]]=False
            visited[i[1]]=False
            
        for i in visited.keys():
            #print(i)
            if visited[i]==False:
                if self.dfs(i,-1,visited):
                    return 1
        return 0
        
    
===========================================================================================================

========================================= snakes ladder problem =======================================

class Solution:
    # @param A : list of list of integers
    # @param B : list of list of integers
    # @return an integer
    def snakeLadder(self, A, B):
        jump = {}
        for a in A:
            start, end = a
            jump[start] = end
            
        for b in B:
            start, end = b
            jump[start] = end
            
        initial = 1
        final = 100
        queue = []
        visited = set()
        queue.append((initial, 0))
        
        while queue:
            val, count = queue.pop(0)
            if val in jump:
                val = jump[val] 
            
            if val in visited:
                continue
            
            if val == final:
                return count
                
            visited.add(val)
            for i in range(val, val+7):
                if i not in visited and i <= 100:
                    queue.append((i, count+1))
                    
        return -1
            
================================================= Region in Binary matrix ==================================================
-- https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/
-- https://www.youtube.com/watch?v=ABVvTxH0qsw
-- https://practice.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

class Solution:
    # @param A : list of list of integers
    # @return an integer
    def solve(self, A):
        max_count = 0
        for i in range(len(A)):
            for j in range(len(A[0])):
                if A[i][j] == 1:
                    local_sep_count = self.countCells(A,i,j)
                    max_count = max(max_count, local_sep_count)
        return max_count
    
    def countCells(self, A, row, col):
        if any([row < 0, col< 0, row>=len(A), col>=len(A[0])]):
            return 0
        if A[row][col] == 0:
            return 0
        cell_count = 1
        A[row][col] = 0
        for r in range(row-1, row+2):
            for c in range(col-1, col+2):
                if (r!=row or c != col):
                    cell_count += self.countCells(A, r, c)
        return cell_count


A = [  [0, 0, 1, 1, 0],
        [1, 0, 1, 1, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 0, 0, 1],
    ]
test = Solution()
print(test.solve(A))


======================================================================================================
================================== Min cost path =====================================================

i/p  => 
 A = 3
 B = 3
 C = ["RRR","DDD","UUU"]

code = 
import collections
class Solution:
    # @param A : integer
    # @param B : integer
    # @param C : list of strings
    # @return an integer
    def solve(self, A, B, C):
        queue = collections.deque([])
        queue.append((0,0,0))
        #answer = 999
        completed = [[False for i in range(B)] for j in range(A)]
        
        while(len(queue) != 0):
            i,j,cost = queue.popleft()
            if(completed[i][j] == True):
                continue
            completed[i][j] = True
            if(i == A-1 and j == B-1):
                return cost
            
            if(j+1<B and (i<A and j<B)):   
                if(C[i][j] == 'R'):
                    queue.appendleft(( i, j+1,cost))
                else:
                    queue.append(( i, j+1,cost+1))    
                    
            if(i+1<A and (i<A and j<B)):  
                if(C[i][j] == 'D'):
                    queue.appendleft(( i+1, j,cost))
                else:
                    queue.append(( i+1, j,cost+1))
        
            
            if(j-1>=0 and (i<A and j<B)):
                if(C[i][j] == 'L'):
                    queue.appendleft(( i, j-1,cost))
                else:
                    queue.append(( i, j-1,cost+1))
        
            if(i-1>=0 and (i<A and j<B)):
                
                if(C[i][j] == 'U' ):
                    queue.appendleft(( i-1, j,cost))
                else:
                    queue.append(( i-1, j,cost+1))
            
        
            
        return cost
===============================================================================================================
=========================== path in directed graph =========================================

class Solution:
    # @param A : integer
    # @param B : list of list of integers
    # @return an integer
    def solve(self, A, edges):
        
        if len(edges) == 0:
            return 0
            
        adj = {}
        
        for s,e in edges:
            if s not in adj:
                adj[s] = []
            if e not in adj:
                adj[e] = []
            adj[s].append(e)
            
        visited = {}
        
        
        q = [1]
        visited[1] = True
        while q:
            node = q.pop()
            if node == A:
                return 1
            for n in adj[node]:
                if n not in visited:
                    visited[n] = True
                    q.append(n)
            
            
        return 0 

==================================================== Number of islands ================================

-- https://www.geeksforgeeks.org/find-number-of-islands/
-- https://practice.geeksforgeeks.org/problems/find-the-number-of-islands/1
-- https://leetcode.com/problems/number-of-islands/submissions/


# Program to count islands in boolean 2D matrix
class Graph:

	def __init__(self, row, col, graph):
		self.ROW = row
		self.COL = col
		self.graph = graph

	# A utility function to do DFS for a 2D
	# boolean matrix. It only considers
	# the 8 neighbours as adjacent vertices
	def DFS(self, i, j):
		if i < 0 or i >= len(self.graph) or j < 0 or j >= len(self.graph[0]) or self.graph[i][j] != 1:
			return

		# mark it as visited
		self.graph[i][j] = -1

		# Recur for 8 neighbours
		self.DFS(i - 1, j - 1)
		self.DFS(i - 1, j)
		self.DFS(i - 1, j + 1)
		self.DFS(i, j - 1)
		self.DFS(i, j + 1)
		self.DFS(i + 1, j - 1)
		self.DFS(i + 1, j)
		self.DFS(i + 1, j + 1)

	# The main function that returns
	# count of islands in a given boolean
	# 2D matrix
	def countIslands(self):
		# Initialize count as 0 and traverse
		# through the all cells of
		# given matrix
		count = 0
		for i in range(self.ROW):
			for j in range(self.COL):
				# If a cell with value 1 is not visited yet,
				# then new island found
				if self.graph[i][j] == 1:
					# Visit all cells in this island
					# and increment island count
					self.DFS(i, j)
					count += 1

		return count


graph = [
	[1, 1, 0, 0, 0],
	[0, 1, 0, 0, 1],
	[1, 0, 0, 1, 1],
	[0, 0, 0, 0, 0],
	[1, 0, 1, 0, 1]
]


row = len(graph)
col = len(graph[0])

g = Graph(row, col, graph)

print("Number of islands is:", g.countIslands())

# This code is contributed by Shivam Shrey

========================================================================================================================

-- corona spread 

-- https://practice.geeksforgeeks.org/problems/269f61832b146dd5e6d89b4ca18cbd2a2654ebbe/1/#
-- https://www.geeksforgeeks.org/maximum-time-required-for-all-patients-to-get-infected/

class Solution:
    def helpaterp(self, hospital):
        r = len(hospital)
        c = len(hospital[0])
        time = 0
        q = []
        
        for i in range(r):
            for j in range(c):
                if hospital[i][j] == 2:
                    q.append((i,j))
        
        count = len(q)
        while count > 0:
            for _ in range(count):
                i , j = q.pop(0)
                self.push_neighbours(i,j,q,r,c,hospital) # check if exists a neigbours and is 1 then push to queue
            count = len(q)
            if count > 0:
                time+=1
        for i in range(r):
            for j in range(c):
                if hospital[i][j] == 1:
                    return -1
                    
        return time
                
        
    def push_neighbours(self,i,j,q,r,c,grid):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        for l in range(len(x)):
            if (i + x[l]<0 or i+x[l] >= r or j+y[l] < 0 or j+y[l]>=c or grid[i+x[l]][j+y[l]] != 1 ):
                continue
            q.append((i+x[l],j+y[l]))
            grid[i+x[l]][j+y[l]] = 2
                    

=============================================================================================================================================================================

-- Rotten oranges ( same as corona spread )

-- https://leetcode.com/problems/rotting-oranges/submissions/
-- https://neetcode.io/


--

class Solution(object):
    def orangesRotting(self, grid):
        # BFS
        r = len(grid)
        c = len(grid[0])
        time = 0
        count = 0
        q = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 2:
                    q.append((i, j))
                    
        while q:
            for _ in range(len(q)):
                i, j = q.pop(0)
                self.checkNei(i, j, grid, r, c, q)
            if q:
                time+=1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    return -1 
        return time
    
    def checkNei(self, i, j, grid, r, c, q):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        for l in range(len(x)):
            if (i + x[l]<0 or i+x[l] >= r or j+y[l] < 0 or j+y[l]>=c or grid[i+x[l]][j+y[l]] != 1 ):
                continue
            q.append((i +x[l], j+y[l]))
            grid[i + x[l]][j+y[l]] = 2

--


=======================================================================================================================

-- Min cost path

-- https://www.geeksforgeeks.org/min-cost-path-dp-6/
-- https://practice.geeksforgeeks.org/problems/minimum-cost-path3833/1

================================================================================================================================

-- minimum number of swaps to sort an array

-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/

===================================================================================================================================

-- min steps to reach destination

-- https://www.geeksforgeeks.org/minimum-steps-to-reach-a-destination/
-- code in book b8(kashih mehindrata) 
-- https://www.youtube.com/watch?v=RrWpucR--wU&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=23


# python program to count number of
# steps to reach a point
import sys

# Function to count number of steps
# required to reach a destination
	
# source -> source vertex
# step -> value of last step taken
# dest -> destination vertex
def steps(source, step, dest):
	
	#base cases
	if (abs(source) > (dest)) :
		return sys.maxsize
	
	if (source == dest):
		return step

	# at each point we can go
	# either way

	# if we go on positive side
	pos = steps(source + step + 1,
					step + 1, dest)

	# if we go on negative side
	neg = steps(source - step - 1,
					step + 1, dest)

	# minimum of both cases
	return min(pos, neg)
	

# Driver Code
dest = 11;
print("No. of steps required",
			" to reach " ,dest ,
		" is " , steps(0, 0, dest));
	

# This code is contributed by Sam007.


======================================================================================================================================

-- find strings can chained from ciecle

-- geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/
-- https://www.youtube.com/watch?v=WY6Jsp3NxIk&t=98s

===========================================================================================================================

-- snakes and ladders

-- https://www.geeksforgeeks.org/snake-ladder-problem-2/
-- https://www.youtube.com/watch?v=6lH4nO3JfLk

=====================================================================================================================================

-- alien dictionary

-- https://www.youtube.com/watch?v=h_4_Xb1bLgs&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=28
-- https://practice.geeksforgeeks.org/problems/alien-dictionary/1
-- als a video from neetcode
-- https://neetcode.io/

--
def alienDictionary(words):
    adj = { c : set() for w in words for c in w}
    print(adj)
    
    # {'w': set(), 
    # 'r': set(),
    # 't': set(), 
    # 'f': set(),
    # 'e': set()}
    
    for i in range(len(words) - 1):
        w1 = words[i]
        w2 = words[i+1]
        minLen = min(len(w1), len(w2))
        
        # if prefix words are same but 
        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:
            return ""
        for j in range(minLen):
            if w1[j] != w2[j]:
                adj[w1[j]].add(w2[j])
                break
        
    visit = {} # array to track the path ones
    res = []
        
    def dfs(node):
        if node in visit:
            return visit[node]
        visit[node] = True
        for i in adj[node]:
            if dfs(i):
                return True
        visit[node] = False
        res.append(node)
        
    for i in adj:
        if dfs(i):
            return ""
    return "".join(res[::-1])
    
arr = ["wrt" , "wrf", "er", "ett", "rftt"]
print(alienDictionary(arr))

--

======================================================================================================================================================

-- word ladder 

-- https://www.youtube.com/watch?v=h9iTnkgv05E&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=6
-- https://practice.geeksforgeeks.org/problems/word-ladder/0/?category[]=BFS&page=1&query=category[]BFSpage1

=============================================================================================================================================================

-- Topological sort (only exists on DAG (Directed Acyclic graph)) (DFS)


--
Linear Ordering of vertices of such that if there is an edge between u and v,
u appear before v in that ordering
--


-- https://www.youtube.com/watch?v=5lZ0iJMrUMk
-- https://www.youtube.com/watch?v=eMVg3Gvnva4&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=9
-- https://www.geeksforgeeks.org/topological-sorting/

--
-- Using DFS

from collections import defaultdict
class Solution:
    
    #Function to return list containing vertices in Topological order.
    def topoSort(self, V, adj):
        # V is Number of vertices
        # adj ==> { vertices  : [adj] }
        print(V, adj)
        stack = []
        visited = [False] * V
        for i in range(v):
            if visited[i] == False:
                self.dfs(visited, adj, stack, i)
        res = stack[::-1]
        return res
    
    def dfs(self, vis, adj, stack, i):
        vis[i] = True
        for ind in adj[i]:
            if vis[ind] == False:
                self.dfs(vis, adj, stack, ind)
        stack.append(i)

--


# Python program to print topological sorting of a DAG
from collections import defaultdict

# Class to represent a graph


class Graph:
	def __init__(self, vertices):
		self.graph = defaultdict(list) # dictionary containing adjacency List
		self.V = vertices # No. of vertices

	# function to add an edge to graph
	def addEdge(self, u, v):
		self.graph[u].append(v)

	# A recursive function used by topologicalSort
	def topologicalSortUtil(self, v, visited, stack):

		# Mark the current node as visited.
		visited[v] = True

		# Recur for all the vertices adjacent to this vertex
		for i in self.graph[v]:
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)

		# Push current vertex to stack which stores result
		stack.append(v)

	# The function to do Topological Sort. It uses recursive
	# topologicalSortUtil()
	def topologicalSort(self):
		# Mark all the vertices as not visited
		visited = [False]*self.V
		stack = []

		# Call the recursive helper function to store Topological
		# Sort starting from all vertices one by one
		for i in range(self.V):
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)

		# Print contents of the stack
		print(stack[::-1]) # return list in reverse order


# Driver Code
g = Graph(6)
g.addEdge(5, 2)
g.addEdge(5, 0)
g.addEdge(4, 0)
g.addEdge(4, 1)
g.addEdge(2, 3)
g.addEdge(3, 1)

print ("Following is a Topological Sort of the given graph")

# Function Call
g.topologicalSort()

# This code is contributed by Neelam Yadav


===========================================================================================================================================================

-- Kahns algo (Topological sort algo) (BFS)


--
Indegree - means number of incoming edges for the node
--

--
--

--
--


===========================================================================================================================================================


-- dijkstra algo

-- (Use this) https://www.codingninjas.com/codestudio/problems/dijkstra-s-shortest-path_920469?leftPanelTab=1&utm_source=youtube&utm_medium=affiliate&utm_campaign=Lovebabbar
-- https://practice.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1


-- https://www.google.com/search?q=dijkstra+algo&oq=dijkstra+algo&aqs=chrome..69i57.6343j0j15&sourceid=chrome&ie=UTF-8
-- https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/
-- https://www.youtube.com/watch?v=0kiTAw4xvy4&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=10
-- https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/?ref=lbp
-- https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/?ref=gcse

-- undirected unweighted graph
-- https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/?ref=lbp
-- https://www.youtube.com/watch?v=hwCWi7-bRfI&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=16

-- print paths
-- https://sites.google.com/site/rajboston1951/shortest-paths/8
-- https://www.geeksforgeeks.org/printing-paths-dijkstras-shortest-path-algorithm/?ref=lbp

-- weighted undirected array
-- https://www.youtube.com/watch?v=dVUR3Rm6biE



--
using queue and set
--
-- queue
from collections import deque, defaultdict

def dijkstra1(vec, vertices, edges, source):
    # Write your code here.
    graph = defaultdict(list)
    for s, d, w in vec:
        graph[s].append((d, w))
        graph[d].append((s, w))

    distance = [2147483647] * vertices
    q = deque([source])
    distance[source] = 0
    res = []
    while q:
        curr = q.popleft()
        for node, weight in graph[curr]:
            if distance[curr] + weight < distance[node]:
                distance[node] = distance[curr] + weight
                q.append(node)
                print(q)

    return distance

-- set (use this)
def dijkstra(vec, vertices, edges, source):
    # Write your code here.
    graph = defaultdict(list)
    for s, d, w in vec:
        graph[s].append((d, w))
        graph[d].append((s, w))

    distance = [2147483647] * vertices
    s = set([source])
    distance[source] = 0
    res = []
    while s:
        curr = s.pop()
        for node, weight in graph[curr]:
            if distance[curr] + weight < distance[node]:
                distance[node] = distance[curr] + weight
                s.add(node)

    return distance
--

-- using heap
# using min heap
    def dijkstra(vec, V, adj, S):
        # Write your code here.
        graph = defaultdict(list)
        for i in range(V):
            for nodes in adj[i]:
                graph[i].append((nodes[0],nodes[1]))
    
        distance = [float("inf")] * V
        q = [(0, S)]
        distance[S] = 0
        res = []
        while q:
            w, curr = heapq.heappop(q)
            for node, weight in graph[curr]:
                if distance[curr] + weight < distance[node]:
                    distance[node] = distance[curr] + weight
                    heapq.heappush(q, (distance[node], node))
    
        return distance
--

--
using matrix



class Graph():

	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]

	def printSolution(self, dist):
		print("Vertex \tDistance from Source")
		for node in range(self.V):
			print(node, "\t", dist[node])

	# A utility function to find the vertex with
	# minimum distance value, from the set of vertices
	# not yet included in shortest path tree
	def minDistance(self, dist, sptSet):

		# Initialize minimum distance for next node
		min = float("inf")

		# Search not nearest vertex not in the
		# shortest path tree
		for u in range(self.V):
			if dist[u] < min and sptSet[u] == False:
				min = dist[u]
				min_index = u

		return min_index

	# Function that implements Dijkstra's single source
	# shortest path algorithm for a graph represented
	# using adjacency matrix representation
	def dijkstra(self, src):

		dist = [float("inf")] * self.V
		dist[src] = 0
		sptSet = [False] * self.V

		for _ in range(self.V):

			# Pick the minimum distance vertex from
			# the set of vertices not yet processed.
			# x is always equal to src in first iteration
			x = self.minDistance(dist, sptSet)

			# Put the minimum distance vertex in the
			# shortest path tree
			sptSet[x] = True

			# Update dist value of the adjacent vertices
			# of the picked vertex only if the current
			# distance is greater than new distance and
			# the vertex in not in the shortest path tree
			for y in range(self.V):  
			    # becoz here dist is infinity
			    # if there is edge then the value is more than 0
				if (self.graph[x][y] > 0 and sptSet[y] == False and dist[y] > dist[x] + self.graph[x][y]):
				        
						dist[y] = dist[x] + self.graph[x][y]
						
		self.printSolution(dist)

# Driver program
g = Graph(9)
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 9, 14, 0, 0, 0],
		[0, 0, 0, 9, 0, 10, 0, 0, 0],
		[0, 0, 4, 14, 10, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		];

g.dijkstra(0);

--


---
gfg practice

from collections import defaultdict
class Solution:

    #Function to find the shortest distance of all the vertices
    #from the source vertex S.
    def dijkstra(self, V, adj, S):
        graph = defaultdict(list)
        for i in range(V):
            for nodes in adj[i]:
                graph[i].append((nodes[0],nodes[1]))
            
        distance = [float("inf")] * V
        s = set([S])
        distance[S] = 0
        res = []
        while s:
            curr = s.pop()
            for node, weight in graph[curr]:
                if distance[curr] + weight < distance[node]:
                    distance[node] = distance[curr] + weight
                    s.add(node)
    
        return distance
---
======================================================================================================================================================

-- dijkstra for unweighted graph

-- https://github.com/striver79/StriversGraphSeries/blob/main/shortestPathUndirectedUnweightedGraphCpp
-- https://www.geeksforgeeks.org/shortest-path-unweighted-graph/


--
void BFS(vector<int> adj[], int N, int src):
	int dist[N];
	for(int i = 0;i<N;i++) dist[i] = INT_MAX; 
	queue<int>  q;
	
	dist[src] = 0;
	q.push(src); 

	while q:
		int node = q.pop(0)
		for node in adj[q]:
		    if(dist[node] + 1 < dist[it])
		        dist[it]=dist[node]+1
		        q.append(it)
	return dist 

--


=====================================================================================================================================================

-- bellmon ford

-- https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
-- https://www.youtube.com/watch?v=-dlGfzdfHvM&list=PLNxqWc8Uj2LTb6VYJG3Kebwift2oaBFvE&index=14
-- https://www.youtube.com/watch?v=75yC1vbS8S8&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=28


--
# Python3 program for Bellman-Ford's single source
# shortest path algorithm.

# Class to represent a graph
class Graph:

	def __init__(self, vertices):
		self.V = vertices # No. of vertices
		self.graph = []

	# function to add an edge to graph
	def addEdge(self, u, v, w):
		self.graph.append([u, v, w])
		
	# utility function used to print the solution
	def printArr(self, dist):
		print("Vertex Distance from Source")
		for i in range(self.V):
			print("{0}\t\t{1}".format(i, dist[i]))
	
	# The main function that finds shortest distances from src to
	# all other vertices using Bellman-Ford algorithm. The function
	# also detects negative weight cycle
	def BellmanFord(self, src):

		# Step 1: Initialize distances from src to all other vertices
		# as INFINITE
		dist = [float("Inf")] * self.V
		dist[src] = 0


		# Step 2: Relax all edges |V| - 1 times. A simple shortest
		# path from src to any other vertex can have at-most |V| - 1
		# edges
		for _ in range(self.V - 1):
			# Update dist value and parent index of the adjacent vertices of
			# the picked vertex. Consider only those vertices which are still in
			# queue
			for u, v, w in self.graph:
				if dist[u] != float("Inf") and dist[u] + w < dist[v]:
						dist[v] = dist[u] + w

		# Step 3: check for negative-weight cycles. The above step
		# guarantees shortest distances if graph doesn't contain
		# negative weight cycle. If we get a shorter path, then there
		# is a cycle.

		for u, v, w in self.graph:
			if dist[u] != float("Inf") and dist[u] + w < dist[v]:
					print("Graph contains negative weight cycle")
						return
						
		# print all distance
		self.printArr(dist)

g = Graph(5)
g.addEdge(0, 1, -1)
g.addEdge(0, 2, 4)
g.addEdge(1, 2, 3)
g.addEdge(1, 3, 2)
g.addEdge(1, 4, 2)
g.addEdge(3, 2, 5)
g.addEdge(3, 1, 1)
g.addEdge(4, 3, -3)

# Print the solution
g.BellmanFord(0)

# Initially, Contributed by Neelam Yadav
# Later On, Edited by Himanshu Garg

--


-- bellmon ford in weighted directed graph (Negative weight cycle)
-- https://practice.geeksforgeeks.org/problems/negative-weight-cycle3504/1
-- https://practice.geeksforgeeks.org/problems/distance-from-the-source-bellman-ford-algorithm/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- ( Refer this )
class Solution:
	def isNegativeWeightCycle(self, n, edges):
        dist = [float("inf")] * (n)
        dist[0] = 0
        

	# edges in form (u, v, w)
        for _ in range(n-1):
            for u, v, w in edges:
                if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
        
        for u, v, w in edges:
            if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                return 1
        return 0
--


-- another Solution

--
#User function Template for python3

class Solution:
    # Function to construct and return cost of MST for a graph
    # represented using adjacency matrix representation
    '''
    V: nodes in graph
    edges: adjacency list for the graph
    S: Source
    '''
    def bellman_ford(self, V, edges, S):
        #code here
        
        #step - 1 -> mark the ditance of souce node as zero
        #step - 2 -> and distance for all the nodes except source as inifinity
        #step - 3 -> run untill (V - 1) times 
        #sstep - 4 -> if d[u] + w < d[v] then d[v] = d[u] + w
    
        
        # according to bellman ford if negative cycle exits then using the relaxing once more will get u the negative cycle
        # for bellman ford works mainly on directed graph if u get undirected graph convert it to directed graph\
        
        d = [int(1e8) for _ in range(V)]
        d[S] = 0
        
        for i in range(V-1):
            for u, v, w in edges:
                if d[u] != int(1e8) and d[u] + w < d[v]:
                    d[v] = d[u] + w
        
        for u, v, w in edges:
            if d[u] != int(1e8) and d[u] + w < d[v]:
                return [-1]
                    
        
        return d
--



======================================================================================================================================================



-- Floyd warshell

-- https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/

--
# Python Program for Floyd Warshall Algorithm

# Number of vertices in the graph
V = 4

# Define infinity as the large
# enough value. This value will be
# used for vertices not connected to each other
INF = 99999

# Solves all pair shortest path
# via Floyd Warshall Algorithm

def floydWarshall(graph):

	""" dist[][] will be the output
	matrix that will finally
		have the shortest distances
		between every pair of vertices """
	""" initializing the solution matrix
	same as input graph matrix
	OR we can say that the initial
	values of shortest distances
	are based on shortest paths considering no
	intermediate vertices """
	
	# no need for below line
	#dist = list(map(lambda i: list(map(lambda j: j, i)), graph))

	""" Add all vertices one by one
	to the set of intermediate
	vertices.
	---> Before start of an iteration,
	we have shortest distances
	between all pairs of vertices
	such that the shortest
	distances consider only the
	vertices in the set
	{0, 1, 2, .. k-1} as intermediate vertices.
	----> After the end of a
	iteration, vertex no. k is
	added to the set of intermediate
	vertices and the
	set becomes {0, 1, 2, .. k}
	"""
	for k in range(V):

		# pick all vertices as source one by one
		for i in range(V):

			# Pick all vertices as destination for the
			# above picked source
			for j in range(V):

				# If vertex k is on the shortest path from
				# i to j, then update the value of dist[i][j]
				dist[i][j] = min(dist[i][j],
								dist[i][k] + dist[k][j]
								)
	printSolution(dist)


# A utility function to print the solution
def printSolution(dist):
	print ("Following matrix shows the shortest distances\
between every pair of vertices")
	for i in range(V):
		for j in range(V):
			if(dist[i][j] == INF):
				print ("%7s" % ("INF"),end=" ")
			else:
				print ("%7d\t" % (dist[i][j]),end=' ')
			if j == V-1:
				print ()


# Driver program to test the above program
# Let us create the following weighted graph
"""
			10
	(0)------->(3)
		|		 /|\
	5 |		 |
		|		 | 1
	\|/		 |
	(1)------->(2)
			3		 """
graph = [[0, 5, INF, 10],
		[INF, 0, 3, INF],
		[INF, INF, 0, 1],
		[INF, INF, INF, 0]
		]
# Print the solution
floydWarshall(graph)
# This code is contributed by Mythri J L

--



==========================  IMPORTANT  ========================================================================================================================

-- Union find

-- https://www.geeksforgeeks.org/union-find/
-- https://practice.geeksforgeeks.org/problems/union-find/1

--
# Python Program for union-find algorithm to detect cycle in a undirected graph
# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both

from collections import defaultdict

#This class represents a undirected graph using adjacency list representation
class Graph:

	def __init__(self,vertices):
		self.V= vertices #No. of vertices
		self.graph = defaultdict(list) # default dictionary to store graph


	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

	# A utility function to find the subset of an element i
	def find_parent(self, parent,i):
		if parent[i] == -1:
			return i
		if parent[i]!= -1:
			return self.find_parent(parent,parent[i])

	# A utility function to do union of two subsets
	def union(self,parent,x,y):
		parent[x] = y



	# The main function to check whether a given graph
	# contains cycle or not
	def isCyclic(self):
		
		# Allocate memory for creating V subsets and
		# Initialize all subsets as single element sets
		parent = [-1]*(self.V)

		# Iterate through all edges of graph, find subset of both
		# vertices of every edge, if both subsets are same, then
		# there is cycle in graph.
		for i in self.graph:
			for j in self.graph[i]:
				x = self.find_parent(parent, i)
				y = self.find_parent(parent, j)
				if x == y:
					return True
				self.union(parent,x,y)


# Create a graph given in the above diagram
g = Graph(3)
g.addEdge(0, 1)
g.addEdge(1, 2)
g.addEdge(2, 0)

if g.isCyclic():
	print ("Graph contains cycle")
else :
	print ("Graph does not contain cycle ")

#This code is contributed by Neelam Yadav

--



====================================================================================================================================================

-- min spanning tree (n-1 edges of minimum spanning tree)

-- (Refer this)   https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ 


--

What is a Minimum Spanning Tree?


The cost of the spanning tree is the sum of the weights of all the edges in the tree.
 There can be many spanning trees. Minimum spanning tree is the spanning tree where the 
cost is minimum among all the spanning trees. There also can be many minimum spanning trees.


--



1). prims
-- https://www.youtube.com/watch?v=xsM8i0jVF1w&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=19
-- https://www.youtube.com/watch?v=HnD676J56ak&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=20
-- https://www.youtube.com/watch?v=oNTsS8lGDHw&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=21
-- https://pythonwife.com/kruskal-and-prims-algorithm-in-python/

-- https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp
-- https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1
-- https://takeuforward.org/data-structure/minimum-spanning-tree-mst-using-prims-algo/
-- https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/discuss/831786/minimum-weight-spanning-tree-prims-algorithm


-- prims algo code


--

#User function Template for python3
from collections import defaultdict
import heapq
class Solution:
    
    #Function to find sum of weights of edges of the Minimum Spanning Tree.
    def spanningTree(self, V, adjlist):
        g = defaultdict(list)
        
        ################################# IMP #########################################3
        
        for i in range(V):
            for j in adjlist[i]:
                g[i].append((j[0], j[1]))
                #g[j[0]].append((i, j[1]))
                
                
        parent = [None] * V
        # or distance array u can use
        key = [float("inf")] * V
        mstSet = [False] * V
        key[0] = 0
        parent[0] = -1
        
        # distance and node ==> distance first
        heap = [[0,0]]
        
        for count in range(V - 1):
            mini = float("inf")
            
            # to find the minimum key
            '''
            for i in range(V):
                if not mstSet[i] and key[i] < mini:
                    mini = key[i]
                    u = i
            '''
                    
            
            # either use heap
            # min ditance will be extracted first
            # store node in u
            u = heapq.heappop(heap)[1]
            mstSet[u] = True
            
            # u has minimum distance node  
            
            for adj in g[u]:
                # adjacent node
                v = adj[0]
                # weight 
                weight = adj[1]
                if not mstSet[v] and weight < key[v]:
                    parent[v] = u
                    key[v] = weight
                    heapq.heappush(heap, [key[v], v])
        return sum(key)

--



2) kruskal
-- https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/



-- kruskals algo with heap

#Krushkal's Algorithm
import heapq
class Solution:
   
   #Function to find sum of weights of edges of the Minimum Spanning Tree.
   def spanningTree(self, V, adj):
       
       #code here
       #Krushkal Algorithm
       p=[0]*V
       rank=[0]*V
       for i in range(V):
           p[i]=i
       def par(node):
           if node==p[node]:
               return node
           p[node]=par(p[node])
           return  p[node]
       def union(u,v):
           a=par(u)
           b=par(v)
           if rank[a]<rank[b]:
               p[a]=b
           elif rank[b]<rank[a]:
               p[b]=a
           else:
               p[b]=a
               rank[b]+=1
       q=[]        
       for u in range(V):
           for v,w in adj[u]:
               q.append([u,v,w])
       q=sorted(q,key=lambda x:x[2])
       cost=0
       for u,v,w in q:
           if par(u) != par(v):
               cost+=w
               union(u,v)
       return cost

--





-- Kruskals algo
# Python program for Kruskal's algorithm to find
# Minimum Spanning Tree of a given connected,
# undirected and weighted graph

from collections import defaultdict

# Class to represent a graph


class Graph:

	def __init__(self, vertices):
		self.V = vertices # No. of vertices
		self.graph = [] # default dictionary
		# to store graph

	# function to add an edge to graph
	def addEdge(self, u, v, w):
		self.graph.append([u, v, w])

	# A utility function to find set of an element i
	# (uses path compression technique)
	def find(self, parent, i):
		if parent[i] == i:
			return i
		return self.find(parent, parent[i])

	# A function that does union of two sets of x and y
	# (uses union by rank)
	def union(self, parent, rank, x, y):
		xroot = self.find(parent, x)
		yroot = self.find(parent, y)

		# Attach smaller rank tree under root of
		# high rank tree (Union by Rank)
		if rank[xroot] < rank[yroot]:
			parent[xroot] = yroot
		elif rank[xroot] > rank[yroot]:
			parent[yroot] = xroot

		# If ranks are same, then make one as root
		# and increment its rank by one
		else:
			parent[yroot] = xroot
			rank[xroot] += 1

	# The main function to construct MST using Kruskal's
		# algorithm
	def KruskalMST(self):

		result = [] # This will store the resultant MST
		
		# An index variable, used for sorted edges
		i = 0
		
		# An index variable, used for result[]
		e = 0

		# Step 1: Sort all the edges in
		# non-decreasing order of their
		# weight. If we are not allowed to change the
		# given graph, we can create a copy of graph

		self.graph = sorted(self.graph,key=lambda item: item[2])

		parent = []
		rank = []

		# Create V subsets with single elements
		for node in range(self.V):
			parent.append(node)
			rank.append(0)

		# Number of edges to be taken is equal to V-1
		while e < self.V - 1:

			# Step 2: Pick the smallest edge and increment
			# the index for next iteration

			u, v, w = self.graph[i]
			i = i + 1
			x = self.find(parent, u)
			y = self.find(parent, v)

			# If including this edge doesn't
			# cause cycle, include it in result
			# and increment the indexof result
			# for next edge

			if x != y:
				e = e + 1
				result.append([u, v, w])
				self.union(parent, rank, x, y)

			# Else discard the edge

		minimumCost = 0
		print ("Edges in the constructed MST")
		for u, v, weight in result:
			minimumCost += weight
			print("%d -- %d == %d" % (u, v, weight))
		print("Minimum Spanning Tree" , minimumCost)

# Driver code
g = Graph(4)
g.addEdge(0, 1, 10)
g.addEdge(0, 2, 6)
g.addEdge(0, 3, 5)
g.addEdge(1, 3, 15)
g.addEdge(2, 3, 4)

# Function call
g.KruskalMST()

# This code is contributed by Neelam Yadav

--




========================================================================================================================================================


-- Connected Componets (also refer the code for ==> number of provences)   =>  O(V+E)

-- Given an undirected graph, print all connected components line by line.
 For example consider the following graph.


--
# Python program to print connected
# components in an undirected graph


class Graph:

	# init function to declare class variables
	def __init__(self, V):
		self.V = V
		self.adj = [[] for i in range(V)]

	def DFSUtil(self, temp, v, visited):

		# Mark the current vertex as visited
		visited[v] = True

		# Store the vertex to list
		temp.append(v)

		# Repeat for all vertices adjacent
		# to this vertex v
		for i in self.adj[v]:
			if visited[i] == False:

				# Update the list
				temp = self.DFSUtil(temp, i, visited)
		return temp

	# method to add an undirected edge
	def addEdge(self, v, w):
		self.adj[v].append(w)
		self.adj[w].append(v)

	# Method to retrieve connected components
	# in an undirected graph
	def connectedComponents(self):
		visited = []
		cc = []
		for i in range(self.V):
			visited.append(False)
		for v in range(self.V):
			if visited[v] == False:
				temp = []
				cc.append(self.DFSUtil(temp, v, visited))
		return cc


# Driver Code
if __name__ == "__main__":

	# Create a graph given in the above diagram
	# 5 vertices numbered from 0 to 4
	g = Graph(5)
	g.addEdge(1, 0)
	g.addEdge(2, 3)
	g.addEdge(3, 4)
	cc = g.connectedComponents()
	print("Following are connected components")
	print(cc)

# This code is contributed by Abhishek Valsan

--


-- Two types of algo to find and print SCC
 
1 ==> Kosaraju’s algorithm for strongly connected components. 
2 ==> Tarjan’s Algorithm to find Strongly Connected Components






-- Kosarajus Algo for strongly connected components O(V+E)

-- A directed graph is strongly connected if there is a path between all pairs of vertices. 
A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.
 For example, there arel 3 SCCs in the following graph.

==
-- https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1
-- https://www.geeksforgeeks.org/strongly-connected-components/
==

--

from collections import defaultdict
class Solution:
    # components
    res = []
    #Function to find number of strongly connected components in the graph.
    def kosaraju(self, V, adjacency):
        # dfs and stack for the first time
        vis = [False] * V
        stack = []
        adj = defaultdict(list)
        for i in range(V):
            for nodes in adjacency[i]:
                adj[i].append(nodes)
                
        def dfs(node, vis, adjc, stack, sec):
            if sec:
                self.res.append(node)
            vis[node] = True
            
            for i in adjc[node]:
                if not vis[i]:
                    dfs(i, vis, adjc, stack, sec)
            if not sec:      
                stack.append(node)
                
        # reverse the edges
        def getTranspose(adjc):
            g = defaultdict(list)
            for i in adjc:
			    for j in adjc[i]:
			        
			        g[j].append(i)
            return g
            
            
            
        # first loop
        for i in range(V):
            if not vis[i]:
                dfs(i, vis, adj, stack, False)
                
    
        # reverse the edges ==> get the tranpose
        g = getTranspose(adj)
        vis = [False] * V
        count = 0
        while stack:
            temp = stack.pop()
            if vis[temp] == False:
                dfs(temp, vis, g, stack, True)
                count += 1
                
        
        return count   
--



=====================================================================================================================================================


-- DFS

-- Min time to collect all apples

-- https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/



--
class Solution(object):
    def minTime(self, n, edges, hasApple):
        if len(edges) == 0 or n <= 0: return 0
        all_has_apple = False
        status = [-1] * len(hasApple)
        for i in range(len(hasApple)):
            status[i] = 1 if hasApple[i] else 0
            all_has_apple = all_has_apple and hasApple[i]
        graph = {}
        for f, t in edges:
            if f not in graph: graph[f] = []
            if t not in graph: graph[t] = []
            graph[f].append(t)
            graph[t].append(f)
        has, time = self.dfs(graph, 0, status)
        return time

    def dfs(self, graph, start, status):
        if status[start] == 1: has, time = True, 0
        else: has, time = False, 0
        if start not in graph:
            return has, time
        status[start] = -1
        for node in graph[start]:
            if status[node] >= 0:
                cur_has, cur_time = self.dfs(graph, node, status)
                if cur_has:
                    time += cur_time + 2
                has = has or cur_has
        return has, time
        
--

========================================================================================================================================================================================

-- Convert adjacency list to matrix


-- https://www.geeksforgeeks.org/convert-adjacency-list-to-adjacency-matrix-representation-of-a-graph/


--
# Python3 program to implement
# the above approach

# Function to insert vertices
# to adjacency list
def insert(adj, u, v):

	# Insert a vertex v to vertex u
	adj[u].append(v)
	return

# Function to display adjacency list
def printList(adj, V):
	
	for i in range(V):
		print(i, end = '')
		
		for j in adj[i]:
			print(' --> ' + str(j), end = '')
			
		print()
		
	print()
		
# Function to convert adjacency
# list to adjacency matrix
def convert(adj, V):

	# Initialize a matrix
	matrix = [[0 for j in range(V)]
				for i in range(V)]
	
	for i in range(V):
		for j in adj[i]:
			matrix[i][j] = 1
	
	return matrix

# Function to display adjacency matrix
def printMatrix(adj, V):
	
	for i in range(V):
		for j in range(V):
			print(adj[i][j], end = ' ')
			
		print()
		
	print()
		
# Driver code
if __name__=='__main__':

	V = 5

	adjList = [[] for i in range(V)]

	# Inserting edges
	insert(adjList, 0, 1)
	insert(adjList, 0, 4)
	insert(adjList, 1, 0)
	insert(adjList, 1, 2)
	insert(adjList, 1, 3)
	insert(adjList, 1, 4)
	insert(adjList, 2, 1)
	insert(adjList, 2, 3)
	insert(adjList, 3, 1)
	insert(adjList, 3, 2)
	insert(adjList, 3, 4)
	insert(adjList, 4, 0)
	insert(adjList, 4, 1)
	insert(adjList, 4, 3)

	# Display adjacency list
	print("Adjacency List: ")
	printList(adjList, V)

	# Function call which returns
	# adjacency matrix after conversion
	adjMatrix = convert(adjList, V)

	# Display adjacency matrix
	print("Adjacency Matrix: ")
	printMatrix(adjMatrix, V)

# This code is contributed by rutvik_56

--

============================================================================================================================================

-- Convert Matrix to Adjacency list


-- https://www.geeksforgeeks.org/convert-adjacency-matrix-to-adjacency-list-representation-of-graph/


--
# Python 3 program to convert Adjacency matrix
# representation to Adjacency List

from collections import defaultdict
# converts from adjacency matrix to adjacency list
def convert(a):
	adjList = defaultdict(list)
	for i in range(len(a)):
		for j in range(len(a[i])):
			if a[i][j]== 1:
				adjList[i].append(j)
	return adjList

# driver code
a =[[0, 0, 1], [0, 0, 1], [1, 1, 0]] # adjacency matrix
AdjList = convert(a)
print("Adjacency List:")
# print the adjacency list
for i in AdjList:
	print(i, end ="")
	for j in AdjList[i]:
		print(" -> {}".format(j), end ="")
	print()

# This code is contributed by Muskan Kalra.

--


==========================================================================================================================================================

-- Number of provices (Connected components) ==> O(V**2)


-- https://github.com/Prince-1501/Hello_world-Competiitve-Programming/blob/master/Leetcode/Graph/Number%20of%20Provinces.cpp
-- https://www.youtube.com/watch?v=W3YyfjxKcA0
-- https://practice.geeksforgeeks.org/problems/number-of-provinces/1
-- https://www.geeksforgeeks.org/connected-components-in-an-undirected-graph/
-- https://www.geeksforgeeks.org/convert-adjacency-list-to-adjacency-matrix-representation-of-a-graph/



--
class Solution:
    globalset = []
    def numProvinces(self, adj, V):
        def dfs(s, n, isConnected, visited):
            visited[s] = True;
            #s = 1
            
            # 0 1 2 3 4  -- index
            # 1 2 3 4 5  -- city name
            # 1 1 0 1 0  -- connection
            
            '''
            # for the adjacent nodes
            adj = []
            for i in range(n):
                x =  isConnected[s][i]  # x = connection
                if(x == 1):
                    adj.append(i)
            '''
            
            # run dfs only for the ones that has edges
            for i in range(n):
                if not visited[i] and isConnected[s][i] == 1:
                    dfs(i, n, isConnected, visited)
        
        n = len(adj)
        visited = [False] * V
        count = 0
        
        for i in range(n):
            if not visited[i]:
                count += 1
                dfs(i, len(adj), adj, visited)
        
        return count
--

===================================================================================================================================================
-- transpose a graph


-- https://www.geeksforgeeks.org/transpose-graph/#:~:text=We%20traverse%20the%20adjacency%20list,v%20of%20the%20new%20graph.


--
# Python3 program to find transpose of a graph.

# function to add an edge from vertex
# source to vertex dest
def addEdge(adj, src, dest):
	adj[src].append(dest)

# function to print adjacency list
# of a graph
def displayGraph(adj, v):
	for i in range(v):
		print(i, "--> ", end = "")
		for j in range(len(adj[i])):
			print(adj[i][j], end = " ")
		print()

# function to get Transpose of a graph
# taking adjacency list of given graph
# and that of Transpose graph
def transposeGraph(adj, transpose, v):
	
	# traverse the adjacency list of given
	# graph and for each edge (u, v) add
	# an edge (v, u) in the transpose graph's
	# adjacency list
	for i in range(v):
		for j in range(len(adj[i])):
			addEdge(transpose, adj[i][j], i)

# Driver Code
if __name__ == '__main__':

	v = 5
	adj = [[] for i in range(v)]
	addEdge(adj, 0, 1)
	addEdge(adj, 0, 4)
	addEdge(adj, 0, 3)
	addEdge(adj, 2, 0)
	addEdge(adj, 3, 2)
	addEdge(adj, 4, 1)
	addEdge(adj, 4, 3)

	# Finding transpose of graph represented
	# by adjacency list adj[]
	transpose = [[]for i in range(v)]
	transposeGraph(adj, transpose, v)

	# displaying adjacency list of
	# transpose graph i.e. b
	displayGraph(transpose, v)

# This code is contributed by PranchalK

--


============================================================================================================================================================================

-- Number of operations to make network connected

-- https://leetcode.com/problems/number-of-operations-to-make-network-connected/submissions/
-- https://leetcode.com/problems/number-of-operations-to-make-network-connected/discuss/477806/Python-Union-Find


--
from collections import defaultdict
class Solution(object):
    def makeConnected(self, n, connections):
        # important edges cases
        if len(connections) < n-1: # this is a edge condi. to connect n components we need min n-1 cables. 
            return -1
        g = defaultdict(list)
        for i in connections:
            g[i[0]].append(i[1])
            g[i[1]].append(i[0])
        
        def dfs(node, vis, g):
            vis[node] = True
            for i in g[node]:
                if not vis[i]:
                    dfs(i, vis, g)

        vis = [False] * n
        count = 0
        for node in range(n):
            if not vis[node]:
                count += 1 
                dfs(node, vis, g)
                
        return count - 1
--

============================================================================================================================================================

-- Bridges in graph ( when removed edge, the graph is broken into two or more components)

-- An edge in an undirected connected graph is a bridge if removing it disconnects 
the graph. For a disconnected undirected graph, definition is similar, a bridge 
is an edge removing which increases number of disconnected components. 


-- https://www.geeksforgeeks.org/bridge-in-a-graph/
-- https://leetcode.com/problems/critical-connections-in-a-network/submissions/

-- two arrays used 

=> time array
=> lowest time array


--
from collections import defaultdict
class Solution(object):
    res = []
    def criticalConnections(self, n, connections):
        g = defaultdict(list)
        for i in connections:
            g[i[0]].append(i[1])
            g[i[1]].append(i[0])
        print(g)
        vis = [False] * n
        low = [float("inf")] * n
        time = 0
        tin = [float("inf")] * n
            
        def dfs(parent, node, low, tin, vis, g, time):
            vis[node] = True
            time = time + 1
            low[node] = time
            tin[node] = time
            
            for i in g[node]:  
                if i == parent: continue
                if not vis[i]:
                    # apply dfs for adjacents
                    dfs(node, i, low, tin, vis, g, time)
                    
                    # after returning to the node
                    # minimum between himself and the adjacent
                    
                    low[node] = min(low[node], low[i])
                    
                    # formulae for the bridge
                    # if low[adj] > time insertion of himself then its a bridge
                    if (low[i] > tin[node]):
                        print([i, node])
                        self.res.append([i,node])
                
                
                # if visited then min of himself and adjacent of time of insertion
                else:
                    low[node] = min(low[node], tin[i])
                     
        for i in range(n):
            if not vis[i]:
                dfs(-1, i, low, tin, vis, g, time)
        print(self.res)
        return self.res
            
--


======================================================================================================================================================================

-- Longest cycle in a graph

-- https://www.youtube.com/watch?v=vc_kz2M-jw4
-- https://leetcode.com/problems/longest-cycle-in-a-graph/submissions/


--

class Solution(object):
    ans = -1    
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        vis = [False] * n
        dis = [0] * n 
        extra = [False] * n # extra array for directed graph
        def dfs(node, dis, vis, edges, distance, extra):
            if node != -1:
                if not vis[node]: 
                    vis[node] = True
                    extra[node] = True
                    dis[node] = distance
                    dfs(edges[node], dis, vis, edges, distance + 1, extra)
                
                # already visited then
                elif extra[node]:
                    self.ans = max(self.ans, distance - dis[node])
                extra[node] = False
                          
        # run dfs for the entire edge list
        for i in range(n):
            if not vis[i]:
                dfs(i, dis, vis, edges, 0, extra)
        
        return self.ans
       
--


============================================================================================================================================================================================

-- Find the coleset node to given two nodes

-- https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/
-- https://www.youtube.com/watch?v=S0jZu7H7nQ0


---
class Solution:
    def dfs(self, node, dis, vis, distance, edges):
        if node != -1 and not vis[node]:
            vis[node] = True
            dis[node] = distance
            self.dfs(edges[node], dis, vis, distance + 1, edges)
            
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        dist_node2 = [-1] * len(edges)  # distance array for node1
        dist_node1 = [-1] * len(edges)  # distance array for node2
        vis = [False] * len(edges)
        
        # dfs for only two nodes
        self.dfs(node1, dist_node1, vis, 0, edges)
        
        # initialize visited array again
        vis = [False] * len(edges)
        self.dfs(node2, dist_node2, vis, 0, edges)
        
        print(dist_node1, dist_node2)
        # we have two distance arrays
        # extract the max of two arrays in that answer is min value
        
        ans = len(edges)
        res = -1
        for i in range(len(edges)):
            # only perform the action if the nodes can be visited by the nodes by -1 then dont perform operation
            if dist_node1[i] != -1 and dist_node2[i] != -1:
                if max(dist_node1[i], dist_node2[i]) < ans:
                    ans = max(dist_node1[i], dist_node2[i])
                    res = i
        return res
       

--
================================================================================================================================================================================
-- Disjoint set (Union find)

-- https://www.geeksforgeeks.org/union-find/
-- https://practice.geeksforgeeks.org/problems/union-find/1
-- https://www.youtube.com/watch?v=3gbO7FDYNFQ&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=22

--
class Solution:
    
    def findPar(self, par, node):
        # if node equal to himself
        
        # eg 7 => 6 => 5 => 3 and goes back
        if node == par[node]:
            return node
        par[node] = self.findPar(par, par[node]) # this is path compression
        return  par[node] 
        
    
    #Function to merge two nodes a and b.
    
    # Both functions has parent array and rank array 
    # initially parent array is ==> [0, 1, 2, ...n] parent of nodes at first has the same nodes
    
    # initially ranks of nodes are 1 or 0 either one [1, 1, 1, .... till n]
    def union_(self,a,b,par,rank):
        a = self.findPar(par, a)
        b = self.findPar(par, b)
        
        if rank[a] > rank[b]:
            par[b] = a
        elif rank[b] > rank[a]:
            par[a] = b
        else:
            par[a] = b
            rank[b] += 1
        
        
        
    #Function to check whether 2 nodes are connected or not.
    def isConnected(self,x,y,par,rank):
        if self.findPar(par, x) == self.findPar(par, y):
            return 1
        return 0

--


=========================================================================================================================================================================================

-- Cheapest flights with within k stops

-- https://leetcode.com/problems/cheapest-flights-within-k-stops/
-- https://github.com/neetcode-gh/leetcode/blob/main/python/787-Cheapest-Flights-within-K-stops.py
-- https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/436785/Python-solution-or-Dijkstra's-explained

--

def findCheapestPrice(self, n, flights, src, dst,k):
        import heapq
        from collections import defaultdict

        #Make graph
        adj_list = defaultdict(list)
        for u, v, w in flights:
            adj_list[u].append((v,w))

        prior_queue = [ (0, -1, src) ] #weight, steps, node

        while prior_queue:
            cost, steps, node = heapq.heappop(prior_queue)
            
            if steps > k:
                continue

            if node == dst:
                return cost

            for neighb, weight in adj_list[node]:
                heapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))

        return -1

-- 

class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, k):
        prices = [float("inf")] * n
        prices[src] = 0
        for i in range(k + 1):
            tmpPrices = prices[:]

            for s, d, p in flights:  # s=source, d=dest, p=price
                if prices[s] == float("inf"):
                    continue
                if prices[s] + p < tmpPrices[d]:
                    tmpPrices[d] = prices[s] + p
            prices = tmpPrices
        return -1 if prices[dst] == float("inf") else prices[dst]
--

==========================================================================================================================================================================================


-- Print the path of shortest Path using Dijkstra Algo


-- copy paste the whole code in programiz
-- https://www.geeksforgeeks.org/printing-paths-dijkstras-shortest-path-algorithm/
-- https://practice.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1


--
# Python program for Dijkstra's
# single source shortest
# path algorithm. The program
# is for adjacency matrix
# representation of the graph

from collections import defaultdict

#Class to represent a graph
class Graph:

	# A utility function to find the
	# vertex with minimum dist value, from
	# the set of vertices still in queue
	def minDistance(self,dist,queue):
		# Initialize min value and min_index as -1
		minimum = float("Inf")
		min_index = -1
		
		# from the dist array,pick one which
		# has min value and is till in queue
		for i in range(len(dist)):
			if dist[i] < minimum and i in queue:
				minimum = dist[i]
				min_index = i
		return min_index


	# Function to print shortest path
	# from source to j
	# using parent array
	def printPath(self, parent, j):
		
		#Base Case : If j is source
		if parent[j] == -1 :
			print(j,end=" ")
			return
		self.printPath(parent , parent[j])
		print (j,end=" ")
		

	# A utility function to print
	# the constructed distance
	# array
	def printSolution(self, dist, parent):
		src = 0
		print("Vertex \t\tDistance from Source\tPath")
		for i in range(0, len(dist)):
			print("\n%d --> %d \t\t%d \t\t\t\t\t" % (src, i, dist[i]),end=" ")
			self.printPath(parent,i)


	'''Function that implements Dijkstra's single source shortest path
	algorithm for a graph represented using adjacency matrix
	representation'''
	def dijkstra(self, graph, src):

		row = len(graph)
		col = len(graph[0])

		# The output array. dist[i] will hold
		# the shortest distance from src to i
		# Initialize all distances as INFINITE
		dist = [float("Inf")] * row

		#Parent array to store
		# shortest path tree
		parent = [-1] * row

		# Distance of source vertex
		# from itself is always 0
		dist[src] = 0
	
		# Add all vertices in queue
		queue = []
		for i in range(row):
			queue.append(i)
			
		#Find shortest path for all vertices
		while queue:

			# Pick the minimum dist vertex
			# from the set of vertices
			# still in queue
			u = self.minDistance(dist,queue)

			# remove min element	
			queue.remove(u)

			# Update dist value and parent
			# index of the adjacent vertices of
			# the picked vertex. Consider only
			# those vertices which are still in
			# queue
			for i in range(col):
				'''Update dist[i] only if it is in queue, there is
				an edge from u to i, and total weight of path from
				src to i through u is smaller than current value of
				dist[i]'''
				if graph[u][i] and i in queue:
					if dist[u] + graph[u][i] < dist[i]:
						dist[i] = dist[u] + graph[u][i]
						parent[i] = u


		# print the constructed distance array
		self.printSolution(dist,parent)

g= Graph()
graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 9, 14, 0, 0, 0],
		[0, 0, 0, 9, 0, 10, 0, 0, 0],
		[0, 0, 4, 14, 10, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		]

# Print the solution
g.dijkstra(graph,7)

import heapq
class Solution:
    def dijkstra1(self, V, adj, S):
        graph = defaultdict(list)
        for i in range(V):
            for nodes in adj[i]:
                graph[i].append((nodes[0],nodes[1]))
            
        distance = [float("inf")] * V
        print(graph)
        s = set([S])
        parent = [-1] * V
        distance[S] = 0
        while s:
            curr = s.pop()
            for node, weight in graph[curr]:
                if distance[curr] + weight < distance[node]:
                    distance[node] = distance[curr] + weight
                    parent[node] = curr
                    s.add(node)
                    
        # to print paths
        def printPath(parent, j):
            if parent[j] == -1:
                print(j," \n")
                return
            print (j,end=" ")
            printPath(parent , parent[j])
            
    		
		
        for i in range(0, V):
            printPath(parent , i)
        return distance
        
arr = [[[1,4],[7,8]],
[[0,4],[2,8],[7,11]],
[[1,8],[3,7],[5,4],[8,2]],
[[2,7], [4,9] , [5,14]],
[[3,9],[5,10]] ,
[[2,4], [3,14], [4,10],[6,2]], 
[[5,2], [7,1], [8,6]], 
[[0,8], [1,11], [6, 1], [8, 7]],
[[2,2],[6,6],[7,7]]]

arr2 = [[[1, 9], [2, 1], [3, 1]], [[0, 9], [3, 3]], [[0, 1], [3, 2]], [[0, 1], [1, 3], [2, 2]]]
test = Solution()
print(test.dijkstra1(9,arr,7))
        
        
# This code is contributed by Neelam Yadav
--

===============================================================================================================================================

-- Swim in rising water


-- https://leetcode.com/problems/swim-in-rising-water/submissions/
-- https://neetcode.io/


--
import heapq
class Solution(object):
    def swimInWater(self, grid):
        n = len(grid)
        visit = set()
        minH = [[grid[0][0], 0, 0]]
        # in four directions
        directions = [[0,1],[1,0],[0,-1],[-1,0]]
        visit.add((0,0))
        while minH:
            t, r, c = heapq.heappop(minH)
            if r == n - 1 and c == n - 1:
                return t
            for dr, dc in directions:
                newR = r + dr
                newC = c + dc
                
                if (newR < 0 or newC < 0 or newR == n or newC == n or (newR, newC) in visit): continue
                heapq.heappush(minH, [max(t, grid[newR][newC]), newR, newC])
                visit.add((newR, newC))
--


=====================================================================================================================================================================

-- Shortest path from 1 to n

-- https://practice.geeksforgeeks.org/problems/shortest-path-from-1-to-n0156/1

--
class Solution:
    def minStep (self, n):
        ans = 0
        while(n > 1):
            if(n%3 == 0):
                ans = ans + 1
                n = n//3
            else:
                ans = ans + 1
                n = n - 1
        return ans
--


===========================================================================================================================================================================

-- shortest path in Directed acyclic graph


-- https://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/
-- https://www.youtube.com/watch?v=CrxG4WJotgg&list=PLenDHP08C275jqDbvspC-govc6GAk1Oz_&index=16


-- Topological sort and store it in stack
-- and run dijkstra algoon stack

--
# Python program to find single source shortest paths
# for Directed Acyclic Graphs Complexity :O(V+E)
from collections import defaultdict

# Graph is represented using adjacency list. Every
# node of adjacency list contains vertex number of
# the vertex to which edge connects. It also contains
# weight of the edge
class Graph:
	def __init__(self,vertices):

		self.V = vertices # No. of vertices

		# dictionary containing adjacency List
		self.graph = defaultdict(list)

	# function to add an edge to graph
	def addEdge(self,u,v,w):
		self.graph[u].append((v,w))


	# A recursive function used by shortestPath
	def topologicalSortUtil(self,v,visited,stack):

		# Mark the current node as visited.
		visited[v] = True

		# Recur for all the vertices adjacent to this vertex
		if v in self.graph.keys():
			for node,weight in self.graph[v]:
				if visited[node] == False:
					self.topologicalSortUtil(node,visited,stack)

		# Push current vertex to stack which stores topological sort
		stack.append(v)


	''' The function to find shortest paths from given vertex.
		It uses recursive topologicalSortUtil() to get topological
		sorting of given graph.'''
	def shortestPath(self, s):

		# Mark all the vertices as not visited
		visited = [False]*self.V
		stack =[]

		# Call the recursive helper function to store Topological
		# Sort starting from source vertices
		for i in range(self.V):
			if visited[i] == False:
				self.topologicalSortUtil(s,visited,stack)

		# Initialize distances to all vertices as infinite and
		# distance to source as 0
		dist = [float("Inf")] * (self.V)
		dist[s] = 0

		# Process vertices in topological order
		while stack:

			# Get the next vertex from topological order
			i = stack.pop()

			# Update distances of all adjacent vertices
			for node,weight in self.graph[i]:
				if dist[node] > dist[i] + weight:
					dist[node] = dist[i] + weight

		# Print the calculated shortest distances
		for i in range(self.V):
			print (("%d" %dist[i]) if dist[i] != float("Inf") else "Inf" ,end=" ")


g = Graph(6)
g.addEdge(0, 1, 5)
g.addEdge(0, 2, 3)
g.addEdge(1, 3, 6)
g.addEdge(1, 2, 2)
g.addEdge(2, 4, 4)
g.addEdge(2, 5, 2)
g.addEdge(2, 3, 7)
g.addEdge(3, 4, -1)
g.addEdge(4, 5, -2)

# source = 1
s = 1

print ("Following are shortest distances from source %d " % s)
g.shortestPath(s)

# This code is contributed by Neelam Yadav

--

==================================================================================================================================

-- Courses Schedule - II

-- https://leetcode.com/problems/course-schedule-ii/submissions/
-- https://www.youtube.com/watch?v=Akt3glAwyfY

--
# https://www.youtube.com/watch?v=Akt3glAwyfY
class Solution(object):
    def findOrder(self, numCourses, prerequisites):
    # topological sort
    # eg for the edge [1,0] complete 0 first to complete 1
    # if there is cycle then return empty array
    # tc => O(V+E) 
    
    # steps =>
    # build adjacency list
    # run dfs on graph
    # topological sort method
    # also check for cycle by hashset
        pre = { c: [] for c in range(numCourses)}
        for crs, nes in prerequisites:
            pre[crs].append(nes)
            
        vis = set()
        cycle = set()
        res = []
        
        def dfs(node):
            if node in cycle:
                return False
            if node in vis:
                return True
            
            cycle.add(node)
            for i in pre[node]:
                # if cycle return False
                if dfs(i) == False:
                    return False
            cycle.remove(node)
            vis.add(node)
            # comming back append in res
            res.append(node)
            return True
        
        for i in range(numCourses):
            if dfs(i) == False:
                return []
        return res
--


=======================================================================================================================================


-- Course Schedule - I (Same code as Couses scedule II)

-- https://leetcode.com/problems/course-schedule/submissions/
-- https://neetcode.io/

--
class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        pre = { c: [] for c in range(numCourses)}
        for crs, nes in prerequisites:
            pre[crs].append(nes)
            
        vis = set()
        cycle = set()
        res = []
        
        def dfs(node):
		# check for cycle
            if node in cycle:
                return False
            if node in vis:
                return True

            cycle.add(node)
            for i in pre[node]:
                # if cycle return False
                if dfs(i) == False:
                    return False
            cycle.remove(node)
            vis.add(node)
            # comming back append in res
            res.append(node)
            return True
        
        for i in range(numCourses):
            if dfs(i) == False:
                return []
        return True
--

===========================================================================================================================================================

-- Min Cost to connect all paths

-- https://leetcode.com/problems/network-delay-time/discuss/187713/Python-concise-queue-and-heap-solutions
-- https://leetcode.com/problems/network-delay-time/discuss/471164/Python-DFS-BFS-Dijkstra-Bellman-Ford-SPFA-Floyd-Warshall
-- https://leetcode.com/problems/network-delay-time/submissions/
-- https://neetcode.io/

--
from collections import defaultdict
class Solution(object):
    def networkDelayTime(self, times, n, src):
        g = defaultdict(list)
        for u, v, w in times:
            g[u].append((v, w))
            #g[v].append((u, w))
        dist = [float("inf")] * (n + 1)
        q = [src]
        dist[src] = 0
        maximum = dist[src]
        while q:
            curr = q.pop(0)
            for node, weight in g[curr]:
                if dist[curr] + weight < dist[node]:
                    dist[node] = dist[curr] + weight
                    
                    q.append(node)
        for i in range(1, n+1):
            if dist[i] == float("inf"):
                return -1
            else:
                maximum = max(maximum, dist[i])
        return maximum
    
    
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        edges = collections.defaultdict(list)
        for u, v, w in times:
            edges[u].append((v, w))

        minHeap = [(0, k)]
        visit = set()
        t = 0
        while minHeap:
            w1, n1 = heapq.heappop(minHeap)
            if n1 in visit:
                continue
            visit.add(n1)
            t = max(t, w1)

            for n2, w2 in edges[n1]:
                if n2 not in visit:
                    heapq.heappush(minHeap, (w1 + w2, n2))
        return t if len(visit) == n else -1

        # O(E * logV)
        
        
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:        
        adj_list = defaultdict(list)
        
        for x,y,w in times:
            adj_list[x].append((w, y))
        
        visited=set()
        heap = [(0, k)]
        while heap:
            travel_time, node = heapq.heappop(heap)
            visited.add(node)
            
            if len(visited)==n:
                return travel_time
            
            for time, adjacent_node in adj_list[node]:
                if adjacent_node not in visited:
                    heapq.heappush(heap, (travel_time+time, adjacent_node))
                
        return -1
--

===================================================================================================================================================================

-- Min cost to connect all paths

-- 




===============================================================================================================================================================================

-- Max Area of island


-- https://leetcode.com/problems/max-area-of-island/submissions/

--

class Solution:
    def maxAreaOfIsland(self, grid):
        ROWS, COLS = len(grid), len(grid[0])
        visit = set()
        def dfs(r, c):
            if (
                r < 0
                or r == ROWS
                or c < 0
                or c == COLS
                or grid[r][c] == 0
                or (r, c) in visit
            ):
                return 0
            visit.add((r, c))
            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)

        area = 0
        for r in range(ROWS):
            for c in range(COLS):
                area = max(area, dfs(r, c))
        return area
--

===============================================================================================================================================================================

-- Number of islands

-- https://leetcode.com/problems/number-of-islands/submissions/

--
class Solution:
    def numIslands(self,grid):
        row = len(grid)
        col = len(grid[0])
        count = 0
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    self.dFS(i,j,row,col,grid)
                    count+=1
        return count
                
    def dFS(self,i,j,row,col,grid):
        if i < 0 or j < 0 or i >= row or j>= col or grid[i][j] != "1":
            return
        grid[i][j] = -1
        self.dFS(i - 1, j, row, col, grid)
        self.dFS(i, j - 1, row, col, grid)
        self.dFS(i, j + 1, row, col, grid)
        self.dFS(i + 1, j, row, col, grid)
--

===========================================================================================================================================================================

-- Longest Increasing Path in Matrix


-- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/submissions/
-- https://www.youtube.com/watch?v=wCc_nd-GiEc&t=966s

--
class Solution(object):
    def longestIncreasingPath(self, g):
        row = len(g)
        col = len(g[0])
        dp = {} # (r, w)
        
        # prevVal - previous value
        def dfs(r, c, prevVal):
            if (r < 0 or c == col or c < 0 or
            r == row or g[r][c] <= prevVal):
                return 0
            
            if (r,c) in dp:
                return dp[(r,c)]
            
            res = 1
            res = max(res, 1 + dfs(r+1, c, g[r][c]))
            res = max(res, 1 + dfs(r-1, c, g[r][c]))
            res = max(res, 1 + dfs(r, c-1, g[r][c]))
            res = max(res, 1 + dfs(r, c+1, g[r][c]))
            
            dp[(r,c)] = res
            return res
                
        
        
        for i in range(row):
            for j in range(col):
                dfs(i, j, -1)
        return max(dp.values())
        
--

==============================================================================================================================================================================

-- (Floyd warshell) Find city with smallest number of neighbours at threshold distance 


-- https://www.youtube.com/watch?v=s33lKd8ZOkI&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=40
-- https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/submissions/


--
class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):
        dist = [[float("inf") for _ in range(n)] for _ in range(n)]
        
        # make the diagonal distance as 0
        for i in range(n):
            dist[i][i] = 0
        
        for v in edges:
            dist[v[0]][v[1]] = v[2]
            dist[v[1]][v[0]] = v[2]
            
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][k] != float("inf") and dist[k][j] != float("inf") and (dist[i][k] + dist[k][j] < dist[i][j]):
                        dist[i][j] = dist[i][k] + dist[k][j]
        
        citycount = float("inf")
        ans = 0
        for i in range(n):
            count =0
            for j in range(n):
                if i!=j and dist[i][j] <= distanceThreshold:
                    count += 1
        
            if count <= citycount:
                ans = i
                citycount = count
        return ans
            
--

====================================================================================================================================================================================

-- 