
-- Number of Provices

-- https://www.geeksforgeeks.org/problems/number-of-provinces/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=number_of_provinces
-- https://www.youtube.com/watch?v=ACzkVtewUYA&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=7
-- https://www.youtube.com/watch?v=muncqlKJrH0&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=8


--
from collections import defaultdict

class Solution:
    def numProvinces(self, adj, V):
        # code here 
        n = len(adj)
        m = len(adj)
        
        g = defaultdict(list)
        
        for i in range(n):
            for j in range(m):
                if adj[i][j] == 1:
                    g[i].append(j)
                    g[j].append(i)
            
            
        vis = [0] * V
        def dfs(cur):
            vis[cur] = 1
            for node in g[cur]:
                if not vis[node]:
                    dfs(node)
        
        cnt = 0
        
        for i in range(V):
            if not vis[i]:
                cnt += 1
                dfs(i)
                
                
        return cnt
--



##########################################################################################################################################################################

-- Number of Islands


-- https://chat.openai.com/c/c2a155d1-4284-4165-85cd-f52a8aa395fd
-- https://www.youtube.com/watch?v=muncqlKJrH0&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=8


--
from collections import defaultdict
import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        #code here
        n = len(grid)
        m = len(grid[0])
        
        
        def dfs(r, c, row, col, vis):
            if r < 0 or c < 0 or r >= row or c >= col or grid[r][c] != 1 or vis[r][c]:
                return
            vis[r][c] = 1
            
            for i in [-1, 0, 1]:
                for j in [-1, 0, 1]:
                    if i != 0 or j != 0:
                        new_row = r + i 
                        new_col = c + j
                        
                        dfs(new_row, new_col, row, col, vis)
            
            
        vis = [[0 for _ in range(m)] for _ in range(n)]
        
    
        cnt = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1 and not vis[i][j]:
                    cnt += 1
                    dfs(i, j, n, m, vis)
        
        return cnt
                
--


=================================================================================================================================================

-- Flood fill algo


-- https://www.geeksforgeeks.org/problems/flood-fill-algorithm1856/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=flood-fill-algorithm
-- https://www.youtube.com/watch?v=C-2_uSRli8o&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=9


--class Solution:
	def floodFill(self, image, sr, sc, newColor):
		#Code here
		
		n = len(image)
		m = len(image[0])
		
		def dfs(r, c, row, col, color):
            if r < 0 or c < 0 or r >= row or c >= col or image[r][c] != color:
                return
            image[r][c] = newColor
            
            

            
            for dr, dc in dir:
                new_row, new_col = r + dr, c + dc    
                dfs(new_row, new_col, row, col, color)
            
        initialCol = image[sr][sc]

        
        
        if initialCol != newColor:  # Only perform flood fill if the new color is different from the initial color
            dfs(sr, sc, n, m, initialCol)
        
        return image
--


======================================================================================================================================================

-- Rotten Oranges


-- https://www.geeksforgeeks.org/problems/rotten-oranges2536/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=rotten_oranges
-- https://www.youtube.com/watch?v=yf3oUhkvqA0&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=11

--
class Solution:

    #Function to find minimum time required to rot all oranges. 
	def orangesRotting(self, grid):
		#Code here
		
		r = len(grid)
        c = len(grid[0])
        
        time = 0
        count = 0
        
        q = []
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 2:
                    q.append((i, j))
                    
                    
        while q:
            for _ in range(len(q)):
                i, j = q.pop(0)
                self.checkNei(i, j, grid, r, c, q)
            if q:
                time+=1
                
                
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    return -1 
                    
                    
        return time
    
    def checkNei(self, i, j, grid, r, c, q):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        for l in range(len(x)):
            if (i + x[l]<0 or i+x[l] >= r or j+y[l] < 0 or j+y[l]>=c or grid[i+x[l]][j+y[l]] != 1 ):
                continue
            q.append((i +x[l], j+y[l]))
            grid[i + x[l]][j+y[l]] = 2
--


===========================================================================================================================================================