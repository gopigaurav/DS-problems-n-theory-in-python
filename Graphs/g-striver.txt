
-- Number of Provices

-- https://www.geeksforgeeks.org/problems/number-of-provinces/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=number_of_provinces
-- https://www.youtube.com/watch?v=ACzkVtewUYA&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=7
-- https://www.youtube.com/watch?v=muncqlKJrH0&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=8


--
from collections import defaultdict

class Solution:
    def numProvinces(self, adj, V):
        # code here 
        n = len(adj)
        m = len(adj)
        
        g = defaultdict(list)
        
        for i in range(n):
            for j in range(m):
                if adj[i][j] == 1:
                    g[i].append(j)
                    g[j].append(i)
            
            
        vis = [0] * V
        def dfs(cur):
            vis[cur] = 1
            for node in g[cur]:
                if not vis[node]:
                    dfs(node)
        
        cnt = 0
        
        for i in range(V):
            if not vis[i]:
                cnt += 1
                dfs(i)
                
                
        return cnt
--



##########################################################################################################################################################################

-- Number of Islands


-- https://chat.openai.com/c/c2a155d1-4284-4165-85cd-f52a8aa395fd
-- https://www.youtube.com/watch?v=muncqlKJrH0&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=8


--
from collections import defaultdict
import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        #code here
        n = len(grid)
        m = len(grid[0])
        
        
        def dfs(r, c, row, col, vis):
            if r < 0 or c < 0 or r >= row or c >= col or grid[r][c] != 1 or vis[r][c]:
                return
            vis[r][c] = 1
            
            for i in [-1, 0, 1]:
                for j in [-1, 0, 1]:
                    if i != 0 or j != 0:
                        new_row = r + i 
                        new_col = c + j
                        
                        dfs(new_row, new_col, row, col, vis)
            
            
        vis = [[0 for _ in range(m)] for _ in range(n)]
        
    
        cnt = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1 and not vis[i][j]:
                    cnt += 1
                    dfs(i, j, n, m, vis)
        
        return cnt
                
--


=================================================================================================================================================

-- Flood fill algo


-- https://www.geeksforgeeks.org/problems/flood-fill-algorithm1856/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=flood-fill-algorithm
-- https://www.youtube.com/watch?v=C-2_uSRli8o&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=9


--class Solution:
	def floodFill(self, image, sr, sc, newColor):
		#Code here
		
		n = len(image)
		m = len(image[0])
		
		def dfs(r, c, row, col, color):
            if r < 0 or c < 0 or r >= row or c >= col or image[r][c] != color:
                return
            image[r][c] = newColor
            
            dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            
            for dr, dc in dir:
                new_row, new_col = r + dr, c + dc    
                dfs(new_row, new_col, row, col, color)
            
        initialCol = image[sr][sc]

        
        
        if initialCol != newColor:  # Only perform flood fill if the new color is different from the initial color
            dfs(sr, sc, n, m, initialCol)
        
        return image
--


======================================================================================================================================================

-- 