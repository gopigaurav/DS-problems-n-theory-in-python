-- Introduction and concepts
Heap is a compete binary tree which satisfies Heap property


Types :-
==> Max Heap
==> Min Heap


-- Insert and delete
-- https://www.youtube.com/watch?v=ywx-Onrdx4U&list=PLUcsbZa0qzu3yNzzAxgvSgRobdUUJvz7p&index=31

============================================================================================================================================

-- Binary Heap ( Using Heapq )
from heapq import heappush, heappop, heapify 

-- https://www.geeksforgeeks.org/binary-heap/
-- https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/
-- https://www.geeksforgeeks.org/heap-sort/?ref=gcse

=======================================================================================================================================================

-- Heapify and Heap sort

-- https://www.youtube.com/watch?v=UVW0NfG_YWA&list=PLUcsbZa0qzu3yNzzAxgvSgRobdUUJvz7p&index=32
========================================================================================================================================

import heapq

# Min Heap - largest element at the end of the array at arr[0
def findKthLargest(nums, k):
    k = len(nums) - k 
    heapq.heapify(nums) # O(N)
    print(nums)
    for i in range(k): # O(klog(N))
        print(nums)
        heapq.heappop(nums)
        
    print(nums)
    print(nums[0])
    return nums[0]

============================================================================================================
# Max Heap
def findkthSmallest(nums, k):
    nums = [-num for num in nums]
    k = len(nums) - k 
    heapq.heapify(nums)
    for _ in range(k):  # Remove k-1 larger elements
        heapq.heappop(nums)
        print(nums)
    return -nums[0]

===========================================================================================================
# Min Heap
def findlarg(nums,k): # another approach
    list = []
    heapq.heapify(list)
    for i in range(len(nums)):
        heapq.heappush(list,nums[i])
        print(list) 
        if(len(list) > k):
            heapq.heappop(list)
    print(list)
    return list[0]
    return list # for k largest numbers

========================= k numbers to x closest number to find the nums =================================================================
# Max Heap
def kSmallestNo(nums, k , x): # another apprach to find the kth smallest number(aditya verma)
    num = []
    heapq.heapify(num)
    for i in range(len(nums)):
        heapq.heappush(num, (-1 * abs(x-nums[i]), nums[i]))
        if(len(num) > k):
            heapq.heappop(num)
    first_elts = [x[1] for x in num]
    print(first_elts)
    return first_elts

=================================== Sort a Nearly or K sorted Array =========================================================================
 
# A Python3 program to sort a
# nearly sorted array.

from heapq import heappop, heappush, heapify


# A utility function to print
# array elements
def print_array(arr: list):
	for elem in arr:
		print(elem, end=' ')

# Given an array of size n, where every
# element is k away from its target
# position, sorts the array in O(nLogk) time.


def sort_k(arr: list, n: int, k: int):
	"""
	:param arr: input array
	:param n: length of the array
	:param k: max distance, which every
	element is away from its target position.
	:return: None
	"""
	# List of first k+1 items
	heap = arr[:k + 1]

	# using heapify to convert list
	# into heap(or min heap)
	heapify(heap)

	# "rem_elmnts_index" is index for remaining
	# elements in arr and "target_index" is
	# target index of for current minimum element
	# in Min Heap "heap".
	target_index = 0
	for rem_elmnts_index in range(k + 1, n):
		arr[target_index] = heappop(heap)
		heappush(heap, arr[rem_elmnts_index])
		target_index += 1

	while heap:
		arr[target_index] = heappop(heap)
		target_index += 1


# Driver Code
k = 3
arr = [2, 6, 3, 12, 56, 8]
n = len(arr)
sort_k(arr, n, k)

print('Following is sorted array')
print_array(arr)

# This code is contributed by
# Veerat Beri(viratberi)

======================================== Top K frequent Numbers ====================================================================
def topfreNo(nums,k):
    freq = {}
    num = []
    for item in nums:
        if (item in freq):
            freq[item] += 1
        else:
            freq[item] = 1
    for key, value in freq.items():
        heapq.heappush(num, (value, key))
        if(len(num) > k):
            heapq.heappop(num)
    res = [x[1] for x in num]
    return res
num = [7,10,4,3,15]
arr = [15,4,21,22,23,25,44,55]
arrtfn = [1,1,1,3,3,2,2,4]
print(topfreNo(arrtfn, 3))
#print(kSmallestNo(arr, 4,22))
#print(findlarg(num,3))
print()
#print(findKthLargest(num,3))
#print(findkthSmallest(num,3))


=====================================================================================================


-- Max heapify and min heapify and heapsort

class heap:
    
    def maxheapify(self,array):
        n=len(array)
        for i in range(n//2-1,-1,-1):
            self._maxheapify(array,n,i)
            
            
    def _maxheapify(self,array,n,i):
        l=2*i+1
        r=2*i+2
        if l<n and array[l]>array[i]:
            largest=l
        else:
            largest=i
        if r<n and array[r]>array[largest]:
            largest=r
        if (largest!=i):
            array[largest],array[i]=array[i],array[largest]
            self._maxheapify(array,n,largest)
            
            
    def minheapify(self,array):
        n = len(array)
        for i in range(n//2-1,-1,-1):
            self._minheapify(array,n,i)
            
            
    def _minheapify(self,array,n,i):
        l=2*i+1
        r=2*i+2
        if l<n and array[l]<array[i]:
            smallest = l
        else:
            smallest = i
        if r < n and array[r]<array[smallest]:
            smallest = r
        if (smallest != i):
            array[smallest], array[i] = array[i], array[smallest]
            self._minheapify(array, n, smallest)
            
            
    def descending_heapsort(self,array):
        n = len(array)
        for i in range(n // 2 - 1, -1, -1):
            self._minheapify(array, n, i)
        for i in range(n - 1, 0, -1):
            array[0], array[i] = array[i], array[0]
            self._minheapify(array, i, 0)


    def ascending_heapsort(self,array):
        n=len(array)
        for i in range(n//2-1,-1,-1):
            self._maxheapify(array,n,i)
        for i in range(n-1,0,-1):
            array[0],array[i]=array[i],array[0]
            self._maxheapify(array,i,0)

b=[550,4520,3,2340,12]
a=heap()

a.maxheapify(b)
print('Max Heapify -->',b)

a.minheapify(b)
print('Min Heapify -->',b)

a.ascending_heapsort(b)
print('Ascending Heap Sort -->',b)

a.descending_heapsort(b)
print('Descending Heap Sort -->',b)

=========================================================================================================================



-- Find median from data stream

-- https://leetcode.com/problems/find-median-from-data-stream/submissions/
-- https://www.geeksforgeeks.org/median-of-stream-of-running-integers-using-stl/
-- https://www.youtube.com/watch?v=itmhHWaHupI&t=1273s



#from heapq import * 


class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        heapq.heappush(self.small, -1* num) # first add num to small array that is max heap
        
        # make sure every num in small is <= every element in large
        if self.small and self.large and (-1* self.small[0] > self.large[0]):
            val = -1 * heapq.heappop(self.small) # pop from small
            heapq.heappush(self.large,val) # push the val to large if element in small is greater than large
            
        # uneven size
        if len(self.small) > len(self.large) + 1: # if small is greater len than large with 2 and greater then pop from small and push it to large
            val = -1 * heapq.heappop(self.small) # pop from small
            heapq.heappush(self.large,val)
            
        
        if len(self.large) > len(self.small) + 1: # vice versa for above "if"
            val = heapq.heappop(self.large) # pop from large
            heapq.heappush(self.small,-1 * val) # push it to small

    def findMedian(self):
        # odd length
        if len(self.small) > len(self.large):
            return (-1 * self.small[0])
        
        if len(self.large) > len(self.small):
            return self.large[0]
        
        return ((-1 * self.small[0] + self.large[0])/2)
            





===================================================================================================================================================

-- Operations on Binary Min Heaps

-- https://www.geeksforgeeks.org/binary-heap/

-- 
# A Python program to demonstrate common binary heap operations

# Import the heap functions from python library
from heapq import heappush, heappop, heapify

# heappop - pop and return the smallest element from heap
# heappush - push the value item onto the heap, maintaining
#			 heap invarient
# heapify - transform list into heap, in place, in linear time

# A class for Min Heap
class MinHeap:
	
	# Constructor to initialize a heap
	def __init__(self):
		self.heap = []

	def parent(self, i):
		return (i-1)/2
	
	# Inserts a new key 'k'
	def insertKey(self, k):
		heappush(self.heap, k)		

	# Decrease value of key at index 'i' to new_val
	# It is assumed that new_val is smaller than heap[i]
	def decreaseKey(self, i, new_val):
		self.heap[i] = new_val
		while(i != 0 and self.heap[self.parent(i)] > self.heap[i]):
			# Swap heap[i] with heap[parent(i)]
			self.heap[i] , self.heap[self.parent(i)] = (
			self.heap[self.parent(i)], self.heap[i])
			
	# Method to remove minium element from min heap
	def extractMin(self):
		return heappop(self.heap)

	# This functon deletes key at index i. It first reduces
	# value to minus infinite and then calls extractMin()
	def deleteKey(self, i):
		self.decreaseKey(i, float("-inf"))
		self.extractMin()

	# Get the minimum element from the heap
	def getMin(self):
		return self.heap[0]

# Driver pgoratm to test above function
heapObj = MinHeap()
heapObj.insertKey(3)
heapObj.insertKey(2)
heapObj.deleteKey(1)
heapObj.insertKey(15)
heapObj.insertKey(5)
heapObj.insertKey(4)
heapObj.insertKey(45)

print heapObj.extractMin(),
print heapObj.getMin(),
heapObj.decreaseKey(2, 1)
print heapObj.getMin()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)


================================================================================================================================


-- Heapsort 

-- https://www.geeksforgeeks.org/heap-sort/?ref=gcse

# Python program for implementation of heap Sort

# To heapify subtree rooted at index i.
# n is size of heap


def heapify(arr, n, i):
	largest = i # Initialize largest as root
	l = 2 * i + 1	 # left = 2*i + 1
	r = 2 * i + 2	 # right = 2*i + 2

	# See if left child of root exists and is
	# greater than root
	if l < n and arr[largest] < arr[l]:
		largest = l

	# See if right child of root exists and is
	# greater than root
	if r < n and arr[largest] < arr[r]:
		largest = r

	# Change root, if needed
	if largest != i:
		arr[i], arr[largest] = arr[largest], arr[i] # swap

		# Heapify the root.
		heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
	n = len(arr)

	# Build a maxheap.
	for i in range(n//2 - 1, -1, -1):
		heapify(arr, n, i)

	# One by one extract elements
	for i in range(n-1, 0, -1):
		arr[i], arr[0] = arr[0], arr[i] # swap
		heapify(arr, i, 0)


# Driver code
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
n = len(arr)
print("Sorted array is")
for i in range(n):
	print("%d" % arr[i],end=" ")
# This code is contributed by Mohit Kumra

=============================================================================================================================================





        