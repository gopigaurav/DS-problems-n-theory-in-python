-- Subarrays with k diff integers (Imp)


-- https://leetcode.com/problems/subarrays-with-k-different-integers/
--


--
class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        res = 0
        cnt = [0] * (len(nums) + 1)
        l = 0
        r= 0
        windowCnt = 0  # Current number of valid subarrays in the window

        while r < len(nums):
            if cnt[nums[r]] == 0:
                k-=1
            cnt[nums[r]] += 1

            while k < 0: 
                cnt[nums[l]] -=1
                if cnt[nums[l]] == 0:
                    k+=1
                l += 1
                windowCnt = 0

            # this helps you count the number of subarrays 
            if k == 0:
                while cnt[nums[l]] > 1:
                    cnt[nums[l]] -= 1
                    l+=1
                    windowCnt += 1

                res += (windowCnt+1)


            r +=1

        return res
--


====================================================================================================


-- Minimum number of k consecutive bit flips


-- https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/
--


--
class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        # Keeps track of flipped states
        flipped = [False] * len(nums)

        # Tracks valid flips within the past window
        validFlipsFromPastWindow = 0

        # Counts total flips needed
        flipCount = 0

        for i in range(len(nums)):
            if i >= k:
                # Decrease count of valid flips from the past window if needed
                if flipped[i - k]:
                    validFlipsFromPastWindow -= 1

            # Check if current bit needs to be flipped
            if validFlipsFromPastWindow % 2 == nums[i]:
                # If flipping the window extends beyond the array length,
                # return -1
                if i + k > len(nums):
                    return -1

                # Increment the count of valid flips and
                # mark current as flipped
                validFlipsFromPastWindow += 1
                flipped[i] = True
                flipCount += 1

        return flipCount
--


================================================================================================================

-- Longest chunked palindrome decomposition


-- https://leetcode.com/problems/longest-chunked-palindrome-decomposition/
--


--
class Solution:
    def longestDecomposition(self, text: str) -> int:
        n = len(text)
        left, right = 0, n - 1
        count = 0
        left_part, right_part = "", ""
        
        while left < right:
            left_part += text[left]
            right_part = text[right] + right_part  # Prepend to maintain order
            
            if left_part == right_part:
                # print(left_part, right_part)
                count += 2
                left_part, right_part = "", ""  # Reset after a valid split
            
            left += 1
            right -= 1

        
        if left_part != right_part or left == right:
            return count + 1
        else:
            return count
        
--

==================================================================================================================


-- Maximum level sum of a binary tree


-- https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        from collections import deque
        max_level = 1
        lvl = 0
        max_sum = root.val
        q = deque([root])

        while q:
            size = len(q)
            csum = 0
            lvl += 1
            for i in range(size):
                temp = q.popleft()
                csum += temp.val

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
            
            if csum > max_sum:
                max_sum = csum
                max_level = lvl

        return max_level
        
--


=============================================================================================================

-- As Far from land as possible


-- https://leetcode.com/problems/as-far-from-land-as-possible/description/
--


--
class Solution:
    def lastSubstring(self, s: str) -> str:
        s = list(s)
        n = len(s)
        
        # Initialize pointers
        # start by locating maximum character and its index
        start = max(s)
        i = s.index(start)
        j = i + 1
        
        while j < n:
            # Find the next candidate where s[j] >= s[i]
            while j < n and s[j] < s[i]:
                j += 1
            
            if j >= n:
                # If we have reached the end, return the substring from i
                return "".join(s[i:])
            
            # Compare substrings starting from i and j
            l, r = i + 1, j + 1
            while r < n and s[l] == s[r] and l < j:
                l += 1
                r += 1
            
            if r == n:
                # If r reached the end, the substring from i is the result
                return "".join(s[i:])
            
            # Update the index i or j based on the comparison
            if s[l] < s[r]:
                i = j
            else:
                j = r
        
        return "".join(s[i:])

    def lastSubstring1(self, s: str) -> str:
        n = len(s)
        start = max(s)
        i = s.index(start)
        j = i + 1
    
        while j < n:
            k = 0  # Offset for comparison
            while j + k < n and s[i + k] == s[j + k]:
                k += 1
            if j + k < n and s[i + k] < s[j + k]:  # Found a lexicographically greater suffix
                i = j
            j += 1  # Move to the next candidate
        
        return s[i:]
--


===========================================================================================================



