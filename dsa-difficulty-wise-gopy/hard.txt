-- Subarrays with k diff integers (Imp)


-- https://leetcode.com/problems/subarrays-with-k-different-integers/
--


--
class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        res = 0
        cnt = [0] * (len(nums) + 1)
        l = 0
        r= 0
        windowCnt = 0  # Current number of valid subarrays in the window

        while r < len(nums):
            if cnt[nums[r]] == 0:
                k-=1
            cnt[nums[r]] += 1

            while k < 0: 
                cnt[nums[l]] -=1
                if cnt[nums[l]] == 0:
                    k+=1
                l += 1
                windowCnt = 0

            # this helps you count the number of subarrays 
            if k == 0:
                while cnt[nums[l]] > 1:
                    cnt[nums[l]] -= 1
                    l+=1
                    windowCnt += 1

                res += (windowCnt+1)


            r +=1

        return res
--


====================================================================================================


-- Minimum number of k consecutive bit flips


-- https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/
--


--
class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        # Keeps track of flipped states
        flipped = [False] * len(nums)

        # Tracks valid flips within the past window
        validFlipsFromPastWindow = 0

        # Counts total flips needed
        flipCount = 0

        for i in range(len(nums)):
            if i >= k:
                # Decrease count of valid flips from the past window if needed
                if flipped[i - k]:
                    validFlipsFromPastWindow -= 1

            # Check if current bit needs to be flipped
            if validFlipsFromPastWindow % 2 == nums[i]:
                # If flipping the window extends beyond the array length,
                # return -1
                if i + k > len(nums):
                    return -1

                # Increment the count of valid flips and
                # mark current as flipped
                validFlipsFromPastWindow += 1
                flipped[i] = True
                flipCount += 1

        return flipCount
--


================================================================================================================

-- Longest chunked palindrome decomposition


-- https://leetcode.com/problems/longest-chunked-palindrome-decomposition/
--


--
class Solution:
    def longestDecomposition(self, text: str) -> int:
        n = len(text)
        left, right = 0, n - 1
        count = 0
        left_part, right_part = "", ""
        
        while left < right:
            left_part += text[left]
            right_part = text[right] + right_part  # Prepend to maintain order
            
            if left_part == right_part:
                # print(left_part, right_part)
                count += 2
                left_part, right_part = "", ""  # Reset after a valid split
            
            left += 1
            right -= 1

        
        if left_part != right_part or left == right:
            return count + 1
        else:
            return count
        
--

==================================================================================================================


-- Maximum level sum of a binary tree


-- https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        from collections import deque
        max_level = 1
        lvl = 0
        max_sum = root.val
        q = deque([root])

        while q:
            size = len(q)
            csum = 0
            lvl += 1
            for i in range(size):
                temp = q.popleft()
                csum += temp.val

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
            
            if csum > max_sum:
                max_sum = csum
                max_level = lvl

        return max_level
        
--


=============================================================================================================

-- As Far from land as possible


-- https://leetcode.com/problems/as-far-from-land-as-possible/description/
--


--
class Solution:
    def lastSubstring(self, s: str) -> str:
        s = list(s)
        n = len(s)
        
        # Initialize pointers
        # start by locating maximum character and its index
        start = max(s)
        i = s.index(start)
        j = i + 1
        
        while j < n:
            # Find the next candidate where s[j] >= s[i]
            while j < n and s[j] < s[i]:
                j += 1
            
            if j >= n:
                # If we have reached the end, return the substring from i
                return "".join(s[i:])
            
            # Compare substrings starting from i and j
            l, r = i + 1, j + 1
            while r < n and s[l] == s[r] and l < j:
                l += 1
                r += 1
            
            if r == n:
                # If r reached the end, the substring from i is the result
                return "".join(s[i:])
            
            # Update the index i or j based on the comparison
            if s[l] < s[r]:
                i = j
            else:
                j = r
        
        return "".join(s[i:])

    def lastSubstring1(self, s: str) -> str:
        n = len(s)
        start = max(s)
        i = s.index(start)
        j = i + 1
    
        while j < n:
            k = 0  # Offset for comparison
            while j + k < n and s[i + k] == s[j + k]:
                k += 1
            if j + k < n and s[i + k] < s[j + k]:  # Found a lexicographically greater suffix
                i = j
            j += 1  # Move to the next candidate
        
        return s[i:]
--


===========================================================================================================


-- Invalid transactions


--
-- https://leetcode.com/problems/invalid-transactions/


--
class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        transaction_data = []
        invalid = set()

        # Parse transactions
        for i, transaction in enumerate(transactions):
            name, time, amount, city = transaction.split(',')
            transaction_data.append((name, int(time), int(amount), city, i))

        # Check first condition: Amount exceeds $1000
        for name, time, amount, city, i in transaction_data:
            if amount > 1000:
                invalid.add(i)

        # Group transactions by name
        transactions_by_name = defaultdict(list)
        for entry in transaction_data:
            transactions_by_name[entry[0]].append(entry)

        # Check second condition: Same name, different city, within 60 minutes
        for name, entries in transactions_by_name.items():
            entries.sort(key=lambda x: x[1])  # Sort by time
            for i in range(len(entries)):
                for j in range(i + 1, len(entries)):
                    if abs(entries[i][1] - entries[j][1]) <= 60 and entries[i][3] != entries[j][3]:
                        invalid.add(entries[i][4])
                        invalid.add(entries[j][4])

        return [transactions[i] for i in invalid]
--

=========================================================================================================

-- Remove zero sum consecutive noddes from linked list (Imp)


-- https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
--


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        prefix_sum = 0
        prefix_map = {0: dummy}

        current = dummy
        while current:
            prefix_sum += current.val
            prefix_map[prefix_sum] = current
            current = current.next
        # print(prefix_sum, prefix_map)

        prefix_sum = 0
        current = dummy
        while current:
            prefix_sum += current.val
            current.next = prefix_map[prefix_sum].next  # Skip nodes summing to zero
            current = current.next

        return dummy.next
        
--


========================================================================================================

-- Can make palindrome from substring (Imp)



--
-- https://leetcode.com/problems/can-make-palindrome-from-substring/


--
class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        n = len(s)
        prefix = [[0] * 26 for _ in range(n + 1)]  # 26 for lowercase 'a' to 'z'
        
        for i in range(n):
            prefix[i + 1] = prefix[i][:]  # Copy previous counts
            prefix[i + 1][ord(s[i]) - ord('a')] += 1  # Increment count of current char
        
        res = []
        
        # Step 2: Process each query in O(1)
        for left, right, k in queries:
            # Step 2a: Get the character frequency in range [left, right]
            odd_count = 0
            for j in range(26):
                if (prefix[right + 1][j] - prefix[left][j]) % 2 == 1:
                    odd_count += 1  # Count characters with odd frequency

            # Step 2b: Check if k is sufficient to balance odd counts
            if odd_count // 2 <= k:
                res.append(True)
            else:
                res.append(False)
        
        return res
        
--


=======================================================================================================


-- 

