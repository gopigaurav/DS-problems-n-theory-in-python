-- Subarrays with k diff integers (Imp)


-- https://leetcode.com/problems/subarrays-with-k-different-integers/
--


--
class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        res = 0
        cnt = [0] * (len(nums) + 1)
        l = 0
        r= 0
        windowCnt = 0  # Current number of valid subarrays in the window

        while r < len(nums):
            if cnt[nums[r]] == 0:
                k-=1
            cnt[nums[r]] += 1

            while k < 0: 
                cnt[nums[l]] -=1
                if cnt[nums[l]] == 0:
                    k+=1
                l += 1
                windowCnt = 0

            # this helps you count the number of subarrays 
            if k == 0:
                while cnt[nums[l]] > 1:
                    cnt[nums[l]] -= 1
                    l+=1
                    windowCnt += 1

                res += (windowCnt+1)


            r +=1

        return res
--


====================================================================================================


-- Minimum number of k consecutive bit flips


-- https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/
--


--
class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        # Keeps track of flipped states
        flipped = [False] * len(nums)

        # Tracks valid flips within the past window
        validFlipsFromPastWindow = 0

        # Counts total flips needed
        flipCount = 0

        for i in range(len(nums)):
            if i >= k:
                # Decrease count of valid flips from the past window if needed
                if flipped[i - k]:
                    validFlipsFromPastWindow -= 1

            # Check if current bit needs to be flipped
            if validFlipsFromPastWindow % 2 == nums[i]:
                # If flipping the window extends beyond the array length,
                # return -1
                if i + k > len(nums):
                    return -1

                # Increment the count of valid flips and
                # mark current as flipped
                validFlipsFromPastWindow += 1
                flipped[i] = True
                flipCount += 1

        return flipCount
--


================================================================================================================

-- Longest chunked palindrome decomposition


-- https://leetcode.com/problems/longest-chunked-palindrome-decomposition/
--


--
class Solution:
    def longestDecomposition(self, text: str) -> int:
        n = len(text)
        left, right = 0, n - 1
        count = 0
        left_part, right_part = "", ""
        
        while left < right:
            left_part += text[left]
            right_part = text[right] + right_part  # Prepend to maintain order
            
            if left_part == right_part:
                # print(left_part, right_part)
                count += 2
                left_part, right_part = "", ""  # Reset after a valid split
            
            left += 1
            right -= 1

        
        if left_part != right_part or left == right:
            return count + 1
        else:
            return count
        
--

==================================================================================================================


-- Maximum level sum of a binary tree


-- https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        from collections import deque
        max_level = 1
        lvl = 0
        max_sum = root.val
        q = deque([root])

        while q:
            size = len(q)
            csum = 0
            lvl += 1
            for i in range(size):
                temp = q.popleft()
                csum += temp.val

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
            
            if csum > max_sum:
                max_sum = csum
                max_level = lvl

        return max_level
        
--


=============================================================================================================

-- As Far from land as possible


-- https://leetcode.com/problems/as-far-from-land-as-possible/description/
--


--
class Solution:
    def lastSubstring(self, s: str) -> str:
        s = list(s)
        n = len(s)
        
        # Initialize pointers
        # start by locating maximum character and its index
        start = max(s)
        i = s.index(start)
        j = i + 1
        
        while j < n:
            # Find the next candidate where s[j] >= s[i]
            while j < n and s[j] < s[i]:
                j += 1
            
            if j >= n:
                # If we have reached the end, return the substring from i
                return "".join(s[i:])
            
            # Compare substrings starting from i and j
            l, r = i + 1, j + 1
            while r < n and s[l] == s[r] and l < j:
                l += 1
                r += 1
            
            if r == n:
                # If r reached the end, the substring from i is the result
                return "".join(s[i:])
            
            # Update the index i or j based on the comparison
            if s[l] < s[r]:
                i = j
            else:
                j = r
        
        return "".join(s[i:])

    def lastSubstring1(self, s: str) -> str:
        n = len(s)
        start = max(s)
        i = s.index(start)
        j = i + 1
    
        while j < n:
            k = 0  # Offset for comparison
            while j + k < n and s[i + k] == s[j + k]:
                k += 1
            if j + k < n and s[i + k] < s[j + k]:  # Found a lexicographically greater suffix
                i = j
            j += 1  # Move to the next candidate
        
        return s[i:]
--


===========================================================================================================


-- Invalid transactions


--
-- https://leetcode.com/problems/invalid-transactions/


--
class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        transaction_data = []
        invalid = set()

        # Parse transactions
        for i, transaction in enumerate(transactions):
            name, time, amount, city = transaction.split(',')
            transaction_data.append((name, int(time), int(amount), city, i))

        # Check first condition: Amount exceeds $1000
        for name, time, amount, city, i in transaction_data:
            if amount > 1000:
                invalid.add(i)

        # Group transactions by name
        transactions_by_name = defaultdict(list)
        for entry in transaction_data:
            transactions_by_name[entry[0]].append(entry)

        # Check second condition: Same name, different city, within 60 minutes
        for name, entries in transactions_by_name.items():
            entries.sort(key=lambda x: x[1])  # Sort by time
            for i in range(len(entries)):
                for j in range(i + 1, len(entries)):
                    if abs(entries[i][1] - entries[j][1]) <= 60 and entries[i][3] != entries[j][3]:
                        invalid.add(entries[i][4])
                        invalid.add(entries[j][4])

        return [transactions[i] for i in invalid]
--

=========================================================================================================

-- Remove zero sum consecutive noddes from linked list (Imp)


-- https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
--


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        prefix_sum = 0
        prefix_map = {0: dummy}

        current = dummy
        while current:
            prefix_sum += current.val
            prefix_map[prefix_sum] = current
            current = current.next
        # print(prefix_sum, prefix_map)

        prefix_sum = 0
        current = dummy
        while current:
            prefix_sum += current.val
            current.next = prefix_map[prefix_sum].next  # Skip nodes summing to zero
            current = current.next

        return dummy.next
        
--


========================================================================================================

-- Can make palindrome from substring (Imp)



--
-- https://leetcode.com/problems/can-make-palindrome-from-substring/


--
class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        n = len(s)
        prefix = [[0] * 26 for _ in range(n + 1)]  # 26 for lowercase 'a' to 'z'
        
        for i in range(n):
            prefix[i + 1] = prefix[i][:]  # Copy previous counts
            prefix[i + 1][ord(s[i]) - ord('a')] += 1  # Increment count of current char
        
        res = []
        
        # Step 2: Process each query in O(1)
        for left, right, k in queries:
            # Step 2a: Get the character frequency in range [left, right]
            odd_count = 0
            for j in range(26):
                if (prefix[right + 1][j] - prefix[left][j]) % 2 == 1:
                    odd_count += 1  # Count characters with odd frequency

            # Step 2b: Check if k is sufficient to balance odd counts
            if odd_count // 2 <= k:
                res.append(True)
            else:
                res.append(False)
        
        return res
        
--


=======================================================================================================


-- Make array strictly increasing


--
--


--
class Solution:
    def makeArrayIncreasing2(self, arr1: List[int], arr2: List[int]) -> int:
        from collections import defaultdict

        def binary_search(arr, target):
            """Finds the index of the first element greater than target in arr."""
            left, right = 0, len(arr) - 1
            ans = -1  # Default if no valid element is found

            while left <= right:
                mid = (left + right) // 2
                if arr[mid] > target:  # Found a candidate
                    ans = mid  # Store possible answer
                    right = mid - 1  # Look for smaller element on the left
                else:
                    left = mid + 1  # Move right to find a greater element

            return ans  # Index of the first element greater than target or -1

        arr2 = sorted(set(arr2))  # Remove duplicates and sort
        dp = {-1: 0}  # Stores (prev_value, min_operations)

        for num in arr1:
            new_dp = {}
            for prev_val, ops in dp.items():
                # Case 1: Keep num if it's strictly increasing
                if num > prev_val:
                    new_dp[num] = min(new_dp.get(num, float('inf')), ops)

                # Case 2: Replace with the smallest greater element in arr2
                idx = binary_search(arr2, prev_val)  # Use our custom binary search
                if idx != -1:  # Valid replacement found
                    new_dp[arr2[idx]] = min(new_dp.get(arr2[idx], float('inf')), ops + 1)

            if not new_dp:
                return -1  # No valid increasing sequence possible
            dp = new_dp  # Move to next state

        return min(dp.values())
        
    def makeArrayIncreasing(self, arr1, arr2):
        arr2.sort()  # Sort arr2 for binary search
        n = len(arr1)

        def binary_search(arr, target):
            """Finds the index of the first element greater than target in arr."""
            left, right = 0, len(arr) - 1
            ans = -1  # Default if no valid element is found

            while left <= right:
                mid = (left + right) // 2
                if arr[mid] > target:  # Found a candidate
                    ans = mid  # Store possible answer
                    right = mid - 1  # Look for smaller element on the left
                else:
                    left = mid + 1  # Move right to find a greater element

            return ans 

        dp = {}  # Memoization

        def helper(index, prev):
            if index == n:
                return 0  # Successfully reached the end

            if (index, prev) in dp:
                return dp[(index, prev)]

            ans = float('inf')  # Use a large value

            # Option 1: Keep arr1[index] if it maintains the increasing order
            if arr1[index] > prev:
                ans = min(ans, helper(index + 1, arr1[index]))

            # Option 2: Replace arr1[index] with a value from arr2
            next_greater = binary_search(arr2, prev)
            if next_greater != -1:
                ans = min(ans, 1 + helper(index + 1, arr2[next_greater]))

            dp[(index, prev)] = ans
            return ans

        result = helper(0, -1)
        return result if result != float('inf') else -1

    from bisect import bisect_right

    def makeArrayIncreasing3(self, arr1, arr2):
        arr2.sort()  # Sorting arr2 for binary search
        n = len(arr1)
        
        # DP table: Key = (index, changes), Value = minimum last value possible
        dp = { -1:  -1 }  # Start with -1 as the last element
        
        for num in arr1:
            new_dp = {}
            
            for key in dp:
                # Case 1: Keep the current `num` if it maintains the increasing order
                if num > dp[key]:  
                    new_dp[key] = min(new_dp.get(key, float('inf')), num)

                # Case 2: Replace `num` with the smallest larger number in `arr2`
                idx = bisect_right(arr2, dp[key])  # Find the smallest larger element in `arr2`
                if idx < len(arr2):  # If a valid replacement exists
                    new_dp[key + 1] = min(new_dp.get(key + 1, float('inf')), arr2[idx])

            if not new_dp:  
                return -1  # If no valid sequence is found

            dp = new_dp  # Move to the next iteration

        return min(dp.keys())  # Return the minimum changes required



--


=======================================================================================================


-- Reverse substrings between each pair of parenthesis 


-- https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/submissions/1550913266/
--


--
class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []

        for char in s:
            if char == ')':
                temp = []
                while stack and stack[-1] != "(":
                    temp.append(stack.pop())
                stack.pop() # poping the "(" bracket
                stack.extend(temp)
            else:
                stack.append(char)
        
        return ''.join(stack)
        
--


=====================================================================================================


-- K concentration maximum sum (Imp)


-- https://leetcode.com/problems/k-concatenation-maximum-sum/
--


--
class Solution:
    def kConcatenationMaxSum1(self, arr: List[int], k: int) -> int:
        MOD = 10**9 + 7

        def kadane(nums):
            max_sum = curr_sum = 0  # Allow empty subarray
            for num in nums:
                curr_sum = max(num, curr_sum + num)
                max_sum = max(max_sum, curr_sum)
            return max_sum
        
        max_kadane = kadane(arr)  # Maximum subarray sum for one array
        if k == 1:
            return max_kadane % MOD
        
        prefix_sum = suffix_sum = total_sum = 0
        curr_prefix = curr_suffix = 0

        # Calculate prefix sum
        for num in arr:
            curr_prefix += num
            prefix_sum = max(prefix_sum, curr_prefix)

        # Calculate suffix sum
        for num in reversed(arr):
            curr_suffix += num
            suffix_sum = max(suffix_sum, curr_suffix)

        # Calculate total sum
        total_sum = sum(arr)

        # If total sum is positive, consider adding (k-2) times the total sum
        if total_sum > 0:
            result = max(prefix_sum + suffix_sum + (k-2) * total_sum, max_kadane)
        else:
            result = max(prefix_sum + suffix_sum, max_kadane)
        
        return result % MOD

    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        MOD=10**9+7
        def kadane(arr):
            curr=res=0
            for i in range(len(arr)):
                if curr<0:
                    curr=0
                curr+=arr[i]
                if curr>res:
                    res=curr
            return res

        res=0
        if sum(arr)>=0:
            if k>=2:
                temp=kadane(arr*2)
                res=temp+(k-2)*(sum(arr))
            else:
                res=kadane(arr)
        else:
            if k>=2:
                res=kadane(arr*2)
            else:
                res=kadane(arr)

        return res%MOD
--


====================================================================================================


-- Count vowels permutation


--
-- https://leetcode.com/problems/count-vowels-permutation/


--
class Solution:
    def countVowelPermutation(self, n: int) -> int:
        MOD = 10**9 + 7

        # Representing 'a', 'e', 'i', 'o', 'u' as indexes 0, 1, 2, 3, 4
        a, e, i, o, u = 1, 1, 1, 1, 1  # Base case for n = 1

        for _ in range(n - 1):
            a_new = (e) % MOD
            e_new = (a + i) % MOD
            i_new = (a + e + o + u) % MOD
            o_new = (i + u) % MOD
            u_new = (a) % MOD

            a, e, i, o, u = a_new, e_new, i_new, o_new, u_new

        return (a + e + i + o + u) % MOD
        

class Solution:
    def countVowelPermutation(self, n: int) -> int:
        m = 5
        dp = [[1] * 5 for _ in range(n)]

        for i in range(n - 2, -1, -1):
            for letter in range(5):
                # a
                if letter == 0:
                    dp[i][letter] = dp[i + 1][1] # 'a' follwed by 'e'
                ## e
                elif letter == 1:
                    dp[i][letter] = dp[i + 1][0] + dp[i + 1][2] # 'e' followed by 'a' or 'i' 
                ## i
                elif letter == 2:
                    dp[i][letter] = dp[i + 1][0] + dp[i + 1][1] + dp[i + 1][3] + dp[i + 1][4] # 'i' not followed by 'i'
                ## o
                elif letter == 3:
                    dp[i][letter] = dp[i + 1][2] + dp[i + 1][4] # 'o' followed by 'i' or 'u' 
                ## u
                else:
                    dp[i][letter] = dp[i + 1][0] # 'u' followed by 'a'

            dp[i][letter] = dp[i][letter] % (10**9 + 7)#
        
        return sum(dp[0]) % (10**9 + 7)
--


========================================================================================================

-- Queens that can attack the king


--
-- https://leetcode.com/problems/queens-that-can-attack-the-king/


--
class Solution:
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        queen_set = {(x, y) for x, y in queens}  # Convert to set for O(1) lookup
        xK, yK = king
        
        # Possible directions (dx, dy)
        directions = [
            (0, 1), (0, -1),  # Left, Right
            (1, 0), (-1, 0),  # Down, Up
            (1, 1), (-1, -1),  # Bottom-right, Top-left diagonal
            (1, -1), (-1, 1)   # Bottom-left, Top-right diagonal
        ]
        
        result = []
        
        # Check each direction
        for dx, dy in directions:
            x, y = xK, yK
            while 0 <= x < 8 and 0 <= y < 8:  # Stay within board limits
                x += dx
                y += dy
                if (x, y) in queen_set:
                    result.append([x, y])
                    break  # Stop at the first queen in this direction
        
        return result
        
--


========================================================================================================

-- Tiling a rectangle witht the fewest squares


--
-- https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/


--
class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        # 11x13 appears to be the only case where there is a square in the middle
        if max(m, n) == 13 and min(m, n) == 11:
            return 6

        # assume that there exists a horizontal or vertical cut
        @cache
        def deeper(a, b):
            # already a square
            if a == b:
                return 1

            # a single row / column
            if min(a, b) == 1:
                return max(a, b)

            # ensure a >= b
            if a < b:
                return deeper(b, a)

            best = +inf
            # try all horizontal and vertical cuts
            for i in range(1, a):
                best = min(best, deeper(i, b) + deeper(a - i, b))
            for i in range(1, b):
                best = min(best, deeper(a, i) + deeper(a, b - i))
            return best

        return deeper(m, n)
--


====================================================================================================


-- Maimum point after coletiong coins from all nodes (Imp) 



-- https://leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes/
-- https://www.youtube.com/watch?v=3f7Vz6pnJ-Q


--
from collections import defaultdict
class Solution:
    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:

        n = len(edges)
        g = defaultdict(list)

        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
        
        memo = {}

        def dfs(node, count, parent):

            if (node, count) in memo:
                return memo[(node, count)]

            # consider first choice
            ans1 = 0
            # consider second choice
            ans2 = 0

            for nei in g[node]:
                if nei != parent:
                    ans1 += dfs(nei, count, node)

                    if count <= 13:
                        ans2 += dfs(nei, count + 1, node)

            cur_val = coins[node]
            cur_val /= pow(2, count)

            memo[(node, count)] = max(cur_val - k + ans1, cur_val // 2 + ans2)
            return memo[(node, count)]
        
        return int(dfs(0, 0, -1))

--


=========================================================================================================

-- Count complete substrings (Imp)

--
-- https://www.youtube.com/watch?v=ygPMLjxaT2Y


--
from collections import defaultdict

class Solution:
    def countCompleteSubstrings(self, word: str, k: int) -> int:
        def solve(start, end, k):
            result = 0
            for unique_char in range(1, 27):
                window_length = unique_char * k

                if window_length > end - start + 1:
                    break

                count = defaultdict(int)
                good = 0
                i = start

                for j in range(start, end + 1):
                    count[word[j]] += 1

                    if count[word[j]] == k:
                        good += 1
                    elif count[word[j]] == k + 1:
                        good -= 1

                    if j - i + 1 > window_length:
                        if count[word[i]] == k:
                            good -= 1
                        elif count[word[i]] == k + 1:
                            good += 1
                        count[word[i]] -= 1
                        if count[word[i]] == 0:
                            del count[word[i]]
                        i += 1

                    if good == unique_char:
                        result += 1
            return result

        res = 0
        n = len(word)
        last = 0

        for i in range(1, n):
            if abs(ord(word[i]) - ord(word[i - 1])) > 2:
                res += solve(last, i - 1, k)
                last = i
        res += solve(last, n - 1, k)  # process the last segment
        return res

--


========================================================================================================


-- Count the number of infection squeences (Imp) (stars and bars, ncr, pnc)


-- https://leetcode.com/problems/count-the-number-of-infection-sequences/
-- https://www.youtube.com/watch?v=kvJ4CTPzX74

--
class Solution:
    MOD = 10 ** 9 + 7

    @staticmethod
    @cache
    def factorial(n: int) -> int:
        if n == 0:
            return 1
        return n * Solution.factorial(n - 1) % Solution.MOD

    def numberOfSequence(self, n: int, sick: List[int]) -> int:
        # DD, DDD, DDDD
        # 9! / 2! / 3! / 4! * (1) * (2 * 2 * 1) * (1)
        lengths = [sick[0], n - sick[-1] - 1]
        for a, b in pairwise(sick):
            length = b - a - 1
            if length > 0:
                lengths.append(length)

        res = Solution.factorial(sum(lengths))
        for i, x in enumerate(lengths):
            res *= pow(Solution.factorial(x), -1, Solution.MOD)
            res %= Solution.MOD

            # do not multiply by 2 for beginning and end
            if i >= 2:
                res *= pow(2, x - 1, Solution.MOD)
                res %= Solution.MOD

        return res
--


======================================================================================================= 


-- Count the number of good partitions (Imp)


-- https://leetcode.com/problems/count-the-number-of-good-partitions/submissions/1621872412/
--


--
from collections import defaultdict
class Solution:
    def numberOfGoodPartitions(self, nums: List[int]) -> int:
        
        # use map to store the numbers with the last index of the particular number
        # use i, j and iterate over the nums and partition the arrays with 2 choices whether to divide there or not
        # at the end send the total number of possible continuous subarrays
        
        m = defaultdict(int)
        n = len(nums)
        mod = 10**9 + 7
        
        for i in range(n):
            m[nums[i]] = i
        res = 1
        i = 0
        j = max(i, m[nums[0]])

        while i < n:
            if i > j:
                res = (res * 2) % mod
            j = max(j, m[nums[i]])
            i += 1
        return res

--

======================================================================================================



-- apply operations to maximize frequency score (Imp)


-- https://www.youtube.com/watch?v=Iaz-8ZQYUvs
-- https://leetcode.com/problems/apply-operations-to-maximize-frequency-score/


--
from collections import Counter
class Solution:
    def maxFrequencyScore(self, nums: List[int], k: int) -> int:
        # Using binary search on the answer
        # the min score or answer we can get from is 1 and max_Score we can get is n
        # using this we can perform extra check on the sorted input which every possible 1 to n window 
        # if the elements in them made equal or not
        # also prefix sum to get the window sum to check whether it can be equal or not.

        nums.sort()
        n = len(nums)
        prefix = [0] * n
        prefix[0] = nums[0]

        for i in range(1, n):
            prefix[i] = prefix[i - 1] + nums[i]

        min_score = 1
        max_score = n
        ans = 0

        def checker(window):
            
            i = 0
            j = window - 1

            while j < n:
                target_ind = i + (j - i) // 2
                target = nums[target_ind]

                left_sum = prefix[target_ind - 1] - (prefix[i - 1] if i > 0 else 0)
                right_sum = prefix[j] - (prefix[target_ind])

                operations_left = abs(((target_ind - i) * target - left_sum) if target_ind > 0 else 0)
                operations_right = abs(((j - target_ind) * target - right_sum) if target_ind < n else 0)

                if operations_left + operations_right <= k:
                    return True
                j += 1
                i += 1
                
            return False


        while min_score <= max_score:
            mid = (max_score + min_score) // 2

            if checker(mid):
                ans = mid
                min_score = mid + 1
            else:
                max_score = mid - 1
        return ans



--


===========================================================================================================


-- Find number of coins to place in tree nodes



-- https://leetcode.com/problems/find-number-of-coins-to-place-in-tree-nodes/
--


--
from typing import List

NO_VALUE = int(1e9)

class Solution:
    def __init__(self):
        self.n = 0
        self.g = []
        self.cost = []
        self.val = []
        self.coins = []

    def CalculateCoins(self, src: int, par: int):
        child_val = [self.cost[src]]
        
        for i in self.g[src]:
            if i == par:
                continue

            self.CalculateCoins(i, src)
            for v in self.val[i]:
                child_val.append(v)
        
        child_val.sort()

        if len(child_val) < 3:
            self.coins[src] = 1
            self.val[src] = child_val
        else:
            n = len(child_val)
            max_product = float('-inf')
            max_product = max(max_product, child_val[0] * child_val[1] * child_val[n-1])
            max_product = max(max_product, child_val[n-1] * child_val[n-2] * child_val[n-3])

            self.coins[src] = 0 if max_product < 0 else max_product

            if len(child_val) < 6:
                self.val[src] = child_val
            else:
                self.val[src] = [child_val[0], child_val[1], child_val[n-3], child_val[n-2], child_val[n-1]]

    def placedCoins(self, edges: List[List[int]], _cost: List[int]) -> List[int]:
        self.n = len(_cost)
        self.g = [[] for _ in range(self.n)]
        self.cost = _cost
        self.val = [[] for _ in range(self.n)]
        self.coins = [0] * self.n

        for e in edges:
            self.g[e[0]].append(e[1])
            self.g[e[1]].append(e[0])

        self.CalculateCoins(0, -1)
        return self.coins

--


================================================================================================


-- Minimum cost to convert string 1


-- https://leetcode.com/problems/minimum-cost-to-convert-string-i/
--


--
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        from collections import defaultdict
        import math

        # Step 1: Initialize cost matrix
        INF = math.inf
        minCost = [[INF] * 26 for _ in range(26)]

        for i in range(26):
            minCost[i][i] = 0

        for o, c, z in zip(original, changed, cost):
            from_char = ord(o) - ord('a')
            to_char = ord(c) - ord('a')
            minCost[from_char][to_char] = min(minCost[from_char][to_char], z)

        # Step 2: Floyd-Warshall to get all-pairs shortest transformation cost
        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if minCost[i][k] != INF and minCost[k][j] != INF:
                        minCost[i][j] = min(minCost[i][j], minCost[i][k] + minCost[k][j])

        # Step 3: Calculate total cost to transform source to target
        total_cost = 0
        n = len(source)
        for i in range(n):
            s = ord(source[i]) - ord('a')
            t = ord(target[i]) - ord('a')
            if minCost[s][t] == INF:
                return -1
            total_cost += minCost[s][t]

        return total_cost
        
--


=================================================================================================


-- Minimum cost to convert to string 2



--
-- https://leetcode.com/problems/minimum-cost-to-convert-string-ii/


--
class Solution(object):
    def minimumCost(self, source, target, original, changed, cost):
        index = {}
        for o in original:
            if o not in index:
                index[o] = len(index)
        for c in changed:
            if c not in index:
                index[c] = len(index)

        n = len(index)
        dis = [[float('inf')] * n for _ in range(n)]

        for i in range(len(cost)):
            dis[index[original[i]]][index[changed[i]]] = min(dis[index[original[i]]][index[changed[i]]], cost[i])

        for k in range(n):
            for i in range(n):
                if dis[i][k] < float('inf'):
                    for j in range(n):
                        if dis[k][j] < float('inf'):
                            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])

        substr_lengths = set(len(o) for o in original)

        print(index)
        print(dis)

        dp = [float('inf')] * (len(target) + 1)
        dp[0] = 0

        for i in range(len(target)):
            if dp[i] == float('inf'):
                continue

            if target[i] == source[i]:
                dp[i + 1] = min(dp[i + 1], dp[i])

            for t in substr_lengths:
                if i + t >= len(dp):
                    continue

                sub_source = source[i:i + t]
                sub_target = target[i:i + t]

                c1 = index[sub_source] if sub_source in index else -1
                c2 = index[sub_target] if sub_target in index else -1

                if c1 >= 0 and c2 >= 0 and dis[c1][c2] < float('inf'):
                    dp[i + t] = min(dp[i + t], dp[i] + dis[c1][c2])

        return dp[-1] if dp[-1] != float('inf') else -1
        
--


================================================================================================



-- Find longest specialsubsring that occurs thrice 1 & 2


-- https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/
--


--
class Solution:
    def maximumLength1(self, s: str) -> int:
        from collections import defaultdict
        # brute force

        # get all substrings
        # find the special substrings
        # find the longest substring
        m = defaultdict(int)
        n = len(s)
        for i in range(n):
            curr = ""
            for j in range(i, n): 
                if not curr or curr[-1] == s[j]:
                    curr += s[j]
                    m[(s[j], len(curr))] += 1
                else:
                    break

        # iterate through the map and get the substring with longest one with frequency more than 3
        result = 0
        for key in m:
            string = key[1]

            if m[key] >= 3 and string > result:
                result = string        
        return result if result else -1


    def maximumLength(self, s: str) -> int:

        # Another approach using matrix
        # x axis - 0 - 25 representing letters
        # 0 to n representing the len if the characters that can be repeated
        
        # for the cumulative sum go from right to left and as soon the freq hits more than 3 return that len
        n = len(s)
        mat = [[0] * (n + 1) for _ in range(26)]
        prev_char = ""
        lenght = 0

        for i in range(n):
            if prev_char == s[i]:
                length += 1
            else:
                length = 1
                prev_char = s[i]
            mat[ord(s[i]) - ord('a')][length] += 1

        result = 0
        for i in range(26):
            c_sum = 0
            for j in range(n, 0, -1):
                c_sum += mat[i][j]

                if c_sum >= 3:
                    result = max(result, j)
        
        return result if result else -1



                    


--


===============================================================================================

-- Palindrome rearrangement queries (Imp)


-- https://leetcode.com/problems/palindrome-rearrangement-queries/description/
--

--
class Solution:
    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        
        n = len(s) // 2
        s1, s2 = s[0:n], s[n:2*n][::-1]
        
        pos_len = [0] * n
        pre = 0
        for j in range(n+1):
            if j == n or s1[j] != s2[j]:
                for i in range(pre, j):
                    pos_len[i] = j-i
                pre = j+1
        
        def get_psum(s):
            psum = [None] * n
            cur_cnt = [0] * 26
            for i in range(n):
                cur_cnt[ord(s[i]) - ord('a')] += 1
                psum[i] = cur_cnt.copy()
            return psum
        
        psum1 = get_psum(s1)
        psum2 = get_psum(s2)
        
        def p(a, b):
            # if s1[a..b] == s2[a..b]
            if a > b:
                return True
            return pos_len[a] >= b-a+1
        
        def f(a, b, ps1, c, d, ps2):
            # compare letter count of s1[a..b] and s2[c..d]. return >=0 if former covers latter.
            # return 0 if all letters have the same count; 1 if counts in ps1 all > ps2; -1 if s1[a..b] does not cover s2[c..d]
            all_eq = 1
            for i in range(26):
                c1 = ps1[b][i] - (0 if a == 0 else ps1[a-1][i])
                c2 = ps2[d][i] - (0 if c == 0 else ps2[c-1][i])
                if c1 < c2:
                    return -1
                if c1 > c2:
                    all_eq = 0
            return 0 if all_eq else 1
        
        res = []
        for a, b, c, d in queries:
            c, d = 2*n-1-d, 2*n-c-1
            if a > c:
                a, b, c, d = c, d, a, b
                ps1, ps2 = psum2, psum1
            else:
                ps1, ps2 = psum1, psum2
                
            if c > b:
                res.append( p(0, a-1) and p(b+1, c-1) and p(d+1, n-1) 
                           and f(a, b, ps1, a, b, ps2) == 0 
                           and f(c, d, ps1, c, d, ps2) == 0 )
            elif d > b:
                res.append( p(0, a-1) and p(d+1, n-1) 
                           and (a > c-1 or f(a, b, ps1, a, c-1, ps2) > 0 )
                           and (b+1 > d or f(c, d, ps2, b+1, d, ps1) > 0 )
                           and f(a, d, ps1, a, d, ps2) == 0 )
            else:
                res.append( p(0, a-1) and p(b+1, n-1) 
                           and (a > c-1 or f(a, b, ps1, a, c-1, ps2) > 0)
                           and (d+1 > b or f(a, b, ps1, d+1, b, ps2) > 0)
                           and f(a, b, ps1, a, b, ps2) == 0 )

        
        return res
--


================================================================================================


-- Minimum cost to make array equal


-- https://leetcode.com/problems/minimum-cost-to-make-array-equal/
--


--
class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        n = len(nums)
        def cost_checker(val):
            csum = 0
            for i in range(n):
                csum += abs(nums[i] - val) * cost[i]
            return csum

        right = max(nums)
        left = min(nums)

        res = float("inf")

        while left <= right:
            mid = (left + right) // 2

            a = cost_checker(mid)
            b = cost_checker(mid + 1)

            res = min(a, b)

            if b > a:
                right = mid - 1
            else:
                left = mid + 1
        return res if res != float('inf') else 0
--


===============================================================================================

-- Minimum number of operations


-- https://leetcode.com/problems/minimum-number-of-operations-to-make-arrays-similar/
--


--
class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        nums.sort()
        target.sort()

        on, ot, en, et = [], [] , [], []
        n = len(nums)

        for i in range(n):
            if nums[i] % 2 == 0:
                en.append(nums[i])
            else:
                on.append(nums[i])

            if target[i] % 2 == 0:
                et.append(target[i])
            else:
                ot.append(target[i])
        
        c = 0
        for i in range(len(en)):
            c += (abs(en[i] - et[i])) // 2
        
        for i in range(len(on)):
            c += (abs(on[i] - ot[i])) // 2

        return c // 2
--


=================================================================================================


-- Next greater element 4 (Imp)


-- https://leetcode.com/problems/next-greater-element-iv/
--


--
class Solution:
    def secondGreaterElement(self, A: List[int]) -> List[int]:
        res, s1, s2 = [-1] * len(A), [], []
        for i,a in enumerate(A):
            while s2 and A[s2[-1]] < a:
                res[s2.pop()] = a
            tmp = []
            while s1 and A[s1[-1]] < a:
                tmp.append(s1.pop())
            s2 += tmp[::-1]
            s1.append(i)
        return res
--


=================================================================================================



-- Height of the binary tree after subtree removal queries  (Imp)


--
--


--
class Solution:
    def __init__(self):
        self.level = [0] * 1000001  # level of each node
        self.height = [0] * 100001  # height of each node
        self.levelMaxHt = [0] * 100001  # max height at each level
        self.levelSecondMaxHt = [0] * 100001  # second max height at each level

    def findHeight(self, root, l):
        if not root:
            return 0

        self.level[root.val] = l

        left_ht = self.findHeight(root.left, l + 1)
        right_ht = self.findHeight(root.right, l + 1)

        self.height[root.val] = max(left_ht, right_ht) + 1

        h = self.height[root.val]

        if self.levelMaxHt[l] < h:
            self.levelSecondMaxHt[l] = self.levelMaxHt[l]
            self.levelMaxHt[l] = h
        elif self.levelSecondMaxHt[l] < h:
            self.levelSecondMaxHt[l] = h

        return h

    def treeQueries(self, root, queries):
        self.findHeight(root, 0)

        print(self.level, self.height,self.levelSecondMaxHt, self.levelMaxHt)

        result = []
        for node in queries:
            L = self.level[node]
            H = self.height[node]

            if self.levelMaxHt[L] == H:
                max_other = self.levelSecondMaxHt[L]
            else:
                max_other = self.levelMaxHt[L]

            result.append(L + max_other - 1)

        return result

--

===================================================================================================


-- Minimum total distance Traveled


-- https://leetcode.com/problems/minimum-total-distance-traveled/
--


--
from functools import lru_cache
class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        n = len(factory)
        robot.sort()
        # factory.sort(key=lambda x: x[0])
        factory.sort()

        new_arr = [] # convert the factory limit into the new array
        # ex -> [[2, 2]] -> converted to [2, 2] meaning there are 2 factories at the same position making it much easier for computation 

        # using dp for take and skip policy for robot picking factories
        
        for i in range(n):
            limit = factory[i][1]
            pos = factory[i][0]
            new_arr += ([pos] * limit)
        
        dp = [[0] 

        @lru_cache(None)
        def fn(i, j):
            if i >= len(robot):
                return 0  # All robots are placed

            if j >= len(new_arr):
                return float('inf')  # No more factories to assign

            take = abs(robot[i] - new_arr[j]) + fn(i + 1, j + 1)
            skip = fn(i, j + 1)

            return min(take, skip)

        res = fn(0, 0)
        return res if res != float('inf') else -1


from typing import List

class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        robot.sort()
        factory.sort()  # sort by position

        # Flatten the factory list into new_arr with repeated positions based on their limits
        new_arr = []
        for pos, limit in factory:
            new_arr.extend([pos] * limit)

        m, n = len(robot), len(new_arr)

        # Initialize dp table with inf; dp[i][j] = min cost to assign first i robots to first j factories
        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 0  # base case: 0 robots, 0 cost

        # Fill dp table
        for i in range(m + 1):  # number of robots assigned
            for j in range(n):  # current factory index
                # Skip assigning this factory (carry forward previous min cost)
                dp[i][j + 1] = min(dp[i][j + 1], dp[i][j])

                # Take this factory if there's a robot to assign
                if i < m:
                    cost = abs(robot[i] - new_arr[j])
                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + cost)

        return min(dp[m]) if min(dp[m]) != float('inf') else -1


--


====================================================================================================


-- Maximum strong pair xor 2


--
-- https://leetcode.com/problems/maximum-strong-pair-xor-ii/


--
class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        t = XorTrie()
        nums.sort()
        j = 0
        res = 0
        for i in range(len(nums)):
            t.insert(nums[i])
            while nums[j] * 2 < nums[i]:
                t.remove(nums[j])
                j += 1
            res = max(res, t.max_xor(nums[i]))
        return res

        

class XorTrie:
    def __init__(self):
        self.p = [None, None]

    max_b = 1 << 19

    def insert(self, n):
        r = self
        b = XorTrie.max_b
        while b > 0:
            bit = (n & b) > 0
            if r.p[bit] is None:
                r.p[bit] = XorTrie()
            r = r.p[bit]
            b >>= 1

    def remove(self, n, b=None):
        if b is None:
            b = XorTrie.max_b
        if b == 0:
            return True
        bit = (n & b) > 0
        if self.p[bit] is not None and self.p[bit].remove(n, b >> 1):
            self.p[bit] = None
        return self.p[0] is None and self.p[1] is None

    def max_xor(self, n):
        res = 0
        r = self
        b = XorTrie.max_b
        while b > 0:
            bit = (n & b) > 0
            if r.p[not bit] is not None:
                res += b
                r = r.p[not bit]
            else:
                r = r.p[bit]
            b >>= 1
        return res

--


===================================================================================================


-- Find building where lice and bob can meet


--
-- https://leetcode.com/problems/find-building-where-alice-and-bob-can-meet/


--
from typing import List

class Solution:
    def binarySearch(self, height: int, st: List[tuple]) -> int:
        l, r = 0, len(st) - 1
        ans = -1
        while l <= r:
            mid = l + (r - l) // 2
            if st[mid][0] > height:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:
        st = []
        answer = [-1] * len(queries)
        newQueries = [[] for _ in range(len(heights))]

        for i, (a, b) in enumerate(queries):
            if a > b:
                a, b = b, a
            if heights[b] > heights[a] or a == b:
                answer[i] = b
            else:
                newQueries[b].append((heights[a], i))

        for i in range(len(heights) - 1, -1, -1):
            for h, idx in newQueries[i]:
                pos = self.binarySearch(h, st)
                if pos != -1:
                    answer[idx] = st[pos][1]
            while st and st[-1][0] <= heights[i]:
                st.pop()
            st.append((heights[i], i))

        return answer

--


=================================================================================================


