
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================


-- Accounts merge


-- https://leetcode.com/problems/accounts-merge/submissions/1400878057/
--

--
from collections import defaultdict

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        g = defaultdict(list)

        for i, account in enumerate(accounts):
            for j in range(1, len(account)):

                email = account[j]
                g[email].append(i) # storing the index for the email 


        vis = [False] * len(accounts)


        def dfs(index, emails):
            if vis[index] == True:
                return
            vis[index] = True
            
            for j in range(1, len(accounts[index])):
                email = accounts[index][j]
                emails.add(email)
                for neighbor in g[email]:
                    if not vis[neighbor]:
                        dfs(neighbor, emails)



        res = []
        for i, account in enumerate(accounts):
            if not vis[i]:
                name = account[0]
                emails = set()
                dfs(i, emails)
                res.append([name] + sorted(emails))
        
        return res

        
--


===============================================================================================================


--  Remove comments


--
--


--
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:

        res = []
        n = len(source)
        block_comment = False

        new_line = ""
        
        for char_arr in source:
            i = 0

            if not block_comment:
                new_line = ""

            while i < len(char_arr):

                if not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '*':
                    block_comment = True
                    i = i + 2
                
                elif block_comment and i + 1 < len(char_arr) and char_arr[i] == '*' and char_arr[i + 1] == '/':
                    block_comment = False
                    i = i + 2

                elif not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '/':
                    break
                
                elif not block_comment:
                    new_line += char_arr[i]
                    i = i + 1

                # if the block_comment is True
                else:
                    i += 1
                
            if not block_comment and new_line:
                res.append(new_line)
            
        
        return res
        return "".join(res)            
--


===================================================================================================================

-- Split Linked list in Parts


--
-- https://leetcode.com/problems/split-linked-list-in-parts/


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        total_nodes = 0
        current = head
        while current:
            total_nodes += 1
            current = current.next
        
        # Step 2: Calculate the base size of each part and the extra nodes
        base_size = total_nodes // k
        extra_nodes = total_nodes % k
        
        # Step 3: Split the list
        parts = []
        current = head
        for i in range(k):
            part_size = base_size + (1 if i < extra_nodes else 0)  # Calculate the size of the current part
            if part_size == 0:
                parts.append(None)  # If the part size is 0, append None
            else:
                part_head = current
                for j in range(part_size - 1):
                    if current:
                        current = current.next
                next_part = None
                if current:
                    next_part = current.next
                    current.next = None  # Break the list

                parts.append(part_head) # important code which is used to get the list in linked lists to array
                current = next_part  # Move to the next part
        
        return parts
--


==============================================================================================================================


-- My Calender I


--
-- https://leetcode.com/problems/my-calendar-i/


--
class MyCalendar:
    def __init__(self):
        # Initialize an empty list to store the events
        self.events = []

    def book(self, start: int, end: int) -> bool:
        # Iterate over the list of events
        for event_start, event_end in self.events:
            # Check if the new event overlaps with an existing event
            if not (end <= event_start or start >= event_end):
                # If there is an overlap, return False (booking fails)
                return False
        # If no overlap is found, add the event to the calendar
        self.events.append((start, end))
        # Return True indicating successful booking
        return True

--


===================================================================================================================


-- NUMBER OF BURGERS with no waste of ingrediants


-- https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/solutions/4840518/easy-beginner-friendly-solution-in-cpp-0ms-beats-100-0-1-solution/
--


--class Solution:
    def numOfBurgers(self, to: int, ch: int) -> List[int]:

        if ch > to:
            return []
        else:
            if (to > ch * 4) and (to < ch * 2):
                return []
            else:
                if to % 2 == 0:
                    x = to - (2 * ch)
                    y = x // 2
                    z = ch - y
                    return [y, z]
                
                else:
                    return []
--


=======================================================================================================================


-- Count the servers that communicate


-- https://leetcode.com/problems/count-servers-that-communicate/
--


--
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        row = [0] * m
        col = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row[i] += 1
                    col[j] += 1
        
        res = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] and (row[i] > 1 or col[j] > 1):
                    res += 1
        
        return res
        
--

==============================================================================================================================


-- Search Suggestions


-- https://leetcode.com/problems/search-suggestions-system/
--

--class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()

        prefix = ""
        res = []

        for i in searchWord:
            prefix += i
            suggestions = []

            for j in range(len(products)):
                if products[j].startswith(prefix):
                    suggestions.append(products[j])
                    if len(suggestions) == 3:
                        break
            
            res.append(suggestions)
        
        return res
--

====================================================================================================================


-- Count squares submatrices with all ones


-- https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/
--

-
class Solution:
    def countSquares(self, mp: List[List[int]]) -> int:
        m = len(mp)
        n = len(mp[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        total_squares = 0

        for i in range(m):
            for j in range(n):

                if mp[i][j] == 1:
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                total_squares += dp[i][j]
        
        return total_squares
-


=============================================================================================================================


-- Group the people given the group size


-- https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
--


--
from collections import defaultdict

class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        m = defaultdict(list)

        for i, num in enumerate(gs):
            m[num].append(i)

        res = []
        for group_size, people in m.items():
            for i in range(0, len(people), group_size):
                res.append(people[i: i + group_size])

        return res

--


==========================================================================================================================

-- Find the smallest divisor given a threshold


-- https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
--

--
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left = 1  # Smallest divisor should start from 1
        right = max(nums)  # Largest possible divisor can be the maximum element in the array

        def check(num):
            csum = 0
            for i in nums:
                csum += ceil(i / num)  # Use ceil to simulate rounding up the division result
            return csum

        ans = float("inf")
        while left <= right:
            mid = (left + right) // 2

            if check(mid) > threshold:
                left = mid + 1
            else:
                ans = min(ans, mid)
                right = mid - 1
        
        return ans
--


============================================================================================================================

-- Remove covered intervals


-- https://leetcode.com/problems/remove-covered-intervals/
--


--
class Solution:
    def removeCoveredIntervals(self, inter: List[List[int]]) -> int:
        cnt = 0
        inter.sort(key=lambda x:(x[0], -x[1]))

        ending_time = 0

        for i in range(len(inter)):
            if ending_time < inter[i][1]:
                cnt += 1
                ending_time = inter[i][1]

        return cnt
--


==========================================================================================================================


-- Sequential digits


-- https://leetcode.com/problems/sequential-digits/
--



--
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:

        num = "123456789"
        res = []

        for length in range(2, 10):
            for start in range(0, 10 - length): # the range is from 0 to 10 - length because the we will be adding length
                number = int(num[start: start + length])

                if low <= number <= high:
                    res.append(number)
        return sorted(res)
--

=======================================================================================================================


-- Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-- https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/1404694299/
--


--
from typing import List

class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize prefix sum matrix
        prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        # Build prefix sum matrix
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # This function gets the sum of the square from (i, j) to (i + k - 1, j + k - 1)
        def get_sum(i, j, k):
            return prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]

        left = 0
        right = min(m, n)
        ans = 0

        # Binary search for the maximum possible square length
        while left <= right:
            mid = (left + right) // 2
            found = False

            # Check for any valid square of side length 'mid'
            for i in range(m - mid + 1):
                for j in range(n - mid + 1):
                    if get_sum(i, j, mid) <= threshold:
                        found = True
                        break
                if found:
                    break

            if found:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1

        return ans

--

=============================================================================================================================

-- Divide Array in Sets of K consecutive numbers

  
-- https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/submissions/1404733179/
--


--
from collections import defaultdict

class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        nums.sort()
        m = defaultdict(int)

        for i in nums:
            m[i] += 1

        for num in nums:
            if m[num] > 0:
                for j in range(num, num + k):
                    if m[j] == 0:
                        return False
                    m[j] -= 1

        return True
--


=================================================================================================================================

-- Maximum Number of Occurances of a substring


-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/
-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/1404853330/


--
from collections import defaultdict
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        string_count = defaultdict(int)
        ans = 0
        for i in range(len(s) - minSize + 1):
            string = s[i : i + minSize]
            unique_string = set(string)
            
            # since the length is used you can use length to get the maximum unique letters
            if len(unique_string) <= maxLetters:
                string_count[string] += 1
                ans = max(ans, string_count[string])

        return ans
--



===============================================================================================================================

-- Sum of Mutated Array Closest to Target


-
- https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/description/

--
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:        
        
        arr.sort()

        prefix_sum = [0]
        for num in arr:
            prefix_sum.append(prefix_sum[-1] + num)

        def helper(arr, value):
            left, right = 0, len(arr) - 1

            while left <= right:
                mid = (left + right)// 2

                if arr[mid] > value:
                    right = mid - 1
                else:
                    left = mid + 1
                
            return left


        left = 0
        right = max(arr)
        closest_sum_diff = float('inf')
        best_value = right

        while left <= right:
            mid = (left + right) // 2

            index = helper(arr, mid)

            # get the total sum after replacing the number with the mid
            curr_sum = prefix_sum[index] + (len(arr) - index) * mid
            diff = abs(curr_sum - target)

            if diff < closest_sum_diff or (diff == closest_sum_diff and mid < best_value):
                best_value = mid
                closest_sum_diff = diff
            
            if curr_sum < target:
                left = mid + 1
            else:
                right = mid - 1

        
        return best_value
--

===============================================================================================================================

-- Deepest leaves sum


-- https://leetcode.com/problems/deepest-leaves-sum/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:

        # returning the array with depth and the node
        def dfs(node, depth):
            if not node:
                return (0, 0)

            if not node.left and not node.right:
                return (node.val, depth)
            
            left = dfs(node.left, depth + 1)
            right = dfs(node.right, depth + 1)

            if left[1] > right[1]:
                return left
            elif right[1] > left[1]:
                return right
            else:
                return (left[0] + right[0], left[1])
        
        return dfs(root, 0)[0]
--


=============================================================================================================================


-- all elements in two binary search trees


-- https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def dfs(node, arr):
            if not node:
                return None

            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)

            return arr
        
        arr1, arr2 = [], []
        arr1 = dfs(root1, arr1) if root1 else []
        arr2 = dfs(root2, arr2) if root2 else []

        i = 0
        j = 0
        ans = []
        n = len(arr1)
        m = len(arr2)

        while i < n and j < m:
            if arr1[i] <= arr2[j]:
                ans.append(arr1[i])
                i += 1
            else:
                ans.append(arr2[j])
                j += 1
        
        ans.extend(arr1[i:])
        ans.extend(arr2[j:])
        
        return ans
        
            
        
--


==========================================================================================================================

-- Jump game 3


-- https://leetcode.com/problems/jump-game-iii/submissions/1405149002/
--


--
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        # Using queue and BFS to get the solution since you can jump to i - arr[i] or i + arr[i]


        q = []
        q.append(start)
        vis = [0] * len(arr)
        n = len(arr)

        while q:

            index = q.pop(0)

            vis[index] = 1
 
            if arr[index] == 0:
                return True

            left = index - arr[index]

            if left >= 0 and not vis[left]:
                q.append(left)
            
            right = index + arr[index]
            if right < n and not vis[right]:
                q.append(right)
        
        return False
--


==============================================================================================================================


-- Xor queries of a subarrya


-- https://leetcode.com/problems/xor-queries-of-a-subarray/
--

--
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        prefix = [0] * (len(arr) + 1)

        for i in range(1, len(arr) + 1):
            prefix[i] = prefix[i - 1] ^ arr[i - 1]

        result = []
        for left, right in queries:
            result.append(prefix[left] ^ prefix[right + 1])
        
        return result
        
--


============================================================================================================================

-- Subarray with given sum


-- https://www.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1?page=1&sortBy=submissions
--


-
class Solution:
    def subArraySum(self,arr, n, s): 
       #Write your code 
       
        left = 0
       
        for right in range(n):
           
            cur_sum += arr[right]
           
            if cur_sum == s:
                return [left + 1, right + 1]
           
            while cur_sum > s and left <= right:
                cur_sum -= arr[left]
                left += 1
            
            if cur_sum == s and s != 0:
                return [left + 1, right + 1]
        
        return [-1]
-


======================================================================================================================

-- Get watched by your friends


-- https://leetcode.com/problems/get-watched-videos-by-your-friends/
--

--
class Solution:
    def watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, level: int) -> List[str]:

        q = []

        # node and the depth
        q.append((id, 0))
        vis = [0] * len(w)
        vis[id] = 1
        res = []

        while q:
            node, cur_level = q.pop(0)

            if cur_level == level:
                res.append(node)
            elif cur_level < level:
                for i in f[node]:
                    if not vis[i]:
                        vis[i] = 1
                        q.append((i, cur_level + 1))
        
        m = {}
        
        # Count the frequency of videos watched by friends at the target level
        for index in res:
            for v in w[index]:
                if v in m:
                    m[v] += 1
                else:
                    m[v] = 1

        return sorted(m.keys(), key=lambda x: (m[x], x))

            

        
--

========================================================================================================================


-- Matrix block sum


-- https://leetcode.com/problems/matrix-block-sum/
--


--
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        # Step 1: Build prefix sum array with extra row and column
        prefix = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # Step 2: Calculate the block sum using the prefix sum
        def get_sum(r1, c1, r2, c2):
            r1, c1 = max(0, r1), max(0, c1)  # handle boundaries
            r2, c2 = min(m, r2), min(n, c2)  # handle boundaries
            return prefix[r2][c2] - prefix[r1][c2] - prefix[r2][c1] + prefix[r1][c1]

        result = [[0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                r1, c1 = i - k, j - k
                r2, c2 = i + k + 1, j + k + 1
                result[i][j] = get_sum(r1, c1, r2, c2)

        return result

--

============================================================================================================================


-- Sum of nodes with even values grandparent


-- https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
--


--
    def sumEvenGrandparent(self, root: TreeNode) -> int:

        def dfs(node, par, grand_par):
            if not node:
                return 0

            sum_of_nodes = 0

            if grand_par and grand_par % 2 == 0:
                sum_of_nodes += node.val
            
            sum_of_nodes += dfs(node.left, node.val, par)
            sum_of_nodes += dfs(node.right, node.val, par)

            return sum_of_nodes
        
        return dfs(root, None, None)
--

===========================================================================================================================


-- Minimum flips to make a or b equal to c


-- https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/submissions/1405746911/
--


--
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        flips = 0

        for i in range(32):
            bit_a = (a >> i) & 1
            bit_b = (b >> i) & 1
            bit_c = (c >> i) & 1

            if bit_c == 1:
                if bit_a == 0 and bit_b == 0:
                    flips += 1 
            else:
                if bit_a == 1:
                    flips += 1
                if bit_b == 1:
                    flips += 1

        return flips

--


========================================================================================================================

-- Print words vertically


-- https://leetcode.com/problems/print-words-vertically/
--

--
class Solution:
    def printVertically(self, s: str) -> List[str]:
        split_arr = s.split()
        max_str_len = max(len(word) for word in split_arr)


        res = []

        i = 0
        while i < max_str_len:
            string_len = ""

            for word in split_arr:
                if i < len(word):
                    string_len += word[i]
                else:
                    string_len += " "
            res.append(string_len.rstrip())
            i += 1

        return res     
--


============================================================================================================================

-- Delete leaves with a given value


-- https://leetcode.com/problems/delete-leaves-with-a-given-value/
--


--
class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        temp = root

        def dfs(node, target):

            if not node:
                return None

            node.left = dfs(node.left, target)
            node.right = dfs(node.right, target)

            if not node.left and not node.right and node.val == target:
                return None
            return node
        
        return dfs(root, target)
--

===========================================================================================================================

-- break a Palindrome (Important)


-- https://leetcode.com/problems/break-a-palindrome/description/
--


--
class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n <= 1:
            return ""

        # Traverse the string untill the half length 
        # if the character is "a" is not found at that position, replace and return
        # else if all the characters are "a" then replace the last element with next character "b"

        res = list(palindrome)

        for i in range(len(res) // 2):
            if palindrome[i] != 'a':
                res[i] = 'a'
                return "".join(res)
        
        res[-1] = 'b'
        return "".join(res)
--


=====================================================================================================================


-- Sort the matrix diagonally


-- https://leetcode.com/problems/sort-the-matrix-diagonally/
--


--
from collections import defaultdict

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:

        diagonals = defaultdict(list)
        
        m, n = len(mat), len(mat[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i - j has the same slope for diagonal elements
        for i in range(m):
            for j in range(n):
                heapq.heappush(diagonals[i - j], mat[i][j])
        
        # Step 2: Replace matrix elements with the sorted diagonal elements from the heap
        for i in range(m):
            for j in range(n):
                mat[i][j] = heapq.heappop(diagonals[i - j])
        
        return mat
--


===============================================================================================================================


-- Filter restaurents by vegan friendly price and distance


-- https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/submissions/1405999741/
--


--
class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        n = len(restaurants)
        res = []
        for i in range(n):
            if (veganFriendly == 0 or restaurants[i][2] == veganFriendly) and restaurants[i][3] <= maxPrice and restaurants[i][4] <= maxDistance:
                res.append((restaurants[i][1], restaurants[i][0]))

        res.sort(reverse=True,key=lambda x:(x[0], x[1]))

        return [v for u, v in res]
--


===========================================================================================================================

-- Reduce array size to the half


-- https://leetcode.com/problems/reduce-array-size-to-the-half/
--


--
from heapq import heappop, heappush
from collections import defaultdict
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        m = defaultdict(int)

        n = len(arr)

        for i in range(n):
            m[arr[i]] += 1
        
        # m now has the freqeuncy array
        m = sorted(m.values(), reverse=True)
        cnt = 0
        removed_el = 0

        # iterate through the frequency array reduce that frequency amount and increment the count
        for i in m:
            removed_el += i
            cnt += 1

            if removed_el >= n // 2:
                break

        return cnt
            
--


==================================================================================================================================

-- Maximum prodcut of splitted binary tree


-- https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7  # To return the result modulo 10^9 + 7
        total_sum = 0  # To store the total sum of the tree
        max_product = 0  # To store the maximum product

        # First, get the total sum of the entire tree
        def get_total_sum(node):
            if not node:
                return 0
            return node.val + get_total_sum(node.left) + get_total_sum(node.right)

        # Second, calculate the max product by finding each subtree's sum
        def get_subtree_sum(node):
            nonlocal max_product
            if not node:
                return 0

            # Get the sum of the current subtree
            left_sum = get_subtree_sum(node.left)
            right_sum = get_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # Calculate product of splitting the tree at this subtree
            max_product = max(max_product, (total_sum - subtree_sum) * subtree_sum)

            return subtree_sum

        # Step 1: Calculate the total sum of the tree
        total_sum = get_total_sum(root)

        # Step 2: Traverse again to calculate the max product
        get_subtree_sum(root)

        # Return the maximum product modulo 10^9 + 7
        return max_product % MOD
--


===================================================================================================================================


-- Number of subarrys of size k and average greater than or equal to threshold


-- https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
--


--
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        n = len(arr)
        left = 0
        right = 0
        cur_sum = 0
        cnt = 0

        while right < n:
            cur_sum += arr[right]

            if right - left + 1 < k:
                right += 1
                continue
            else:
                if (cur_sum // k)  >= threshold:
                    cnt += 1
                
                cur_sum -= arr[left]
                
                right += 1
                left += 1 
        
        return cnt
            
        
--

===========================================================================================================================

-- Angle between hands of a clock


-- https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/submissions/1406105855/
--


--
from collections import defaultdict

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        map_s = defaultdict(int)
        map_t = defaultdict(int)
        n = len(s)
        m = len(t)
        i = 0
        j = 0

        while i < n or j < m:
            if i < n:
                map_s[s[i]] += 1
            if j < n:
                map_t[t[i]] += 1
            i += 1
            j += 1
        

        cnt = 0

        for char in map_s:
            if map_s[char] > map_t[char]:
                cnt += map_s[char] - map_t[char]

        return cnt       

        
--


====================================================================================================================


-- Tweet Counts per Frequency

-- https://leetcode.com/problems/tweet-counts-per-frequency/description/


--
--

============================================================================================================================


-- Maximum number of events that can be attended


-- https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
--


--
from heapq import heappush, heappop

class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        
        events.sort()
        n = len(events)

        current_day = 0
        event_count = 0
        i = 0

        heap = []

        while i < n or heap:
            
            # is not heap move the next available date of start date
            if not heap:
                current_day = events[i][0]
            
            # add all the events which is on the current day
            while i < n and events[i][0] <= current_day:
                heappush(heap, events[i][1])
                i += 1
            
            # Remove events from the heap that have already ended
            while heap and heap[0] < current_day:
                heappop(heap)

            if heap:
                heappop(heap)
                event_count += 1
        
            current_day += 1

        return event_count

            

        
--


=============================================================================================================================


-- Number of substrings containing all three characters


--
--

--
from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        char_count = defaultdict(int)
        n = len(s)

        i = 0
        j = 0
        k = 3
        cnt = 0
        
        while j < n:
            char_count[s[j]] += 1

            while len(char_count) == 3:

                cnt += len(s) - j
                char_count[s[i]] -= 1

                if char_count[s[i]] == 0:
                    del char_count[s[i]]
                i += 1
            j += 1
        
        return cnt

--


==============================================================================================================================

-- Validate binary tree nodes

-- https://leetcode.com/problems/validate-binary-tree-nodes/
--


--
class Solution:
    def validateBinaryTreeNodes(self, n: int, left: List[int], right: List[int]) -> bool:

        indegree = [0] * n

        i = 0

        while i < n:
            if left[i] != -1:
                indegree[left[i]] += 1
            if right[i] != -1:
                indegree[right[i]] += 1

            i += 1

        # root count should be equal to 1 if not return False
        root_count = 0
        root = -1
        for i in range(n):
            if indegree[i] == 0:
                root_count += 1
                root = i
        
        # If there's not exactly one root, it's not a valid binary tree
        if root_count != 1:
            return False
        
        vis = [0] * n
        cycle = True
        def dfs(node, vis):
            nonlocal cycle
            if node == -1:
                return

            if vis[node]: # there is a cycle in the binary tree
                cycle = False
                return 

            vis[node] = 1

            dfs(left[node], vis)
            dfs(right[node], vis)

        # dfs to check all the nodes to be connected or not
        dfs(root, vis)
        return all(vis) and cycle
    
        
--


==========================================================================================================================

-- Closest divisers 


-- https://leetcode.com/problems/closest-divisors/submissions/1407425844/
--



--
import math
class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        
        def find_closest_product(n):
            for i in range(int(math.sqrt(n)), 0, -1):
                if n % i == 0:
                    return [i, n // i]

        num1_divisor = find_closest_product(num + 1)
        num2_divisor = find_closest_product(num + 2)

        if abs(num1_divisor[0] - num1_divisor[1]) > abs(num2_divisor[0] - num2_divisor[1]):
            return num2_divisor
        else:
            return num1_divisor
        
--


====================================================================================================================================


-- Rank team by votes  (Imp)


-- https://leetcode.com/problems/rank-teams-by-votes/submissions/1407807178/
--


--
class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        
        teams = len(votes[0])
        d = {}

        for vote in votes:
            for i, char in enumerate(vote):
                if char not in d:
                    d[char] = [0] * len(vote)
                d[char][i] += 1

        voted_name = sorted(d.keys())
        print(voted_name, d)

        return "".join(sorted(voted_name, key=lambda x:d[x], reverse=True))
--


================================================================================================================================

-- Linked list in a binary tree


-- https://leetcode.com/problems/linked-list-in-binary-tree/
--


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        def dfs(listnode, treenode):
            if not listnode:  # If we've reached the end of the list, it's a match
                return True
            if not treenode:  # If the tree node is None, no match
                return False
            if listnode.val != treenode.val:  # If values don't match, return False
                return False
            # Recursively check both left and right subtrees
            return dfs(listnode.next, treenode.left) or dfs(listnode.next, treenode.right)


        if not root:
            return False
        
        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

--


==================================================================================================================


-- Find the longest substring containing vowels in even counts (Imp)


-- https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/
--


--
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # Map vowels to their bit positions
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        
        # Bitmask to track the parity of vowel counts
        bitmask = 0
        
        # Dictionary to store the first occurrence of each bitmask
        position_map = {0: -1}
        
        # Variable to store the maximum length of the valid substring
        max_len = 0
        
        for i, char in enumerate(s):
            # If the character is a vowel, flip the corresponding bit
            if char in vowels:
                bitmask ^= vowels[char]
            
            # If the current bitmask has been seen before
            if bitmask in position_map:
                # Update max_len with the distance between current index and previous occurrence of the same bitmask
                max_len = max(max_len, i - position_map[bitmask])
            else:
                # Otherwise, store the first occurrence of this bitmask
                position_map[bitmask] = i
        
        return max_len

--


========================================================================================================================

-- Longest zig zag path in a binary tree


-- https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
--


--
class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def traverse(node, cnt, prev):
            nonlocal ans
            if not node:
                ans = max(ans, cnt)
                return
            if prev:
                traverse(node.left, cnt+1, 0)
                traverse(node.right, 0, 1)
            else:
                traverse(node.right, cnt+1, 1)
                traverse(node.left, 0, 0)
        traverse(root.left, 0, 0)
        traverse(root.right, 0, 1)
        return ans
--


=====================================================================================================================

-- Number of times binary string is prefix aligned


-- https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/
--


--
class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        max_flipped = 0

        cnt = 0

        for i, flip in enumerate(flips, 1): # 1 at the end make it 1 index
            max_flipped = max(max_flipped, flip)

            if max_flipped == i:
                cnt += 1
        
        return cnt
--


=============================================================================================================================
-- Time needed to inform all employees


-- https://leetcode.com/problems/time-needed-to-inform-all-employees/
--


--
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        
        # construct the graph from the given node

        g = defaultdict(list)

        for i, emp in enumerate(manager):
            if emp != -1:
                g[emp].append(i)
    

        def dfs(node):
            if node not in g:
                return 0
            max_time = 0

            for i in g[node]:
                max_time = max(dfs(i), max_time)
            return max_time + informTime[node]



        return dfs(headID)
--


=================================================================================================================================

-- Balanace a binary tree


-- https://leetcode.com/problems/balance-a-binary-search-tree/submissions/1409087547/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        # for the bst given get eh elements in the binary search tree to an array through inorder traversal
        # get the root and the left part comes to the left side and right part comes to right side of the root

        arr = []

        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            arr.append(node.val)
            inorder(node.right)

        inorder(root)

        def dfs(left, right):
            if left > right:
                return None

            mid = (left + right) // 2

            node = TreeNode(arr[mid])

            node.left = dfs(left, mid - 1)
            node.right = dfs(mid + 1, right)

            return node

        
        return dfs(0, len(arr) - 1)

--


=============================================================================================================================



-- Cinema seat allocation


--
--


--
class Solution:
	def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
		seats = collections.defaultdict(set)

		for i,j in reservedSeats:
			if j in [2,3,4,5]:
				seats[i].add(0)
			if j in [4,5,6,7]:
				seats[i].add(1)
			if j in [6,7,8,9]:
				seats[i].add(2)
		res = 2*n
		for i in seats:
			if len(seats[i]) == 3:
				res -= 2
			else:
				res -= 1

		return res
--


==========================================================================================================================

-- Sort the integers by the power value


-- 
-- https://leetcode.com/problems/sort-integers-by-the-power-value/


--
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:

        def get_power_value(x):
            steps = 0

            while x > 1:
                if x % 2 == 0:
                    x = x // 2
                else:
                    x = x * 3 + 1
                steps += 1
            return steps

        res = []
        for i in range(lo, hi + 1):
            res.append((get_power_value(i), i))
        
        res.sort(key=lambda x:x[0])

        return res[k - 1][1]
            

        
--


==========================================================================================================================


-- Count the number of teams


-- https://leetcode.com/problems/count-number-of-teams/submissions/1409330184/
--


--
class Solution:
    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        if n < 3:
            return 0
        
        # Initialize arrays to count smaller and larger soldiers to the left and right
        left_smaller = [0] * n
        left_larger = [0] * n
        right_smaller = [0] * n
        right_larger = [0] * n
        
        # Calculate the left_smaller and left_larger for each soldier
        for i in range(n):
            for j in range(i):
                if rating[j] < rating[i]:
                    left_smaller[i] += 1
                elif rating[j] > rating[i]:
                    left_larger[i] += 1
        
        # Calculate the right_smaller and right_larger for each soldier
        for i in range(n):
            for j in range(i + 1, n):
                if rating[j] > rating[i]:
                    right_larger[i] += 1
                elif rating[j] < rating[i]:
                    right_smaller[i] += 1
        
        # Calculate the number of valid teams
        total_teams = 0
        for i in range(n):
            # Increasing triplets
            total_teams += left_smaller[i] * right_larger[i]
            # Decreasing triplets
            total_teams += left_larger[i] * right_smaller[i]
        
        return total_teams


        
--


==============================================================================================================================

-- Contruct k paindrome strings


-- https://leetcode.com/problems/construct-k-palindrome-strings/submissions/1409350280/
--


--
class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False

        n = len(s)
        m = {}
        
        for i in s:
            m[i] = m.get(i, 0) + 1
        
        # the frequency of the character is greter than k then it is impossible to form the palindromic string 
        # else it is true
        odd_count = sum(1 for count in m.values() if count % 2 != 0)

        return odd_count <= k 

        
--

=============================================================================================================================


-- Number of steps to reduce in binary representation to one



--
-- https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/


--
class Solution:
    def numSteps(self, s: str) -> int:
        steps = 0
        
        while s != "1":
            if s[-1] == "0":
                s = s[:-1]
            else:
                # convert the string to decimal increment and then convert back to binary eg "0b1110"
                s = bin(int(s, 2) + 1)[2:]
            steps += 1

        return steps
        
--

===============================================================================================================================


-- Longest happy string


-- https://leetcode.com/problems/longest-happy-string/submissions/1409397836/
--


--
from collections import Counter

class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        m = Counter({"a": a, "b": b, "c": c})
        res = ["#"]

        while True:
            (a1, count1), (a2, count2) = m.most_common(2)

            if a1 == res[-1] == res[-2]:
                a1 = a2 # if 2 char is already present in the response array just use the second character

            if not m[a1]:
                break
            res.append(a1)
            m[a1] -= 1
            
        
        return "".join(res[1:])
--


========================================================================================================================

-- Queries on a permutaion with key (Imp)



-- https://leetcode.com/problems/queries-on-a-permutation-with-key/
--


--
class Solution: 
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        result = []
        
        m = [x for x in range(1, m + 1)]
        
        for x in queries:
            result.append(m.index(x))  # get the index of the q
            m.remove(x) # remove the element from that index
            m.insert(0, x) # inser the element at the start
        
        return result
--


=============================================================================================================================


-- Html entity parser


-- https://leetcode.com/problems/html-entity-parser/
--


--
class Solution:
    def entityParser(self, text: str) -> str:
        m = {
            '&quot;': '"',
            '&apos;': '\'',
            '&amp;': '&',
            '&gt;': '>',
            '&lt;': '<',
            '&frasl;': '/'
        }

        # minlen = 6, maxlen = 4


        def checker(start):
            # Try to find the longest possible entity from the current position
            for length in range(4, 8):  # Entities have lengths between 4 and 6
                candidate = text[start:start + length]
                if candidate in m:
                    return m[candidate], length  # Return the entity replacement and its length
            return False, 1


        n = len(text)
        i = 0
        res = ""
        while i < n:

            if text[i] != "&":
                res += text[i]
                i += 1
            else:
                found, length = checker(i)
                if found:
                    res += found
                    i += length
                else:
                    res += text[i]
                    i += 1
        return res


        
--

============================================================================================================================


-- Find the minimum number of fibonacci whose sum is k



--
-- https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/submissions/1409497619/


--
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        
        # the idea here is to subtract from the largest fib from the end of the array

        fib = [1, 1]

        while fib[-1] <= k:
            fib.append(fib[-1] + fib[-2])
        
        index = len(fib) - 1
        cnt = 0

        while k > 0:
            if fib[index] <= k:
                k -= fib[index]
                cnt += 1
            index -= 1
        
        return cnt 



        
--


===========================================================================================================================


-- Four divisors


-- https://leetcode.com/problems/four-divisors/
--


--
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:

        def divisors(num):
            div = set()

            for i in range(1, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    div.add(i)
                    div.add(num // i)
            if len(div) == 4:
                
                return sum(div)
            return False
        
        n = len(nums)
        cnt = 0

        for i in range(n):
            c = divisors(nums[i])
            if c:
                cnt += c
        
        return cnt
--

======================================================================================================================================


-- Check if there is a Valid path in a grid


--
-- https://leetcode.com/problems/minimum-number-of-frogs-croaking/submissions/1409685642/


--
class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        c = r = o = a = k = 0
        frogs = 0 
        max_frogs = 0 

        for char in croakOfFrogs:
            if char == 'c':
                c += 1
                frogs += 1  # A new frog starts croaking
                max_frogs = max(max_frogs, frogs)  # Update maximum active frogs
            elif char == 'r':
                r += 1
                if r > c:
                    return -1  # More 'r' than 'c', invalid sequence
            elif char == 'o':
                o += 1
                if o > r:
                    return -1  # More 'o' than 'r', invalid sequence
            elif char == 'a':
                a += 1
                if a > o:
                    return -1  # More 'a' than 'o', invalid sequence
            elif char == 'k':
                k += 1
                if k > a:
                    return -1  # More 'k' than 'a', invalid sequence
                frogs -= 1 

        # After processing, all counts should be equal
        if c == r == o == a == k:
            return max_frogs
        else:
            return -1 
--


============================================================================================================================

-- Diagonal traversal



-- https://leetcode.com/problems/diagonal-traverse-ii/
--


--
from collections import defaultdict

class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        diagonals = defaultdict(list)
        
        m, n = len(nums), len(nums[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i + j has the same slope for diagonal elements
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                diagonals[i + j].append(nums[i][j])

        res = []
        # Step 2: Append elements in the order of diagonals
        for k in sorted(diagonals.keys()):
            res.extend(reversed(diagonals[k]))  # Reversed to maintain the correct diagonal order

        return res
--


===============================================================================================================================


-- Max diff you can get from changing an integer


-- https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/submissions/1410678378/
--


--
class Solution:
    def maxDiff(self, num: int) -> int:
        num_str = str(num)

        max_a = num_str
        for i in num_str:
            if i != "9":
                max_a = num_str.replace(i, "9")
                break
        
        max_a = int(max_a)


        min_b = num_str
        if min_b[0] != "1":
            min_b = min_b.replace(min_b[0], "1")
        else:
            for i in num_str[1:]:
                if i != "0" and i != "1":
                    min_b = num_str.replace(i, "0")
                    break
        min_b = int(min_b)
        return max_a - min_b

--


=============================================================================================================================


-- Check if a string can break another string


--
--


--
class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        count1 = [0] * 26
        count2 = [0] * 26
        
        for c in s1:
            count1[ord(c) - ord('a')] += 1
        for c in s2:
            count2[ord(c) - ord('a')] += 1
        
        s1_breaks_s2 = True
        s2_breaks_s1 = True
        
        cumulative_s1 = 0
        cumulative_s2 = 0
        
	# if the cumulative is less than the other it wont break the other
        for i in range(26):
            cumulative_s1 += count1[i]
            cumulative_s2 += count2[i]
            
            if cumulative_s1 < cumulative_s2:
                s1_breaks_s2 = False
            if cumulative_s2 < cumulative_s1:
                s2_breaks_s1 = False
        
        return s1_breaks_s2 or s2_breaks_s1

--


==============================================================================================================================

-- Check if a there is a valid path in agrid


--
--


--
from collections import deque

class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0])
        directions = {
            # in that [1, 4, 6] in the left the number can be 1, 4, 6
            1: [(0, -1, [1, 4, 6]), (0, 1, [1, 3, 5])], # in an array have two directions mentioned left and right ones
            2: [(-1, 0, [2, 3, 4]), (1, 0, [2, 5, 6])],  # Up, Down
            3: [(0, -1, [1, 4, 6]), (1, 0, [2, 5, 6])],  # Left, Down
            4: [(0, 1, [1, 3, 5]), (1, 0, [2, 5, 6])],   # Right, Down
            5: [(0, -1, [1, 4, 6]), (-1, 0, [2, 3, 4])], # Left, Up
            6: [(0, 1, [1, 3, 5]), (-1, 0, [2, 3, 4])]   # Right, Up
        }

        q = deque([(0, 0)])
        visited = set()
        visited.add((0, 0))

        while q:
            x, y = q.popleft()
            
            if x == m - 1 and y == n - 1:
                return True

            # in this going both sides
            for a, b, valid_types in directions[grid[x][y]]:
                nx = x + a
                ny = y + b

                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                    if grid[nx][ny] in valid_types:
                        q.append((nx, ny))
                        visited.add((nx, ny))

        
        return False

--


===============================================================================================================================


-- Circle and rectangle overlapping



-- https://leetcode.com/problems/circle-and-rectangle-overlapping/
--


--
class Solution:
    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        nearest_x = max(x1, min(x2, xCenter))
        nearest_y = max(y1, min(y2, yCenter))

        # Use Euclidean formula to get the Euclidean dist between circle and rectangle

        disx = nearest_x - xCenter
        disy = nearest_y - yCenter

        return disx ** 2 + disy ** 2 <= radius ** 2
--


===============================================================================================================================

-- The kth lexicographical string of all strings
of length k



-- https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/submissions/1411165093/
--


--
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        string = "abc"
        cnt = [0]
        res = []

        def backtrack(current, n):
            if len(current) == n:
                cnt[0] += 1
                if cnt[0] == k:
                    res.append(current)
                return
            
            for i in 'abc':
                if not current or current[-1] != i:
                    backtrack(current + i, n)
                
                    if res:
                        return
        
        backtrack("", n)
    
        # If we found the k-th happy string, return it, otherwise return an empty string
        return res[0] if res else ""



        
--

================================================================================================================================


-- Display table of food orders in a restaurant


-- https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/submissions/1411790865/
--


--
from typing import List

class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = []

        pre = [0] * n
        suf = [0] * n
        pre[0] = nums[0]
        suf[n - 1] = nums[n - 1]

        for i in range(1, n):
            pre[i] = pre[i - 1] + nums[i]

        for i in range(n - 2, -1, -1):
            suf[i] = suf[i + 1] + nums[i]

        for i in range(n):
            temp = (i + 1) * nums[i] - pre[i]
            temp += (suf[i] - (n - i) * nums[i])
            ans.append(temp)

        return ans

--


================================================================================================================================


-- Longest Continuous subarray with absolute diff less than or equal to limit (Neetcode) (Imp)


-- https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
--


--
from collections import defaultdict
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        # using monotonic queue to get the solution
        # Use 2 queues, max queue and min queue

        min_queue = deque() # monotonically increasing
        max_queue = deque() # monotonically decrease
        n = len(nums)

        left = 0
        right = 0
        res = 0

        for right in range(n):
            while min_queue and nums[right] < min_queue[-1]:
                min_queue.pop()

            while max_queue and nums[right] > max_queue[-1]:
                max_queue.pop()

            max_queue.append(nums[right])
            min_queue.append(nums[right])

            while max_queue[0] - min_queue[0] > limit:
                if nums[left] == max_queue[0]:
                    max_queue.popleft()
                if nums[left] == min_queue[0]:
                    min_queue.popleft()
                left += 1
            
            res = max(res, right - left + 1)
    
        return res
--


=============================================================================================================================


-- Build an array with stack


--
--


--
class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        stack = []
        current = 1

        for num in target:

            while current < num:
                stack.append("Push")
                stack.append("Pop")
                current += 1
            
            stack.append("Push")
            current += 1
        
        return stack
--

===============================================================================================================================

-- Simplified fractions



-- https://leetcode.com/problems/simplified-fractions/
--


--
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []

        res = set()
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                if j / i in res:
                    continue
                
                temp = str(j) + '/' + str(i)
                ans.append(temp)
                res.add(j / i)  # Add the fraction tuple to the set
        return ans
--


--
from math import gcd
from typing import List

class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []
        
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                # Check if the fraction is in its simplest form using GCD
                if gcd(j, i) == 1:
                    ans.append(f"{j}/{i}")
        
        return ans

--


============================================================================================================================



-- Count good nodes in binary tree


-- https://leetcode.com/problems/count-good-nodes-in-binary-tree/
--

--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:

        res = []

        def dfs(node, maximum):
            if not node:
                return 
            
            if node.val >= maximum:
                res.append(node.val)
            
            dfs(node.left, max(node.val, maximum))
            dfs(node.right, max(node.val, maximum))

            return maximum

        dfs(root, root.val)
        return len(res)
      
--

============================================================================================================================


-- People whose list of favorite companies is not a subset of another list


-- https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
--


--
class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        result = []

        favoriteSets = [set(arr) for arr in favoriteCompanies]   

        for i in range(len(favoriteSets)):
            isSubset = False
            for j in range(len(favoriteSets)):
                if i != j and favoriteSets[i].issubset(favoriteSets[j]):
                    isSubset = True
                    break
            if not isSubset:
                result.append(i)
        
        return sorted(result)     
--


================================================================================================================================

--  Count triplets that can form two arrays of equal xor


--
-- https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/


--
class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        n = len(arr)
        prefixXor = 0
        count = 0
        freq = {0: 1}
        total = {0: 0}
        
        for i in range(n):
            prefixXor ^= arr[i]
            
            if prefixXor in freq:
                count += freq[prefixXor] * i - total[prefixXor]
            
            freq[prefixXor] = freq.get(prefixXor, 0) + 1
            total[prefixXor] = total.get(prefixXor, 0) + i + 1
        
        return count
--


=======================================================================================================================================

-- Maximum number of vowels ina  substring


-- https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
--


--
from collections import defaultdict

class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        cnt = 0
        left = 0
        right = 0
        n = len(s)
        ans = 0

        while right < n:
            if s[right] in "aeiou":
                cnt += 1

            if right - left + 1 < k:
                right += 1

            elif right - left + 1 == k:
                ans = max(ans, cnt)
                
                if s[left] in "aeiou":
                    cnt -= 1

                left += 1
                right += 1

        return ans

--


=========================================================================================================================


-- Check if a string contains all binary codes of size k


-- https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/
--

-
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        unique_substrings = set()
        n = len(s)
        
        for i in range(n - k + 1):
            substring = s[i:i + k]
            unique_substrings.add(substring)
        
        total_binary_codes = 2 ** k
        
        # you can also check that if the len of unique substrings equal to total binary codes
        return len(unique_substrings) == total_binary_codes

-

=============================================================================================================================

-- Pseudo palindromic path in a binary tree


--
-- https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/


--
# Definition for a binary tree node.
# class TreeNode:k
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node:
                return 0
            
            path ^= (1 << node.val)
            
            if not node.left and not node.right:
                if path & (path - 1) == 0:
                    return 1
                else:
                    return 0
            
            return dfs(node.left, path) + dfs(node.right, path)
        
        return dfs(root, 0)
        
--


========================================================================================================================


-- Course schedule IV (Imp)


-- https://leetcode.com/problems/course-schedule-iv/
--


--
from collections import defaultdict, deque
from typing import List

class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        # Create a graph and indegree array
        g = defaultdict(list)
        indegree = [0] * numCourses

        # Build the graph and indegree array
        for u, v in prerequisites:
            g[u].append(v)
            indegree[v] += 1

        # Initialize the queue for topological sorting
        q = deque()
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)

        # Reachable nodes tracking
        reachable_array = defaultdict(set)

        topo_order = []
        # Perform topological sorting
        while q:
            temp = q.popleft()  # use popleft for O(1) complexity
            topo_order.append(temp)
            for node in g[temp]:
                indegree[node] -= 1
                if indegree[node] == 0:
                    q.append(node)

        # Propagate reachable nodes
        for course in topo_order:
            for neighbor in g[course]:
                reachable_array[neighbor].add(course)
                reachable_array[neighbor].update(reachable_array[course])

        # Check each query
        result = []
        for u, v in queries:
            result.append(u in reachable_array[v])

        #   reachable_array = {
        #       1: {0},        # Course 1 can be reached by course 0
        #       2: {0, 1},     # Course 2 can be reached by courses 0, 1
        #       3: {0, 1, 2},  # Course 3 can be reached by courses 0, 1, 2     
        #   }

        return result


--


============================================================================================================================


-- Maximum area of a piece of cake after horizontal and vertical cuts



-- https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/submissions/1412723062/
--


--
class Solution:
    def maxArea(self, h: int, w: int, hr: List[int], vr: List[int]) -> int:
        hr.sort()
        vr.sort()


        max_hr = max(hr[0], h - hr[-1]) # from the edges to first and last cit
        for i in range(1, len(hr)):
            max_hr = max(max_hr, hr[i] - hr[i - 1])
        
        max_vr = max(vr[0], w - vr[-1])
        for j in range(1, len(vr)):
            max_vr = max(max_vr, vr[j] - vr[j - 1])

        MOD = 10**9 + 7
        return (max_vr * max_hr) % MOD
      
--

===========================================================================================================================

-- Removing stars from a string


-- https://leetcode.com/problems/removing-stars-from-a-string/
--


--
class Solution:
    def removeStars(self, s: str) -> str:

        stack = []

        for i in range(len(s)):
            if s[i] == "*" and stack:
                stack.pop()
            elif s[i] != "*":
                stack.append(s[i])
        
        return "".join(stack)
--


===============================================================================================================================


-- Optimal partition of string


-- https://leetcode.com/problems/optimal-partition-of-string/
--


--
from collections import defaultdict
class Solution:
    def partitionString(self, s: str) -> int:
        cnt = 0
        m = {}

        for i in range(len(s)):
            if s[i] in m:
                cnt += 1
                m = {}
            m[s[i]] = m.get(s[i], 0) + 1
        
        return cnt + 1
--


=============================================================================================================================

-- Reorder to make all paths lead to the city zero



-- https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
--


--
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        adj = defaultdict(list)
    
        for a, b in connections:
            adj[a].append((b, 1))  # road from a to b needs to be reordered
            adj[b].append((a, 0))  # road from b to a is fine as it is
        
        def dfs(node, parent):
            changes = 0
            for neighbor, needs_reorder in adj[node]:
                if neighbor == parent:
                    continue
                changes += needs_reorder
                changes += dfs(neighbor, node)
            return changes
        
        return dfs(0, -1)
--


===============================================================================================================================


-- The k strongest values in a array


-- https://leetcode.com/problems/the-k-strongest-values-in-an-array/
--

--
class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        n =len(arr)
        median = arr[(n - 1) // 2]

        # Step 2: Sort the array based on strength
        arr.sort(key=lambda x: (abs(x - median), x), reverse=True)

        # Step 3: Return the first k strongest elements
        return arr[:k]
--


=========================================================================================================================


-- Find two non overlapping sub arrays each with target sum


-- https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/
--


--
class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        n = len(arr)
        inf = float('inf')
        
        min_len = [inf] * n        
        res = inf
        
        left = 0
        curr_sum = 0
        best_len = inf
        
        for right in range(n):
            curr_sum += arr[right]
            
            while curr_sum > target:
                curr_sum -= arr[left]
                left += 1
            
            # When a valid sub-array with sum equal to target is found
            if curr_sum == target:
                # checking if the subarray with sum equals target found before
                if left > 0 and min_len[left - 1] != inf:
                    # Get the length of the sub which was found before
                    res = min(res, min_len[left - 1] + (right - left + 1))
                
                # Update the best_len with the minimum length of sub-array found so far
                best_len = min(best_len, right - left + 1)
            
            min_len[right] = best_len
        
        return res if res != inf else -1
--


========================================================================================================================


-- Least number of unique integers after k removals


-- https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
--


--
from collections import defaultdict
class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        m = defaultdict(int)

        for i in arr:
            m[i] += 1
        
        sorted_list = sorted(m.values())
        cnt = len(sorted_list)

        for i in sorted_list:
            if i <= k:
                cnt -= 1
                k -= i
            else:
                break
        
        return cnt

        
--


===========================================================================================================================


-- Kth factor of n submissions



-- https://leetcode.com/problems/the-kth-factor-of-n/submissions/1412939794/
--

--
class Solution:
    def kthFactor(self, n: int, k: int) -> int:

        def divisors(num):
            div = []

            for i in range(1, num // 2 + 1):
                if num % i == 0:
                    div.append(i)
            div.append(num)
            return div
        
        arr = divisors(n)

        if len(arr) < k:
            return -1
        
        return arr[k - 1]
--

========================================================================================================================

-- Remove methods from projext


-- https://leetcode.com/contest/weekly-contest-418/problems/remove-methods-from-project/
--



--
from collections import defaultdict
class Solution:
    def remainingMethods(self, n: int, k: int, edges: List[List[int]]) -> List[int]:
        g = defaultdict(list)

        for u, v in edges:
            g[u].append(v)
        
        # from kth node traverse to all the neighbouring nodes and mark them as visited

        vis = [False] * n

        def dfs(node):
            if vis[node]: return
            vis[node] = True

            for neighbour in g[node]:
                    dfs(neighbour)
        
        # no we have marked all the suspicious edges or falty edges 
        dfs(k)

        # we now have to check if the non falty edges are connected to the visited ones if yes then take 
        # all the nodes from 0 to n - 1 else take only the ones that are non visited
        take_all = False
        for u, v in edges:
            if not vis[u] and vis[v]:
                take_all = True

        res = []
        for i in range(n):
            if take_all or not vis[i]:
                res.append(i)

        return res 
--


=======================================================================================================================

--  Construct 2d gird matching graph layout (Incomplete) (Imp)


-- https://leetcode.com/contest/weekly-contest-418/problems/construct-2d-grid-matching-graph-layout/
--

--
from collections import deque, defaultdict
from typing import List

class Solution:
    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        # Helper function to handle dimension and find path
        def handleDimension(adj):
            n = len(adj)
            src, dest = -1, -1
            
            for i in range(n):
                if len(adj[i]) > 1:
                    continue
                if src == -1:
                    src = i
                elif dest == -1:
                    dest = i
            
            if dest == -1:
                return []

            path = getPath(src, dest, adj)
            return path

        # BFS function to get path from src to dest
        def getPath(src, dest, adj):
            n = len(adj)
            
            def bfs(src):
                dist = [-1] * n
                from_node = [-1] * n
                q = deque([src])
                dist[src] = 0
                
                while q:
                    u = q.popleft()
                    
                    for v in adj[u]:
                        if dist[v] == -1:  # Not visited
                            dist[v] = dist[u] + 1
                            from_node[v] = u
                            q.append(v)
                
                return from_node
            
            from_node = bfs(src)
            path = []
            
            node = dest
            while node != -1:
                path.append(node)
                node = from_node[node]
            
            path.reverse()  # Reverse to get the path from src to dest
            return path

        # Build adjacency list
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        # Check for the edge case.
        path = handleDimension(adj)
        print(path)
        if path:
            return []

        # Find all corners (nodes with only 2 edges)
        corners = []
        for i in range(n):
            if len(adj[i]) == 2:
                corners.append(i)

        if len(corners) < 4:
            return []  # Not enough corners to form a grid

        # Find the minimum path size between corners
        paths_size = [
            len(getPath(corners[0], corners[1], adj)),
            len(getPath(corners[0], corners[2], adj)),
            len(getPath(corners[0], corners[3], adj))
        ]
        
        min_index = paths_size.index(min(paths_size))
        cols = paths_size[min_index]
        rows = n // cols
        
        # Fill the first row of the matrix
        ans = [[-1 for _ in range(cols)] for _ in range(rows)]
        ans[0] = getPath(corners[0], corners[min_index + 1], adj)

        # Fill the grid with remaining nodes
        for r in range(rows):
            for c in range(cols):
                # Find the neighbors that have already been placed.
                neighbors = set()
                if r > 0:
                    neighbors.add(ans[r-1][c])  # Above
                if c > 0:
                    neighbors.add(ans[r][c-1])  # Left
                
                # Place the neighbor that has not been placed yet.
                u = ans[r][c]
                for v in adj[u]:
                    if v not in neighbors:
                        ans[r][c] = v
                        break
        print(ans)
        return [[]]

--

=========================================================================================================================

-- Longest subarray of 1s after deleting one element 


-- https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/submissions/1413535232/
--


--
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        zero_count = 0
        max_len = 0
        n = len(nums)

        for right in range(n):
            if nums[right] == 0:
                zero_count += 1

            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            
            # right - left instead of right - left + 1 coz you are requried to delete one element in the array
            
            max_len = max(max_len, right - left)

        return max_len
--


============================================================================================================================


-- Number of subsequence that satify the given sum condition


-- https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/submissions/1413648296/
--


--
class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        # in a sorted array number of subsequence formed is 2^(j - i)
        # and the numbers between i and j can either be included or be excluded in the subsequence

        # if num[i] + num[j] <= target then we add 2^(j - i) to the count

        # if the num[i] + num[j] > target, then move j to left

        i = 0
        MOD = 10**9 + 7
        n = len(nums)
        j = n - 1
        nums.sort()

        power_of_two = [1] * n
        for i in range(1, n):
            power_of_two[i] = (power_of_two[i - 1] * 2) % MOD

        i =0
        cnt = 0
        while i <= j:
            if nums[i] + nums[j] <= target:
                cnt = (cnt + power_of_two[j - i]) % MOD
                i += 1
            else:
                j -= 1
        
        return cnt

        
--


=============================================================================================================================


-- Sentence Similarity III


--
-- https://leetcode.com/problems/sentence-similarity-iii/?envType=daily-question&envId=2024-10-06


--
class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        words1 = sentence1.split(" ")
        words2 = sentence2.split(" ")


        if len(words1) > len(words2):
            words1, words2 = words2, words1

        # Match words from the start and end
        i = 0
        while i < len(words1) and words1[i] == words2[i]:
            i += 1
        
        j = 0
        while j < len(words1) - i and words1[-(j+1)] == words2[-(j+1)]:
            j += 1
        
        # If the remaining middle part (if any) is matched, return True
        return i + j >= len(words1)

        
--


=============================================================================================================================


-- Append characters to string to make subsequence


-- https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/
--


--
from collections import defaultdict
class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        i = 0
        j = 0

        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                j += 1
            i += 1

        return len(t) - j
--

===========================================================================================================================


-- determine if two strings are close


-- https://leetcode.com/problems/determine-if-two-strings-are-close/submissions/1415047021/
--


--
from collections import defaultdict, Counter
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if set(word1) != set(word2):
            return False
        m1 = Counter(word1)
        m2 = Counter(word2)
        
        return sorted(m1.values()) == sorted(m2.values())
        
--


==========================================================================================================================



-- Minimum operations to reduce x to zero


--
-- https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/



--
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        # instead of removing from the ends we can frind out the middle ones which should not be considered
        # We need to find the maximum length subarray which sum equals sum(arr) - x
        target = sum(nums) - x
        if target < 0: # if target is less than 0 then x is greater than sum(arr)
            return -1
        if target == 0: # if x is qual to sum(arr) then return len(nums) 
            return len(nums)

        

        left = 0

        ans = -1
        csum = 0

        for right in range(len(nums)):
            csum += nums[right]

            while csum > target:
                csum -= nums[left]
                left += 1

            if csum == target:
                ans = max(ans, right - left + 1)

        return len(nums) - ans if ans != -1 else -1
        
--

=======================================================================================================================



-- Minimum jumps to reach home (BFS/ DFS) (Imp)


-- https://leetcode.com/problems/minimum-jumps-to-reach-home/
--


--
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        from collections import deque

        max_limit = 6000  # Upper bound for search (arbitrary large value to prevent infinite loops)
        forbidden_set = set(forbidden)
        
        # Queue will store (position, last_jump_was_backward, jumps_count)
        queue = deque([(0, False, 0)])  # Start from position 0, not backward jump, 0 jumps so far
        visited = set([(0, False)])  # Track visited positions with the direction
        
        while queue:
            pos, last_backward, jumps = queue.popleft()
            
            # If we reached home, return the number of jumps
            if pos == x:
                return jumps
            
            # Move forward
            new_pos_forward = pos + a
            if new_pos_forward not in forbidden_set and new_pos_forward <= max_limit and (new_pos_forward, False) not in visited:
                visited.add((new_pos_forward, False))
                queue.append((new_pos_forward, False, jumps + 1))
            
            # Move backward (only if the last jump was not backward)
            new_pos_backward = pos - b
            if not last_backward and new_pos_backward >= 0 and new_pos_backward not in forbidden_set and (new_pos_backward, True) not in visited:
                visited.add((new_pos_backward, True))
                queue.append((new_pos_backward, True, jumps + 1))
        
        # If we exhaust the queue and didn't reach x, return -1
        return -1

--

=============================================================================================================================


-- Minimum deltions to make string balanced



-- https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/submissions/1415395634/
--


--
class Solution:
    def minimumDeletions(self, s: str) -> int:
        minDeletions = 0
        bcount = 0

        for i in s:
            if i == 'b':
                bcount += 1
            else:
                minDeletions = min(minDeletions + 1, bcount)
        return minDeletions
        
--


===========================================================================================================================

-- Minimum operations to make the integer zero


-- https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/
--


--
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(61):
            target = num1 - k * num2
            if target >= 0 and target.bit_count() <= k <= target:
                return k
        return -1
--


======================================================================================================================


-- Sell Diminishing valued colored balls



-- https://leetcode.com/problems/sell-diminishing-valued-colored-balls/
--


--
class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True) # inventory high to low 
        inventory += [0]
        ans = 0
        k = 1
        for i in range(len(inventory)-1): 
            if inventory[i] > inventory[i+1]: 
                if k*(inventory[i] - inventory[i+1]) < orders: 
                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum 
                    orders -= k*(inventory[i] - inventory[i+1])
                else: 
                    q, r = divmod(orders, k)
                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)
                    return ans % 1_000_000_007
            k += 1
--


=============================================================================================================


-- Count zero request servers


-- https://www.youtube.com/watch?v=cIHKCWVBqW0
-- https://leetcode.com/problems/count-zero-request-servers/


--
class Solution:
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:

        # TLE 
        cnt = 0
        res = []

        for query in queries:
            start = query - x
            end = query
            
            count = 0
            
            serverids = set()
            
            for id, time in logs:
                if time >= start and time <= end:
                    serverids.add(id)

            res.append(n - len(serverids))
        return res
    
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:

        # first push all the queries and logs in one array 
        # for logs push it with (time, n + i) n -> no. servers
        # for queries push it as zero based index with server id as 0 based index

        # use queue to sort out the list and remove the intervals which comes before the specified time intervals

        b = []

        for i in range(len(logs)):
            # push (time, id - 1) 
            b.append((logs[i][1], logs[i][0] - 1))

        for i in range(len(queries)):
            # push it as (query, n + i) => n + i determines that it is query and not log in future
            b.append((queries[i], n + i))
        
        # now sort the list out
        b.sort()
        from collections import deque

        q = deque()
        count = 0 # to keep the number of servers which are active at that interval
        d = {} # d to store the server count
        m = len(b)

        ans = [0] * len(queries)

        for i in range(m):
            # this condition tells you that whether the second part is server or the log
            if b[i][1] >= n:

                # traverse through the queue and get the time intervals in the range (b[i][1] - x) to b[i][1]
                while q and b[q[0]][0] < b[i][0] - x:
                    server = b[q[0]][1]
                    d[server] -= 1
                    if d[server] == 0:
                        count -= 1
                    q.popleft()
                ans[b[i][1] - n] = n - count

            else:
                q.append(i) # insert the index to the queue
                server = b[i][1]
                d[server] = d.get(server, 0) + 1

                if d[server] == 1:
                    count += 1
        return ans
--


============================================================================================================

-- Divide players into teams of equal skill


--
-- https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/


--
class Solution:
    def dividePlayers(self, skill: List[int]) -> int:

        # 1, 2, 3, 3, 4, 5
        skill.sort()

        left = 0
        right = len(skill) - 1  # Set right to point to the last element

        equal_sum = skill[left] + skill[right]
        ans = [] 

        while left < right: 
            current_sum = skill[left] + skill[right]
            if current_sum != equal_sum:
                return -1 
            ans.append(skill[left] * skill[right])
            left += 1
            right -= 1 

        return sum(ans)
        
--


==========================================================================================================

-- Contruct the longest new string


-- https://leetcode.com/problems/construct-the-longest-new-string/
--


--
class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        
        # Case 1: If x == y:

        # If the number of "AA" strings is equal to the number of "BB" strings, we can alternate between "AA" and "BB", possibly adding "AB" strings in between.
        # The total length in this case would be 


        # 2(x+y+z)=4x+2z, as each "AA" or "BB" contributes 2 characters, and each "AB" contributes 2 characters.

        # Case 2: If x > y:

        # If there are more "AA" strings than "BB" strings, we should try to alternate as much as possible, but eventually, we will run out of "BB" strings.
        # Once all "BB" strings are used, we need to ensure that the remaining "AA" strings do not form "AAA".
        # To do this, we can add an "AB" string in between to break the sequence of "AA"s.
        # The maximum number of usable "AA" strings without forming "AAA" is 
        # 2
        # 𝑦
        # +
        # 1
        # 2y+1 (one more than twice the number of "BB" strings).
        # The total length in this case would be 

        # 2(2y+1+z)=4y+2+2z.
        # Case 3: If y > x:

        # Similarly to the previous case, if there are more "BB" strings than "AA" strings, we try to alternate, but once we run out of "AA" strings, we must avoid forming "BBB".
        # The maximum number of usable "BB" strings without forming "BBB" is 

        # 2x+1.
        # The total length in this case would be 
        #2(2x+1+z)=4x+2+2z.

        if x == y:
            return 4 * x + 2 * z
        elif x > y:
            return 4 * y + 2 + 2 * z
        else:
            return 4 * x + 2 + 2 * z
        
--


=========================================================================================================


-- Minimum time to repair cars


-- https://leetcode.com/problems/minimum-time-to-repair-cars/
--


--
from typing import List

class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        n = len(ranks)
        
        # Helper function to check if a given time is sufficient to repair all cars
        def checker(time):
            total_cars = 0  # Reset total cars for each check
            for rank in ranks:
                max_cars = int((time // rank) ** 0.5)  # Formula to calculate how many cars can be repaired by the mechanic
                total_cars += max_cars
                if total_cars >= cars:
                    return True
            return False

        # Binary search for the minimum time
        left, right = 0, max(ranks) * cars * cars

        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                right = mid - 1
            else:
                left = mid + 1

        # `left` will have the minimum time required to repair the cars
        return left

--


===========================================================================================================

-- Number of even and odd bits


-- https://leetcode.com/problems/number-of-even-and-odd-bits/submissions/1417287009/
--


--
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        even = 0
        odd = 0


        num_str = bin(n)[2:][::-1]  
        
        i = 0
        n = len(num_str)
        while i < n:
            if num_str[i] == '1': 
                if i % 2 == 0:
                    even += 1
                else:
                    odd += 1
            i += 1
        return [even, odd]

        

    
        
--


==============================================================================================================

-- Decremental string Concatination


--
-- https://leetcode.com/problems/number-of-even-and-odd-bits/submissions/1418333002/


--
--


===============================================================================================================


-- Find score of an array after marking all elements



-- https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/submissions/1419529278/
--


--
class Solution:
    def findScore(self, nums: List[int]) -> int:
        n = len(nums)

        sorted_nums = sorted((num, i) for i, num in enumerate(nums))
        marked = [False] * n

        csum = 0  

        # [1, 2, 2, 3, 3, 5]

        for num, index in sorted_nums:
            if not marked[index]:
                csum += num

                if index - 1 >= 0:
                    marked[index - 1] = True
                if index + 1 < n:
                    marked[index + 1] = True
            
        return csum
--


===============================================================================================================


--Maximize greatest of an array


--
-- https://leetcode.com/problems/maximize-greatness-of-an-array/


--
class Solution:
    def maximizeGreatness(self, nums: List[int]) -> int:
        sorted_array = sorted(nums)

        perm_sorted = sorted(nums)

        i = 0 # pointing to the numbers in sorted_array
        j = 0 # pointing to the numbers in perm_sortted

        greatest_flips = 0

        while i < len(sorted_array) and j < len(perm_sorted):
            if perm_sorted[j] > sorted_array[i]:
                greatest_flips += 1
                i += 1
                j += 1
            else:
                j += 1
        return greatest_flips
        
--


=================================================================================================================


-- Distribute money to maximum children


-- https://leetcode.com/problems/distribute-money-to-maximum-children/
--


--
class Solution:
    def distMoney(self, money: int, children: int) -> int:
        #money left after distributing 1$ to each child
        money=money-children
        c=0
        if  money>=0:
            while money>=7:
                money-=7 
                #addition of 7$ more to each child will make it 8$
                c+=1 
            if money==3 and c==children-1:
                c-=1 #because 1+3=4$
            elif c==children and money>0:
                c-=1 #all the remaining money is taken up by one child
            elif c>children:
                c=children-1 #all the remaining money is given to one child
            return c
        else:
            return -1
--


===================================================================================================================


-- Kth largest sum in a binary tree


-- https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/
--


--
class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:

        q = []
        q.append(root)
        ans = []

        while q:
            size = len(q)
            csum = 0
            for i in range(size):
                temp = q.pop(0)
                csum += temp.val

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
            ans.append(csum)
        ans.sort(reverse=True)
        print(ans)
        return ans[k-1] if k - 1 < len(ans) else -1
--


=================================================================================================================


-- Count the ways to group overlapping ranges 


-- https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/submissions/1422407210/
--


--
class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ranges.sort()

        prev_end = ranges[0][1]
        group = 1
        MOD = 10**9 + 7

        for i in range(len(ranges)):
            start, end = ranges[i]

            if start <= prev_end:
                prev_end = max(prev_end, end)
            else:
                group += 1
                prev_end = end
        
        return pow(2, group, MOD)
--

=================================================================================================================


--  Find the divisibilyt array of a string


--
-- https://leetcode.com/problems/find-the-divisibility-array-of-a-string/


--from typing import List

class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        res = []
        current_remainder = 0

        for char in word:
            current_remainder = (current_remainder * 10 + int(char)) % m # use this method instead of convertiing the huge string to number
            if current_remainder == 0:
                res.append(1)
            else:
                res.append(0)
        
        return res
--


=======================================================================================================


-- Count the number of square free subsets


-- https://leetcode.com/problems/count-the-number-of-square-free-subsets/
--


--
class Solution:
    def squareFreeSubsets(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])

        # get the frequency for the square free numbers
        cnt = defaultdict(int)
        for num in nums:
            if num in candidates:
                cnt[num] += 1
        
        def count(arr):
            if not arr:
                return 1
            arr1 = []
            for num in arr[1:]:
                if math.gcd(num, arr[0]) == 1:
                    arr1.append(num)
            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD
            
        ones = nums.count(1)
        
        tmp = 1
        for _ in range(ones):
            tmp = (tmp * 2) % MOD
        return (count(list(cnt)) * tmp - 1) % MOD
--


============================================================================================================================


-- Minimum operations to reduce an integer to 0



-- https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/
--


--
from collections import deque

class Solution:
    def minOperations(self, n: int) -> int:
        q = deque()

        # (number, operations count)
        q.append((n, 0))
        vis = set()
        vis.add(n)

        powers_of_2 = [1 << i for i in range(30)]  # Precompute powers of 2 up to 2^29

        while q:
            num, op = q.popleft()

            if num == 0:
                return op  # Return the number of operations

            for i in powers_of_2:
                new_num_add = num + i
                new_num_sub = num - i

                # Check if we can add or subtract i to get closer to 0
                if new_num_add not in vis:
                    vis.add(new_num_add)
                    q.append((new_num_add, op + 1))

                if new_num_sub not in vis and new_num_sub >= 0:  # Only consider non-negative numbers
                    vis.add(new_num_sub)
                    q.append((new_num_sub, op + 1))

        return -1  # If no solution is found (although this should never happen)

--


==========================================================================================================================

-- Count the total number of colored cells


-- https://leetcode.com/problems/count-total-number-of-colored-cells/submissions/1423536173/
--


--
class Solution:
    def coloredCells1(self, n: int) -> int:

        if n == 1:
            return 1

        dp = [0] * (n + 1)

        dp[0] = 0
        dp[1] = 1

        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + (4 * (i - 1))
        

        return dp[n]
    
    def coloredCells(self, n: int) -> int:
        total_cells = 1
        if n == 1:
            return total_cells
        for i in range(2, n+1):
            total_cells += 4 * (i - 1)
        return total_cells
        
--

==========================================================================================================================

-- Rearrange array to maximize prefix score


-- https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/description/
--

--
class Solution:
    def maxScore1(self, nums: List[int]) -> int:
        return sum(n > 0 for n in accumulate(sorted(nums, reverse=True)))
    
    def maxScore(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
    
        prefix_sum = 0
        positive_count = 0
        
        # Calculate prefix sums and count how many are positive
        for num in nums:
            prefix_sum += num
            if prefix_sum > 0:
                positive_count += 1
            else:
                break  # Once the prefix sum becomes non-positive, stop counting
        
        return positive_count
--


========================================================================================================================


-- Count the number of beautiful subarrays (Imp)


-- https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/
--


--
class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        prefix = 0

        # cal the prefix xor if the number is already present in the array then the subarry from left to right is subarray

        xor = {0 : 1}
        n = len(nums)
        ans = 0

        for i in range(n):
            prefix ^= nums[i]

            if prefix in xor:
                ans += xor[prefix]
            xor[prefix] = xor.get(prefix, 0) + 1

        return ans 
        
--



========================================================================================================================


-- Minimum score by changing two elements


-- https://leetcode.com/problems/minimum-score-by-changing-two-elements/
--


--
class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
    # Change the two largest values to the third largest value. Third largest value now becomes the max value.
    # Change the two smallest values to the third smallest value. Third smallest value now becomes the min value.
    # Change largest value to second largest value and smallest value to second smallest value. Second largest becomes max value and second smallest becomes min value.


        n = len(nums)

        nums.sort()
        return min(nums[-1] - nums[2], min(nums[n - 2] - nums[1], nums[n - 3] - nums[0]))
--


===========================================================================================================================


-- Substring xor queries


--
-- https://leetcode.com/problems/substring-xor-queries/


--
from typing import List

class Solution:
    def substringXorQueries1(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        n = len(s)

        def checker(target, prev_start):
            for start in range(n):
                val = 0
                for end in range(start, n):
                    val = (val << 1) | int(s[end])

                    if val == target:
                        temp = start
                        while temp + 1 <= end and int(s[temp + 1: end + 1]) == target:
                            temp += 1
                        return ([temp, end], end)  

                    if val > 10**9:
                        break
            return False

        ans = []
        prev = 0 
        for first, second in queries:
            target = first ^ second
            result = checker(target, prev)

            if result:
                res, new_end = result 
                prev = new_end
                ans.append(res)
            else:
                ans.append([-1, -1])
        
        return ans

    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        # for every i at amx we can go till 32 length and then get the smallest substring which matches the target
        # and get the answer for it
        l=len(s) #get length of the given string
        d={} #create empty hashmap
        n=min(32,l) # integer upto 10**9 can be represented within 32 bits, hence we need all substrings upto 32 bits length. Also, length of the given string could be < 32.

        for i in range(n): # generate all substrings of i+1 length
            for j in range(l-i): 
                # l - i because from i to 32 long
                x=s[j:j+i+1] 
                if int(x,2) not in d:
                    d[int(x,2)]=[j,j+i]


        ans=[]
        
        for q in queries:
            x=q[0]^q[1] 
            if x in d:
                ans.append(d[x])
            else:
                ans.append([-1,-1])
        return ans
--

=========================================================================================================================


-- Count the number of fair pairs (Imp)


--
--



--
class Solution:
    def countFairPairs1(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        n = len(nums)
        count = 0
        
        # Iterate over each element in nums
        for i in range(n):
            # Find the lower bound index for nums[i]
            low_index = bisect.bisect_left(nums, lower - nums[i], i + 1)
            # Find the upper bound index for nums[i]
            high_index = bisect.bisect_right(nums, upper - nums[i], i + 1)
            
            # Count valid pairs with nums[i]
            count += (high_index - low_index)
        
        return count
    
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()

        # first check for all left and right compare it with upper and lower range

        # and add the pairs to the values if sorted array then right - left gives the number of paires
        n = len(nums)

        left = 0
        right = n - 1
        val1 = 0

        # counting first for upper and then lower
        while left < right:
            if nums[left] + nums[right] <= upper:
                val1 += right - left
                left += 1
            else:
                right -= 1
        

        # now calculate for the pairs which are less than lower so that at the end you can subtract the sum at the end 
        left = 0
        right = n - 1
        val2 = 0

        while left < right:
            if nums[left] + nums[right] < lower:
                val2 += right - left
                left += 1
            else:
                right -= 1
        return val1 - val2
--


=============================================================================================================================


-- Find the array concatenation value

-- https://leetcode.com/problems/find-the-array-concatenation-value/submissions/1425667879/
--


--
class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:

        ans = 0
        left = 0
        n = len(nums)
        right = n - 1

        while left <= right:
            if left == right:
                ans += nums[left]
            else:
                temp = int(str(nums[left]) + str(nums[right]))
                ans += temp
            left += 1
            right -= 1
        return ans
--


==============================================================================================================================

-- House Robber IV


-- https://leetcode.com/problems/house-robber-iv/
--

--
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        def can_steal_with_capability(cap):
            count = 0
            i = 0
            while i < len(nums):
                if nums[i] <= cap:
                    count += 1
                    i += 2  # Skip the next house to ensure non-adjacency
                else:
                    i += 1
            return count >= k

        low, high = min(nums), max(nums)
        
        while low < high:
            mid = (low + high) // 2
            if can_steal_with_capability(mid):
                high = mid  # Try to lower the capability
            else:
                low = mid + 1  # Increase the capability
        
        return low
--

===============================================================================================================================

-- Count the vowel strin in ranges


-- https://leetcode.com/problems/count-vowel-strings-in-ranges/
--



--
class Solution:
    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        n = len(words)
        prefix_sum = [0] * n
        vowels = "aeiou"

        for i in range(n):
            if words[i] and words[i][0] in vowels and words[i][-1] in vowels:
                prefix_sum[i] = 1

            if i > 0:
                prefix_sum[i] += prefix_sum[i - 1]
        
        ans = []
        for l, r in queries:
            if l > 0:
                ans.append(abs(prefix_sum[r]  - prefix_sum[l - 1]))
            else:
                ans.append(prefix_sum[r])

        return ans 
--


===============================================================================================================


-- Closest nodes queries in a binary search tree


-- https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/submissions/1427315570/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        arr = []            
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            arr.append(node.val)
            inorder(node.right)

        def findmini(num):
            left = 0
            right = len(arr) - 1
            res = -1

            while left <= right:
                mid = (left + right)//2

                if arr[mid] <= num:
                    res = arr[mid]
                    left = mid + 1
                else:
                    right = mid - 1
            return res
        
        def findmaxi(num):
            left = 0
            right = len(arr) - 1
            res = -1

            while left <= right:
                mid = (left + right)//2

                if arr[mid] >= num:
                    res = arr[mid]
                    right = mid - 1
                else:
                    left = mid + 1
            return res
    
        
        inorder(root)
        result = []
        for query in queries:
            mini = findmini(query)
            maxi = findmaxi(query)
            result.append([mini, maxi])
        
        return result
--


================================================================================================================ 

-- Number of unequal triplets in a array


-- https://leetcode.com/problems/number-of-unequal-triplets-in-array/
--


--
class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] != nums[j] and nums[j] != nums[k] and nums[k] != nums[i]:
                        ans += 1
        return ans

    def unequalTriplets(self, nums: List[int]) -> int:
        c = Counter(nums)
        res = 0

        l = 0 
        r = len(nums)

        for i, f in c.items():
            r -= f
            res += l * f * r
            l += f

        return res

        
--

==========================================================================================================================================================

-- Most profitable path in a tree


-- https://leetcode.com/problems/most-profitable-path-in-a-tree/
--


--
class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        from collections import defaultdict
        graph = defaultdict(list)
        for src, des in edges:
            graph[src].append(des)
            graph[des].append(src)
        
        # bob traversal
        bobPath = dict()
        def bobTravel(bob, time):
            bobPath[bob] = time 
            if bob == 0: return True

            for neighbor in graph[bob]: # graph[1]
                if not bobPath.get(neighbor):
                    if bobTravel(neighbor, time + 1): 
                        return True
                    del bobPath[neighbor]
                        
                    
            return False            


        # alice traversal
        # alice traverses each node and collects the reward/price depending
        # on the node, the amount at each node depends on bob's path
        # case 1: collision => amount // 2 . node in bob's path and at the same time
        # case 2: already visited by bob: node in bob's path and it's time more than bob's time
        # otherwise collect/incur full amount from the gate.
        # as soon as the traversal reaches the leaf node, make changes to the global max_profit if applicable
        # and return 
        bobTravel(bob, 1)
        max_profit = - float('inf')
        
        visited = [0] * len(graph)
        def aliceTraversal(node, time, amt):
            nonlocal max_profit 
            if bobPath.get(node):
                if time == bobPath[node]:
                    amt += amount[node] // 2
                if time < bobPath[node]:
                    amt += amount[node]
            else:
                amt += amount[node]
            visited[node] = 1
            cnt = 0
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    cnt += 1
                    aliceTraversal(neighbor, time + 1, amt)
            
            if cnt == 0:
                max_profit = max(max_profit, amt)
            
        aliceTraversal(0, 1, 0)
        return max_profit
--


==========================================================================================================================================================


-- Find the sequence of strings appeared on the screen


--
-- https://leetcode.com/problems/find-the-sequence-of-strings-appeared-on-the-screen/


--
class Solution:
    def stringSequence(self, target: str) -> List[str]:

        res = []

        i = 0
        n = len(target)
        string = ""

        while i < n:
            for char in range(26):
                temp = chr(char + ord('a'))
                print(temp, i, target[i])
                if target[i] == temp:
                    string += temp
                    res.append(string)
                    i += 1
                    break
                else:
                    string += temp
                    res.append(string)
                    string = string[:-1]

        return res
--


==============================================================================================================================================================


-- Count substrings with k frequency (Imp)


-- https://leetcode.com/problems/count-substrings-with-k-frequency-characters-i/
--


--
from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        ans = 0
        l = 0
        d = {}
        for c in s:
            d[c] = d.get(c, 0) + 1
            while d[c] == k:
                d[s[l]] -= 1
                l += 1
            ans += l
        return ans
--


============================================================================================================================================================


-- Minimum division operations to make array non decreasing


-- https://leetcode.com/problems/minimum-division-operations-to-make-array-non-decreasing/
--


--
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums) - 1, 0, -1):
            if nums[i] < nums[i - 1]:
                nums[i - 1] = self.findNum(nums[i], nums[i - 1])
                if nums[i - 1] == -1: return -1
                ans += 1
        return ans
    
    def findNum(self, n1, n2):
        for i in range(n1, 1, -1):
            if n2 % i == 0: return i
        return -1
--


============================================================================================================================================================

-- Count ways to build good strings (Imp)


-- https://leetcode.com/problems/count-ways-to-build-good-strings/
--


--
class Solution:
    def countGoodStrings1(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 10**9 + 7
    
        # Initialize dp array for lengths up to high
        dp = [0] * (high + 1)
        dp[0] = 1  # There is one way to create an empty string

        # Fill dp array
        for i in range(1, high + 1):
            if i - zero >= 0:
                dp[i] = (dp[i] + dp[i - zero]) % MOD
            if i - one >= 0:
                dp[i] = (dp[i] + dp[i - one]) % MOD

        # Count the number of good strings
        total_good_strings = sum(dp[low:high + 1]) % MOD
        
        return total_good_strings

    def countGoodStrings2(self, low: int, high: int, zero: int, one: int) -> int:
        mod = 10**9 + 7
        # dp = {0 : 1} # base case length -> number of strings of length 0
        dp = {}

        def dfs(length):
            if length > high:
                return 0

            if dp.get(length, 0):
                return dp[length]

            for_zero = dfs(length + zero)
            for_one = dfs(length + one)

            res = 1 if length >= low else 0
            res += for_zero + for_one

            dp[length] = res % mod
            return res % mod

        return dfs(0) 

    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = {0: 1} #  base case length -> number of strings of length 0
        mod = 10**9 + 7

        # using this approach since i got TLE

        for i in range(1, high + 1):
            dp[i] = (dp.get(i - one, 0) + dp.get(i - zero, 0)) % mod
        
        return sum([dp[i] for i in range(low, high + 1)]) % mod
--


==========================================================================================================================================================

-- Total Cost to hire k workers


-- https://leetcode.com/problems/total-cost-to-hire-k-workers/submissions/1428245288/
--


--
from heapq import heappush, heappop
from typing import List

class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        left = 0
        right = n - 1

        heapl = []
        heapr = []

        for i in range(candidates):
            if left <= right:
                heappush(heapl, (costs[left], left))
                left += 1
            if left <= right:
                heappush(heapr, (costs[right], right))
                right -= 1

        total = 0
        # Select the minimum cost for 'k' times
        for i in range(k):
            if not heapl:
                temp = heappop(heapr)
                total += temp[0]
            elif not heapr:
                temp = heappop(heapl)
                total += temp[0]
            else:
                if heapl[0][0] <= heapr[0][0]:
                    total += heappop(heapl)[0]
                    if left <= right:
                        heappush(heapl, (costs[left], left))
                        left += 1
                else:
                    total += heappop(heapr)[0]
                    if left <= right:
                        heappush(heapr, (costs[right], right))
                        right -= 1

        return total

--


============================================================================================================================================================


-- Maximum sum of distinct subarrays with length k


--
-- https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/


--
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        left = 0
        right = 0

        n = len(nums)
        total = 0
        ans = 0
        csum = 0
        m = {}

        while right < n:
            csum += nums[right]
            m[nums[right]] = m.get(nums[right], 0) + 1

            if right - left + 1 < k:
                right += 1

            elif right - left + 1 == k:
                if len(m) == k:
                    ans = max(ans, csum)
                
                m[nums[left]] = m.get(nums[left], 0) - 1

                if m[nums[left]] == 0:
                    del m[nums[left]]

                csum -= nums[left]
                left += 1
                right += 1

        return ans

--


===========================================================================================================================================================


-- Distinct prime facotrs of product of array


--
--


--
class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:

        # get the prime factors for every number
        def prime_factor(num):
            factor = set()

            # first check for the number divisible by 2
            while num % 2 == 0:
                factor.add(2)
                num //= 2
            
            for i in range(3, int(num**0.5) + 1, 2):
                while num % i == 0:
                    factor.add(i)
                    num //= i
            
            # if num is prime number greater than 2
            if num > 2:
                factor.add(num)
            return factor
        
        prime_factors = set()

        for i in nums:
            prime_factors.update(prime_factor(i))

        return len(prime_factors)

          
--

==========================================================================================================================================================


-- parition string into substrings with values at most k


--
-- https://leetcode.com/problems/partition-string-into-substrings-with-values-at-most-k/


--
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        current_string = ""
        count = 0

        for char in s:
            current_string += char

            if int(current_string) > k:
                count += 1
                current_string = char

                if int(current_string) > k:
                    return -1
        
        if current_string:
            count += 1
        return count        
--


======================================================================================================================================================

-- Closest prime numberds in range


--
-- https://leetcode.com/problems/closest-prime-numbers-in-range/


--
class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def is_prime(n):
            if n <= 1:
                return False
            if n <= 3:
                return True
            if n % 2 == 0 or n % 3 == 0:
                return False
            i = 5
            while i * i <= n:
                if n % i == 0 or n % (i + 2) == 0:
                    return False
                i += 6
            return True

        res = []
        for i in range(left, right + 1):
            if is_prime(i):
                res.append(i)

        
        mini = float("inf")
        ans = [-1, -1]

        for i in range(1, len(res)):
            minimum_diff = res[i] - res[i - 1]

            if minimum_diff < mini:
                mini = minimum_diff
                ans = [res[i - 1], res[i]]
        return ans
--


====================================================================================================================================================

-- Make the number of distinct characters equal


-- https://leetcode.com/problems/make-number-of-distinct-characters-equal/submissions/1428539211/
--

--
class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        cnt1, cnt2 = [0 for i in range(26)], [0 for i in range(26)]

        # count the frequency for word1 and word2
        for i in range(len(word1)):
            cnt1[ord(word1[i]) - ord('a')] += 1
        for i in range(len(word2)):
            cnt2[ord(word2[i]) - ord('a')] += 1

        # swap the words
        for i in range(26):
            for j in range(26):
                if cnt1[i] != 0 and cnt2[j] != 0:
                    # Swap
                    cnt1[j] += 1
                    cnt2[j] -= 1
                    cnt1[i] -= 1
                    cnt2[i] += 1
                    # Check Validity
                    if self.isValid(cnt1, cnt2):
                        return True
                    # Restore
                    cnt1[j] -= 1
                    cnt2[j] += 1
                    cnt1[i] += 1
                    cnt2[i] -= 1
        return False
    
    def isValid(self, c1, c2):
        d1, d2 = 0, 0
        for i in range(26):
            if c1[i] != 0:
                d1 += 1
            if c2[i] != 0:
                d2 += 1
        return d1 == d2
--


==================================================================================================================================================

-- Count the number of good subarrays


-- https://leetcode.com/problems/count-the-number-of-good-subarrays/
--


--
from collections import defaultdict
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        m = defaultdict(int)
        left = 0
        n = len(nums)
        good_subarrays = 0
        result = 0
        
        for right in range(n):
            # calculate all the pairs 
            good_subarrays += m[nums[right]]
            m[nums[right]] += 1

            while good_subarrays >= k:
                # include the subarrays to the result
                result += n - right

                # from left reduce the window and calculate the subarrays
                m[nums[left]] -= 1
                good_subarrays -= m[nums[left]]
                left += 1

        return result
            
                
--


==================================================================================================================================================

-- Minimum operations to make array equal II

-- https://leetcode.com/problems/minimum-operations-to-make-array-equal-ii/description/
--


--
class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        if k == 0:
            return 0 if nums1 == nums2 else -1
        
        total_increase = 0
        total_decrease = 0

        for i in range(len(nums1)):
            diff = nums1[i] - nums2[i]

            if diff % k:
                return -1
            
            if diff > 0:
                # you need to divide the diff with k since the diff can be increased or dcreased in k folds
                total_increase += diff // k
            
            if diff < 0:
                total_decrease += (-diff) // k
            
        if total_increase == total_decrease:
            return total_increase
        return -1
            


        
--


==================================================================================================================================================


-- Maximum tastiness of candy basket 


--
-- https://leetcode.com/problems/maximum-tastiness-of-candy-basket/submissions/1429507557/


--
class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        price.sort()

        def checker(diff):
            # increase the maximum diff
            count = 1
            prev = price[0]

            for i in range(1, len(price)):
                if price[i] - prev >= diff:
                    count += 1
                    prev = price[i]
                    if count == k:
                        return True
            return False

        left = 0
        # get the right which has maximum diff
        right = price[-1] - price[0]

        result = 0
        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        return result            

        
--


================================================================================================================================================


-- Take k of each char from left and right


--
-- https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/submissions/1430507073/


--
class Solution:
    def takeCharacters(self, s: str, k: int) -> int:

        # instead of removing from both the ends 
        # you can you technique to get the longest substring to get the characters count(char) - k
        # if any character count goes below 0 then return -1

        # for all the character count decrease by k
        limit = {char: s.count(char) - k for char in "abc"}

        if any(x < 0 for x in limit.values()):
            return -1
        
        cnts = {c: 0 for c in 'abc'}
        ans = l = 0
        for r, c in enumerate(s):
            cnts[c] += 1

            while cnts[c] > limit[c]:
                cnts[s[l]] -= 1
                l += 1
            ans = max(ans, r - l + 1)
        return len(s) - ans
--

===============================================================================================================================================

-- Minimize the maximum of two arrays


--
-- https://leetcode.com/problems/minimize-the-maximum-of-two-arrays/


--
class Solution: 
	def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int: 
		lo, hi = 0, 1<<32-1
		mult = lcm(divisor1, divisor2)

		while lo < hi: 
			mid = lo + hi >> 1

            # mid - mid // div1 gives you total number of count which is less than mid

            # un1 + uni2 <= mid - mid //mul gives you total nuumber of elements which is not divisible by either one
			if uniqueCnt1 <= mid - mid//divisor1 and uniqueCnt2 <= mid - mid//divisor2 and uniqueCnt1+uniqueCnt2 <= mid - mid//mult: 
                hi = mid
			else: 
                lo = mid+1
		return lo 
--


==============================================================================================================================================

-- Reward top k students


-- https://leetcode.com/problems/reward-top-k-students/submissions/1431056624/
--


--
from collections import defaultdict
from typing import List
class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:

        # traverse through the map and check for the feedbacks

        pos = set(positive_feedback)
        neg = set(negative_feedback)

        student = {}

        for i in range(len(report)):
            words = report[i].split()
            _id = student_id[i]

            if _id not in student:
                student[_id] = 0

            for word in words:
                if word in pos:
                    student[_id] += 3
                elif word in neg:
                    student[_id] -= 1
            
        sorted_values = sorted(student.keys(), key=lambda x:(-student[x], x))

        return sorted_values[:k]


--


==================================================================================================================================================

-- Maximum enemy forts that can be captured 


-- https://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/
--


--
class Solution:
    def captureForts(self, f: List[int]) -> int:

        prevOne = False
        cnt = 0
        ans = 0

        n = len(f)
        for i in range(n):
            if f[i] == 0 and prevOne:
                cnt += 1
            elif f[i] == 1:
                cnt = 0
                prevOne = True
            elif f[i] == -1:
                prevOne = False
                ans = max(cnt, ans)
                cnt = 0
        
        prevOne = False
        cnt = 0
        for i in range(n - 1, -1, -1):
            if f[i] == 0 and prevOne:
                cnt += 1
            elif f[i] == 1:
                cnt = 0
                prevOne = True
            elif f[i] == -1:
                prevOne = False
                ans = max(cnt, ans)
                cnt = 0
        
        return ans



        
--


======================================================================================================================================================


-- Remove nodes from linked list


-- https://leetcode.com/problems/remove-nodes-from-linked-list/
--


--
from typing import Optional


# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:

        # Reverse the linked list
        def reverse_head(node):
            if not node:
                return None

            cur = node
            prev = None

            while cur:
                next_node = cur.next
                cur.next = prev
                prev = cur
                cur = next_node
            return prev

        rev_head = reverse_head(head)
        cur = rev_head
        max_element = cur.val

        while cur and cur.next:
            if cur.next.val < max_element:
                cur.next = cur.next.next
            else:
                max_element = cur.next.val
                cur = cur.next
        return reverse_head(rev_head)
--


=====================================================================================================================================================


-- Minimum penalty for a shop



-- https://leetcode.com/problems/minimum-penalty-for-a-shop/submissions/1434224540/
--


--
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        res = 0
        customer_left = 0
        
        for i in range(len(customers)):
            # if customer is greater than 0 there are still customers inside the shop
            # so reset the res to i + i coz the current one is Y
            # if 'N' decreament 1 from customer_left
            if customers[i] == 'Y':
                customer_left += 1

                if customer_left > 0:
                    res = i + 1
                    customer_left = 0                
            else:
                customer_left -= 1
                    
        return res
--

=======================================================================================================================================================


-- Diff between ones and zeros in row and col


-- https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/post-solution/?submissionId=1434246446
--


--
class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0])

        onesRow = [0] * m
        onesCol = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    onesRow[i] += 1
                    onesCol[j] += 1

        diff = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                zerosRow = m - onesRow[i]
                zerosCol = n - onesCol[j]

                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow - zerosCol
        return diff
        

--

========================================================================================================================================================

-- Minimum addition to make integer beautiful


-- https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/
--


--
class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:

        sm = lambda n: sum(map(int,list(str(n))))

        zeros, diff = 10, 0                     #  Ex: n = 5617     ; target = 7

        while sm(n + diff) > target:            #   n    zeros   diff  n+diff  sm(n+diff)
                                                # -----  –––––  –––––  ––––––  –––––––––  
            diff = zeros - n%zeros              # 5617     10      3    5620     13  
                                                # 5617    100     83    5700     12
            zeros*= 10                          # 5617   1000    383    6000      6  <-- less than target
                                                #                 |
        return diff  
--


===========================================================================================================================================================


-- Most popular video creater


--  https://leetcode.com/problems/most-popular-video-creator/
--

--
from collections import defaultdict
class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:

        total_views = defaultdict(int)
        max_views = defaultdict(lambda: (0, ""))  # (max_view_count, id)

        n = len(creators)
        
        for i in range(n):
            creator = creators[i]
            video_id = ids[i]
            view_count = views[i]

            total_views[creator] += view_count

            current_max, current_id = max_views[creator]
            if view_count > current_max:
                max_views[creator] = (view_count, video_id)
            elif view_count == current_max:
                if video_id < current_id or current_id == "":
                    max_views[creator] = (current_max, video_id)

        max_popularity = max(total_views.values())
        result = []

        for creator in total_views:
            if total_views[creator] == max_popularity:
                most_viewed_id = max_views[creator][1]
                result.append([creator, most_viewed_id])

        return result

        

        
--


========================================================================================================================================================


-- Destroy sequential targets


--
-- https://leetcode.com/problems/destroy-sequential-targets/



--
from typing import List

class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        m = {}

        for num in nums:
            reminder = num % space
            if reminder not in m:
                m[reminder] = 1
            else:
                m[reminder] += 1

        max_target = 0
        best_seed = float("inf")

        for num in nums:
            reminder = num % space
            count = m[reminder]

            if count > max_target or (count == max_target and num < best_seed):
                best_seed = num
                max_target = count
        
        return best_seed

--

=========================================================================================================================================================

-- Words within two edits of dictionary


-- https://leetcode.com/problems/words-within-two-edits-of-dictionary/
--


--
from typing import List

class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:

        def is_valid(q, w):
            count = 0
            for i in range(len(q)):
                if q[i] != w[i]:
                    count += 1
                if count > 2:
                    return False
            return count <= 2

        res = []
        for q in queries:
            for d in dictionary:
                if is_valid(q, d):
                    res.append(q)
                    break
        
        return res

--

=========================================================================================================================================================


-- Number of subarrays with gcd equal to k


-- https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/
--


--
class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        
        for i in range(n):
            current_gcd = 0
            for j in range(i, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                
                if current_gcd == k:
                    count += 1
                elif current_gcd < k:
                    break
                    
        return count
--


========================================================================================================================================================


-- Sum of number and its reverse


-- https://leetcode.com/problems/sum-of-number-and-its-reverse/
--


--
    def sumOfNumberAndReverse(self, num: int) -> bool:
        if num < 2:
            return num == 0
        for i in range(num // 2, num):
            rev = int(str(i)[::-1])
            if rev + i == num:
                return True
        return False
--


=========================================================================================================================================================


-- Count the number of distince int after reverse operations


--
-- https://leetcode.com/problems/count-number-of-distinct-integers-after-reverse-operations/


--
class Solution:
    def countDistinctIntegers1(self, nums: List[int]) -> int:
        s = set()
        cnt = 0

        for i in nums:
            temp = int(str(i)[::-1])
            if i not in s:
                cnt += 1
            s.add(i)
            if temp not in s:
                cnt += 1
            s.add(temp)
        
        return cnt
    
    def countDistinctIntegers(self, nums: List[int]) -> int:
    
        unique_integers = set()

        for num in nums:
            unique_integers.add(num)

        for num in nums:
            reversed_num = int(str(num)[::-1])
            unique_integers.add(reversed_num)

        return len(unique_integers)
            
     
--


============================================================================================================================================
 

-- Minimize maximum of array


-- https://leetcode.com/problems/minimize-maximum-of-array/submissions/1438760070/
--


--
import math
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:

        # two approchs 
            # Binary search
            # Normal greedy

        # Normal apporach

        cur_sum = 0
        a = 0  # max_value
        
        for ind, num in enumerate(nums):
            cur_sum += num
            ceil = math.ceil(cur_sum / (ind + 1))
            a = max(a, ceil)
        
        return a

    def minimizeArrayValue(self, nums: List[int]) -> int:
        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))

        
--


============================================================================================================================================


-- Range porduct querirs of powers


-- https://leetcode.com/problems/range-product-queries-of-powers/submissions/1438815532/
--


--
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:

        def get_minimum_pow(num):
            powers = 1
            res = []

            while num:
                if num & 1:
                    res.append(powers)
                powers *= 2
                num = num >> 1
        
            return res
        
        powers = get_minimum_pow(n)
        result = []

        def product_in_range(powers, left, right):
            MOD = 10**9 + 7
            result = 1
            for i in range(left, right + 1):
                result = (result * powers[i]) % MOD
            return result

        for left, right in queries:
            result.append(product_in_range(powers, left, right))
        return result


        
--


==============================================================================================================================================


-- Range product queries of powers


-- https://leetcode.com/problems/range-product-queries-of-powers/
--


--
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        # you can use prefix sum to get apporach as well
        def get_minimum_pow(num):
            powers = 1
            res = []

            while num:
                if num & 1:
                    res.append(powers)
                powers *= 2
                num = num >> 1
        
            return res
        
        powers = get_minimum_pow(n)
        result = []

        def product_in_range(powers, left, right):
            MOD = 10**9 + 7
            result = 1
            for i in range(left, right + 1):
                result = (result * powers[i]) % MOD
            return result

        for left, right in queries:
            result.append(product_in_range(powers, left, right))
        return result


        
--



==================================================================================================================================================


-- Using a robot to print the lexicographically smallesst string


-- https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/
--


--
class Solution:
    def robotWithString(self, s: str) -> str:
        cnt, lo, p, t = Counter(s), 'a', [], []
        for ch in s:
            t += ch
            cnt[ch] -= 1
            while lo < 'z' and cnt[lo] == 0:
                lo = chr(ord(lo) + 1)
            while t and t[-1] <= lo:
                p += t.pop()
        return "".join(p) 
--


======================================================================================================================================================


-- Minimize xor


-- https://leetcode.com/problems/minimize-xor/submissions/1439217586/
--


--
class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        k = bin(num2).count('1') # number of set bits 
        x = 0
        for i in range(31, -1, -1):
            if k == 0:
                break
            
            # check if ith bit of the number is set then or with x
            if (num1 & (1 << i) != 0):
                x |= (1 << i)
                k -= 1

        # this for loop needed when there is not enough set bits in num1
        for i in range(32):
            if k == 0:
                break
            if (x & (1 << i)) == 0:  # If the bit is not set in x
                x |= (1 << i)  # Set this bit in x
                k -= 1
        
        return x
        
        
--


=====================================================================================================================================================


-- Maximum sum of an hourglass


--
-- https://leetcode.com/problems/maximum-sum-of-an-hourglass/


--
class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        if m <= 2 and n <= 2:
            return -1

        max_sum = float('-inf')

        # Iterate over possible hourglass centers
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                # Calculate the hourglass sum centered at grid[i][j]
                hourglass_sum = (
                    grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] +
                    grid[i][j] +
                    grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]
                )
                # Update max_sum if the current hourglass_sum is greater
                max_sum = max(max_sum, hourglass_sum)

        return max_sum
            

        
--


======================================================================================================================================================

-- Bitwise xor of all pairings


-- https://leetcode.com/problems/bitwise-xor-of-all-pairings/
--


--
from typing import List

class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        odd1 = len(nums1) % 2
        odd2 = len(nums2) % 2

        x1 = 0
        for i in nums1:
            x1 ^= i
        x2 = 0
        for j in nums2:
            x2 ^= j

        return (odd1 * x2) ^ (odd2 * x1)

--


=================================================================================================================================================


-- Find all good indices (Imp)


-- https://leetcode.com/problems/find-all-good-indices/
--


--
    def goodIndices(self, nums: List[int], k: int) -> List[int]:

        n = len(nums)

        if n < 2 * k + 1:
            return []

        left = [False] * n
        right = [False] * n

        ls, rs = -1, n

        for i in range(1, n):
            if i >= k:
                if i - ls > k:
                    left[i] = True
            if nums[i] > nums[i - 1]:
                ls = i - 1
        
        for j in range(n - 2, -1, -1):
            if j < n - k:
                if rs - j > k:
                    right[j] = True
            if nums[j] > nums[j + 1]:
                rs = j + 1
        
        res = []
        for i in range(n):
            if left[i] and right[i]:
                res.append(i)
        return res
--


=================================================================================================================================================


-- Reverse odd levels of binary tree


-- https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        q = [root] 
        level = 1

        while q:
            size = len(q)
            current_level = []

            for i in range(size):
                node = q.pop(0)

                current_level.append(node)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            if level % 2 == 0:
                temp = []

                for node in current_level:
                    temp.append(node.val)

                temp = temp[::-1]

                for i in range(len(current_level)):
                    current_level[i].val = temp[i]
            
            level += 1

        return root
        
--

================================================================================================================================================= 


-- Length of the longest alphabetical continuous substring


--
-- https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/submissions/1439768555/


--
class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        
        ans = 1
        count = 1

        for i in range(1, len(s)):
            if ord(s[i]) == ord(s[i - 1]) + 1:
                count += 1
            else:
                ans = max(ans, count)
                count = 1
        ans = max(ans, count)
        return ans
--


===============================================================================================================================================


-- Smallest Subarray with maximum bitwise


-- https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/5993622/easy-solution-bit-manipulation-beats-100/
-- youtube link - https://www.youtube.com/watch?v=PeouhGUGr7Q



--
from typing import List

class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        max_or_setbits = [-1] * 32
        ans = []

        for i in range(n - 1, -1, -1):
            cur = nums[i]
            pos = 0

            while cur:
                if cur & 1:
                    max_or_setbits[pos] = i
                cur //= 2
                pos += 1

            max_index = max(max_or_setbits)
            ans.append(max_index - i + 1 if max_index != -1 else 1)

        return ans[::-1]
--


===============================================================================================================================================


-- Deivide intervals into minimum number of groups



-- https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/
--


--
class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        start = [interval[0] for interval in intervals]
        start.sort()
        end = [interval[1] for interval in intervals]
        end.sort()
        
        ans = 0
        j = 0

        # if i > end[j] meaning the interval than ended and you can move j
        for i in start:
            if i > end[j]:
                j += 1
            else:
                ans += 1
        
        return ans
--


===============================================================================================================================================


-- Number of ways to reach a position after exactly k steps


--
-- https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/


--
class Solution:
    def numberOfWays1(self, startPos: int, endPos: int, target: int) -> int:
        MOD=1e9+7
        dp = {}

        def dfs(cur, k, endPos):
            if (cur, k) in dp:
                return dp[(cur, k)]

            if k == 0:
                return 1 if cur == endPos else 0
            dp[(cur, k)] = (dfs(cur + 1, k - 1, endPos) + dfs(cur - 1, k - 1, endPos)) % MOD
            return dp[(cur, k)]
        
        return int(dfs(startPos, target, endPos) % MOD)

    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:

        dist = endPos-startPos

        if k%2 != dist%2 or abs(dist) > k: return 0

        return comb(k, (dist+k)//2) %1_000_000_007
--


===============================================================================================================================================

-- Maximum rows covered by columns


-- https://leetcode.com/problems/maximum-rows-covered-by-columns/submissions/1440595770/
--


--
class Solution:
    def maximumRows(self, mat: List[List[int]], numSelect: int) -> int:
        
        # using Backtracking and recursion to solve this problem
        m = len(mat)
        n = len(mat[0])

        vis = [False] * n
        ans = 0

        def backtrack(index, cols, cur_cols):
            nonlocal ans
            if cols == cur_cols:
                count = 0
                for i in range(m):
                    flag = True
                    for j in range(n):
                        if mat[i][j] == 1 and not vis[j]:
                            flag = False
                            break
                
                    if flag:
                        count += 1
                ans = max(ans, count)
                return 

            if index >= n:
                return

            vis[index] = True
            backtrack(index + 1, cols, cur_cols + 1)
            vis[index] = False
            
            backtrack(index + 1, cols, cur_cols)
        
        backtrack(0, numSelect, 0)
        return ans
            



--


===============================================================================================================================================


-- Minimum amount of time to collect garbage


-- https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
--


--
class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        m = 0
        g = 0
        p = 0

        last_metal = 0
        last_paper = 0
        last_glass = 0

        for i, house in enumerate(garbage):
            a = house.count('M')
            b = house.count('P')
            c = house.count('G')

            m += a
            g += b
            p += c

            if a:
                last_metal = i
            if b:
                last_paper = i
            if c:
                last_glass = i
        
        # now calculate the total time taken to reach the last particular garbage index
        tm = sum(travel[:last_metal])
        tg = sum(travel[:last_glass])
        tp = sum(travel[:last_paper])

        return tm + tg + tp + m + p + g
--


==============================================================================================================================================

-- Amount of time for binary tree to be infected


--
-- https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/

--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:

        # first calculate the parent array for all the nodes so that the infections can travel in all directions

        adj = {}

        def parent_cal(node, parent):
            if not node:
                return
            
            if node.val not in adj:
                adj[node.val] = []

            if parent:
                adj[node.val].append(parent.val)
                adj[parent.val].append(node.val)

            parent_cal(node.left, node)
            parent_cal(node.right, node) 
        
        parent_cal(root, None)

        q = [start]
        cnt = 0
        vis = set([start])

        while q:
            for _ in range(len(q)):
                temp = q.pop(0)
                for node in adj[temp]:
                    if node not in vis:
                        vis.add(node)
                        q.append(node)
            if q:
                cnt += 1
        
        return cnt
        
--


============================================================================================================================================

-- Shifting letters 2 (Imp)


-- https://leetcode.com/problems/shifting-letters-ii/
--


--
class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        n = len(s)
        delta = [0] * (n + 1)
        
        for start, end, direction in shifts:
            # based on direction add and decrease
            if direction == 1:
                delta[start] += 1
                if end + 1 < n:
                    delta[end + 1] -= 1
            else:
                delta[start] -= 1
                if end + 1 < n:
                    delta[end + 1] += 1

        shift = 0
        result = []
        for i, char in enumerate(s):
            shift += delta[i]

            # the new character
            new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            result.append(new_char)
        
        return ''.join(result)
--


==========================================================================================================================================


-- Time needed to rearrange a binary string


-- https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/submissions/1440931000/
--


--
class Solution:
    def secondsToRemoveOccurrences1(self, s: str) -> int:
        seconds = 0
        while '01' in s:
            s = s.replace('01', '10')
            seconds += 1
        return seconds

    def secondsToRemoveOccurrences(self, s: str) -> int:
        steps, zeroes = 0, 0
        for ch in s:
            if ch == '0':
                zeroes += 1
            elif zeroes > 0:
                # Increment steps after counting the necessary steps for '0's before '1'
                steps = max(steps + 1, zeroes)
        return steps

        
--

=======================================================================================================================================


-- Construct smallest number from di string


-- https://leetcode.com/problems/construct-smallest-number-from-di-string/
--


--
class Solution:
    def smallestNumber(self, pattern: str) -> str:
        stack = []
        result = []
        
        for i in range(len(pattern) + 1):
            stack.append(str(i + 1))
            
            if i == len(pattern) or pattern[i] == 'I':
                while stack:
                    result.append(stack.pop())
        
        return ''.join(result)
--

======================================================================================================================================

-- Node with highest edges score


--
-- https://leetcode.com/problems/node-with-highest-edge-score/description/


--
class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        temp = [0] * n

        for i in range(n):
            temp[edges[i]] += i

        return temp.index(max(temp))
--


=======================================================================================================================================


-- Longest ideal subsequence


-- https://leetcode.com/problems/longest-ideal-subsequence/
--


--
class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        x = [0] * 123
        for ch in s:
            i = ord(ch)
            x[i] = max(x[i - k:i + k + 1]) + 1
        return max(x)
--


=======================================================================================================================================

-- Check if there is a valid partiiton for the array


-- https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/
--

--
from collections import Counter

class Solution:
    def validPartition1(self, nums: List[int]) -> bool:
        memo = {}
        def can_partition(start):
            if start == len(nums):
                return True
            
            if start in memo:
                return memo[start]

            result = False
            
            # Check for subarray of length 2
            if start + 1 < len(nums) and nums[start] == nums[start + 1]:
                result = can_partition(start + 2)

            # Check for subarray of length 3 (equal elements)
            if not result and start + 2 < len(nums) and nums[start] == nums[start + 1] == nums[start + 2]:
                result = can_partition(start + 3)

            # Check for subarray of length 3 (consecutive increasing)
            if not result and start + 2 < len(nums) and nums[start] + 1 == nums[start + 1] and nums[start + 1] + 1 == nums[start + 2]:
                result = can_partition(start + 3)

            # Store the result in memo
            memo[start] = result
            return result
        return can_partition(0)
            
    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * (n + 1)
        dp[0] = True 

        for i in range(1, n + 1):
            # Check for last 2 elements
            if i >= 2 and nums[i - 1] == nums[i - 2]:
                dp[i] = dp[i] or dp[i - 2]

            # Check for last 3 elements (equal)
            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:
                dp[i] = dp[i] or dp[i - 3]

            # Check for last 3 elements (consecutive increasing)
            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 and nums[i - 2] == nums[i - 3] + 1:
                dp[i] = dp[i] or dp[i - 3]

        return dp[n]


--

=========================================================================================================================================


-- Check if there is a valid partition for the array


--
-- https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/


--
from collections import Counter

class Solution:
    def validPartition1(self, nums: List[int]) -> bool:
        memo = {}
        def can_partition(start):
            if start == len(nums):
                return True
            
            if start in memo:
                return memo[start]

            result = False
            
            # Check for subarray of length 2
            if start + 1 < len(nums) and nums[start] == nums[start + 1]:
                result = can_partition(start + 2)

            # Check for subarray of length 3 (equal elements)
            if not result and start + 2 < len(nums) and nums[start] == nums[start + 1] == nums[start + 2]:
                result = can_partition(start + 3)

            # Check for subarray of length 3 (consecutive increasing)
            if not result and start + 2 < len(nums) and nums[start] + 1 == nums[start + 1] and nums[start + 1] + 1 == nums[start + 2]:
                result = can_partition(start + 3)

            # Store the result in memo
            memo[start] = result
            return result
        return can_partition(0)
            


    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * (n + 1)
        dp[0] = True 

        # check for the condition eith subarray ending at index i
        for i in range(1, n + 1):
            # Check for last 2 elements
            if i >= 2 and nums[i - 1] == nums[i - 2]:
                dp[i] = dp[i] or dp[i - 2]

            # Check for last 3 elements (equal)
            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:
                dp[i] = dp[i] or dp[i - 3]

            # Check for last 3 elements (consecutive increasing)
            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 and nums[i - 2] == nums[i - 3] + 1:
                dp[i] = dp[i] or dp[i - 3]

        return dp[n]


--


========================================================================================================================================


-- Reachable nodes with restrictions


--
-- https://leetcode.com/problems/reachable-nodes-with-restrictions/solutions/6002020/using-bfs-beats-80/


--
from collections import defaultdict
class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:

        g = defaultdict(list)
        s = set(restricted)
        for u,v in edges:
            g[u].append(v)
            g[v].append(u)
        
        q = []
        q.append(0)
        vis = [False] * n
        vis[0] = True
        count = 0

        while q:
            temp = q.pop(0)
            count += 1

            for node in g[temp]:
                if node not in s and not vis[node]:
                    q.append(node)
                    vis[node] = True

        return count
--


======================================================================================================================================


-- Maximum number if groups entering a competition


-- https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
--


--
class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        n = len(grades)
        k = 0
        total_students = 0
        
        # find the maximum number of groups
        while total_students + (k + 1) <= n:
            k += 1
            total_students += k
        
        return k
        
--


==========================================================================================================================================


-- Make array zero by subtracting equal amounts


-- https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/
--


--
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        unique_elements = set(nums)
    
        # Remove zero as we only care about positive elements
        if 0 in unique_elements:
            unique_elements.remove(0)
            
        # The number of unique positive elements is the minimum number of operations
        return len(unique_elements)
--


===========================================================================================================================================

-- Equal row and column pairs


-- https://leetcode.com/problems/equal-row-and-column-pairs/submissions/1441938076/
--


--
from collections import defaultdict
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        # frequency count for rows
        m = defaultdict(int)
        cnt = 0
        
        for row in grid:
            m[str(row)] += 1
        
        for i in range(len(grid[0])):
            cols = []

            for j in range(len(grid)):
                cols.append(grid[j][i])
            cnt += m[str(cols)]
        return cnt
--


============================================================================================================================================

-- Number of zero filled subarrays

-- https://leetcode.com/problems/number-of-zero-filled-subarrays/
--


--
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:

        count = 0  # To store the total count of zero-filled subarrays
        current_zeros = 0  # To count the length of current contiguous zeros

        for num in nums:
            if num == 0:
                current_zeros += 1
                count += current_zeros
            else:
                current_zeros = 0  # Reset the zero count if a non-zero element is encountered

        return count
--


==============================================================================================================================================


-- Query kth smallest trimmed number


--
-- https://leetcode.com/problems/query-kth-smallest-trimmed-number/


--
class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        result = []
    
        for k, trim in queries:
            # Trim each number to the rightmost 'trim' digits
            trimmed_nums = [(num[-trim:], i) for i, num in enumerate(nums)]
            
            # Sort the trimmed numbers; Python's sort is stable, so it keeps original order for equal values
            trimmed_nums.sort()
            
            # Get the k-th smallest trimmed number's index (1-indexed query, so k-1)
            result.append(trimmed_nums[k - 1][1])
        
        return result
            
--


==============================================================================================================================================


-- Maximum number of pairs in array


-- https://leetcode.com/problems/maximum-number-of-pairs-in-array/description/
--


--
class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        m = {}
        def get_digit_sum(num):
            csum = 0

            while num > 0:
                temp = num % 10
                csum += temp
                num //= 10
            return csum

        ans = -1
        for num in nums:
            digits = get_digit_sum(num)

            if digits in m:
                ans = max(ans, m[digits] + num)
                m[digits] = max(m[digits], num)
            else:
                m[digits] = num
        return ans
        
--


=================================================================================================================================================

-- Maximum Number of pairs in an array


-- https://leetcode.com/problems/maximum-number-of-pairs-in-array/description/
--


--
class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        count = Counter(nums)
    
        # Step 2: Calculate pairs and leftovers
        pairs = 0
        leftovers = 0
        for value in count.values():
            pairs += value // 2       # Number of pairs for this number
            leftovers += value % 2     # Leftovers for this number
        
        # Step 3: Return result as an array [number of pairs, number of leftovers]
        return [pairs, leftovers]
        
--


=================================================================================================================================================

-- Move pices to obtain a string


-- https://leetcode.com/problems/move-pieces-to-obtain-a-string/
--


--
class Solution:
    def canChange(self, start: str, target: str) -> bool:
        n = len(start)
        i = j = 0
        while i < n or j < n:
            while i < n and start[i] == '_':
                i += 1
            while j < n and target[j] == '_':
                j += 1
            if n in (i, j):
                return i == j == n
            if start[i] != target[j]:
                return False
            if start[i] == 'L':
                if i < j:
                    return False
            else:
                if i > j:
                    return False
            i += 1
            j += 1
        return True
        
--

================================================================================================================================================


-- Smallest number in inifinite sets


-- https://leetcode.com/problems/smallest-number-in-infinite-set/description/
--


--
class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        diff = [abs(nums1[i]-nums2[i]) for i in range(len(nums1))]
        print(diff)
        bucket = Counter(diff)
        print(bucket)
        M = max(diff)
        k = k1+k2
        for j in reversed(range(1,M+1)):
            print(bucket[j])
            minus = min(k,bucket[j])
            bucket[j]-=minus
            bucket[j-1]+=minus
            print(bucket[j-1])
            k-=minus
            if k == 0:
                break
        return sum([count*(d**2) for d,count in bucket.items()])
--


================================================================================================================================================


-- The Latest time to catch a bus


-- https://leetcode.com/problems/the-latest-time-to-catch-a-bus/
--


--
class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        n, m, i = len(buses), len(passengers), 0

        buses.sort()
        passengers.sort()

        for t in buses:
            k = capacity 
            while k and i < m and passengers[i] <= t:
                k -= 1 
                i += 1 

        ans = t if k else passengers[i-1]

        for l in range(i-1,-1,-1):
            if ans == passengers[l]:
                ans -= 1 
            else:
                break 

        return ans 
--


===================================================================================================================================================


-- The latest time to catch a bus


-- https://leetcode.com/problems/the-latest-time-to-catch-a-bus/
--


--
class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        n, m, i = len(buses), len(passengers), 0

        buses.sort()
        passengers.sort()

        for t in buses:
            k = capacity 
            while k and i < m and passengers[i] <= t:
                k -= 1 
                i += 1 

        ans = t if k else passengers[i-1]

        for l in range(i-1,-1,-1):
            if ans == passengers[l]:
                ans -= 1 
            else:
                break 

        return ans 
--


==================================================================================================================================================

-- Evaluate Boolean binary tree


-- https://leetcode.com/problems/evaluate-boolean-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(node):

            if not node.left and not node.right:
                return bool(node.val)
            
            left = dfs(node.left) if node.left else False
            right = dfs(node.right) if node.right else False

            if node.val == 2:
                return left | right
            else:
                return left & right
            return False
        
        return True if dfs(root) else False
            
--


====================================================================================================================================================


-- Number if people aware of a secret


-- https://leetcode.com/problems/number-of-people-aware-of-a-secret/
--


--
class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        mod = 10**9 + 7  # Common modulus for competitive programming
        dp = [0] * (n + forget + 1)  # Dynamic programming array sized for necessary days
        dp[1] = 1  # Day 1 starts with 1 person knowing the secret

        for i in range(1, n + 1):
            # From day i + delay to min(i + forget, n + forget)
            for j in range(i + delay, min(i + forget, n + 1)):
                dp[j] = (dp[j] + dp[i]) % mod

        # Count the people who still know the secret by day n
        ans = 0
        for j in range(max(1, n - forget + 1), n + 1):
            ans = (ans + dp[j]) % mod

        return ans

--


=====================================================================================================================================================


-- Spiral matrix 4


-- https://leetcode.com/problems/spiral-matrix-iv/
--

--
from typing import List, Optional

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        top = 0
        right = n - 1
        bottom = m - 1
        left = 0 

        # Initialize the matrix with -1
        mat = [[-1] * n for _ in range(m)]
        temp = head

        # Fill the matrix in a spiral order
        while top <= bottom and left <= right and temp:
            # Traverse from left to right along the top boundary
            for i in range(left, right + 1):
                if temp:
                    mat[top][i] = temp.val
                    temp = temp.next
            top += 1

            # Traverse from top to bottom along the right boundary
            for i in range(top, bottom + 1):
                if temp:
                    mat[i][right] = temp.val
                    temp = temp.next
            right -= 1

            # Traverse from right to left along the bottom boundary
            for i in range(right, left - 1, -1):
                if temp:
                    mat[bottom][i] = temp.val
                    temp = temp.next
            bottom -= 1

            # Traverse from bottom to top along the left boundary
            for i in range(bottom, top - 1, -1):
                if temp:
                    mat[i][left] = temp.val
                    temp = temp.next
            left += 1

        return mat

--


======================================================================================================================================================


