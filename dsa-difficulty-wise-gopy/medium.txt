
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================


-- Accounts merge


-- https://leetcode.com/problems/accounts-merge/submissions/1400878057/
--

--
from collections import defaultdict

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        g = defaultdict(list)

        for i, account in enumerate(accounts):
            for j in range(1, len(account)):

                email = account[j]
                g[email].append(i) # storing the index for the email 


        vis = [False] * len(accounts)


        def dfs(index, emails):
            if vis[index] == True:
                return
            vis[index] = True
            
            for j in range(1, len(accounts[index])):
                email = accounts[index][j]
                emails.add(email)
                for neighbor in g[email]:
                    if not vis[neighbor]:
                        dfs(neighbor, emails)



        res = []
        for i, account in enumerate(accounts):
            if not vis[i]:
                name = account[0]
                emails = set()
                dfs(i, emails)
                res.append([name] + sorted(emails))
        
        return res

        
--


===============================================================================================================


--  Remove comments


--
--


--
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:

        res = []
        n = len(source)
        block_comment = False

        new_line = ""
        
        for char_arr in source:
            i = 0

            if not block_comment:
                new_line = ""

            while i < len(char_arr):

                if not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '*':
                    block_comment = True
                    i = i + 2
                
                elif block_comment and i + 1 < len(char_arr) and char_arr[i] == '*' and char_arr[i + 1] == '/':
                    block_comment = False
                    i = i + 2

                elif not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '/':
                    break
                
                elif not block_comment:
                    new_line += char_arr[i]
                    i = i + 1

                # if the block_comment is True
                else:
                    i += 1
                
            if not block_comment and new_line:
                res.append(new_line)
            
        
        return res
        return "".join(res)            
--


===================================================================================================================

-- Split Linked list in Parts


--
-- https://leetcode.com/problems/split-linked-list-in-parts/


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        total_nodes = 0
        current = head
        while current:
            total_nodes += 1
            current = current.next
        
        # Step 2: Calculate the base size of each part and the extra nodes
        base_size = total_nodes // k
        extra_nodes = total_nodes % k
        
        # Step 3: Split the list
        parts = []
        current = head
        for i in range(k):
            part_size = base_size + (1 if i < extra_nodes else 0)  # Calculate the size of the current part
            if part_size == 0:
                parts.append(None)  # If the part size is 0, append None
            else:
                part_head = current
                for j in range(part_size - 1):
                    if current:
                        current = current.next
                next_part = None
                if current:
                    next_part = current.next
                    current.next = None  # Break the list

                parts.append(part_head) # important code which is used to get the list in linked lists to array
                current = next_part  # Move to the next part
        
        return parts
--


==============================================================================================================================


-- My Calender I


--
-- https://leetcode.com/problems/my-calendar-i/


--
class MyCalendar:
    def __init__(self):
        # Initialize an empty list to store the events
        self.events = []

    def book(self, start: int, end: int) -> bool:
        # Iterate over the list of events
        for event_start, event_end in self.events:
            # Check if the new event overlaps with an existing event
            if not (end <= event_start or start >= event_end):
                # If there is an overlap, return False (booking fails)
                return False
        # If no overlap is found, add the event to the calendar
        self.events.append((start, end))
        # Return True indicating successful booking
        return True

--


===================================================================================================================


-- NUMBER OF BURGERS with no waste of ingrediants


-- https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/solutions/4840518/easy-beginner-friendly-solution-in-cpp-0ms-beats-100-0-1-solution/
--


--class Solution:
    def numOfBurgers(self, to: int, ch: int) -> List[int]:

        if ch > to:
            return []
        else:
            if (to > ch * 4) and (to < ch * 2):
                return []
            else:
                if to % 2 == 0:
                    x = to - (2 * ch)
                    y = x // 2
                    z = ch - y
                    return [y, z]
                
                else:
                    return []
--


=======================================================================================================================


-- Count the servers that communicate


-- https://leetcode.com/problems/count-servers-that-communicate/
--


--
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        row = [0] * m
        col = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row[i] += 1
                    col[j] += 1
        
        res = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] and (row[i] > 1 or col[j] > 1):
                    res += 1
        
        return res
        
--

==============================================================================================================================


-- Search Suggestions


-- https://leetcode.com/problems/search-suggestions-system/
--

--class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()

        prefix = ""
        res = []

        for i in searchWord:
            prefix += i
            suggestions = []

            for j in range(len(products)):
                if products[j].startswith(prefix):
                    suggestions.append(products[j])
                    if len(suggestions) == 3:
                        break
            
            res.append(suggestions)
        
        return res
--

====================================================================================================================


-- Count squares submatrices with all ones


-- https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/
--

-
class Solution:
    def countSquares(self, mp: List[List[int]]) -> int:
        m = len(mp)
        n = len(mp[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        total_squares = 0

        for i in range(m):
            for j in range(n):

                if mp[i][j] == 1:
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                total_squares += dp[i][j]
        
        return total_squares
-


=============================================================================================================================


-- Group the people given the group size


-- https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
--


--
from collections import defaultdict

class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        m = defaultdict(list)

        for i, num in enumerate(gs):
            m[num].append(i)

        res = []
        for group_size, people in m.items():
            for i in range(0, len(people), group_size):
                res.append(people[i: i + group_size])

        return res

--


==========================================================================================================================

-- Find the smallest divisor given a threshold


-- https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
--

--
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left = 1  # Smallest divisor should start from 1
        right = max(nums)  # Largest possible divisor can be the maximum element in the array

        def check(num):
            csum = 0
            for i in nums:
                csum += ceil(i / num)  # Use ceil to simulate rounding up the division result
            return csum

        ans = float("inf")
        while left <= right:
            mid = (left + right) // 2

            if check(mid) > threshold:
                left = mid + 1
            else:
                ans = min(ans, mid)
                right = mid - 1
        
        return ans
--


============================================================================================================================

-- Remove covered intervals


-- https://leetcode.com/problems/remove-covered-intervals/
--


--
class Solution:
    def removeCoveredIntervals(self, inter: List[List[int]]) -> int:
        cnt = 0
        inter.sort(key=lambda x:(x[0], -x[1]))

        ending_time = 0

        for i in range(len(inter)):
            if ending_time < inter[i][1]:
                cnt += 1
                ending_time = inter[i][1]

        return cnt
--


==========================================================================================================================


-- Sequential digits


-- https://leetcode.com/problems/sequential-digits/
--



--
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:

        num = "123456789"
        res = []

        for length in range(2, 10):
            for start in range(0, 10 - length): # the range is from 0 to 10 - length because the we will be adding length
                number = int(num[start: start + length])

                if low <= number <= high:
                    res.append(number)
        return sorted(res)
--

=======================================================================================================================


-- Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-- https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/1404694299/
--


--
from typing import List

class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize prefix sum matrix
        prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        # Build prefix sum matrix
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # This function gets the sum of the square from (i, j) to (i + k - 1, j + k - 1)
        def get_sum(i, j, k):
            return prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]

        left = 0
        right = min(m, n)
        ans = 0

        # Binary search for the maximum possible square length
        while left <= right:
            mid = (left + right) // 2
            found = False

            # Check for any valid square of side length 'mid'
            for i in range(m - mid + 1):
                for j in range(n - mid + 1):
                    if get_sum(i, j, mid) <= threshold:
                        found = True
                        break
                if found:
                    break

            if found:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1

        return ans

--

=============================================================================================================================

-- Divide Array in Sets of K consecutive numbers

  
-- https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/submissions/1404733179/
--


--
from collections import defaultdict

class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        nums.sort()
        m = defaultdict(int)

        for i in nums:
            m[i] += 1

        for num in nums:
            if m[num] > 0:
                for j in range(num, num + k):
                    if m[j] == 0:
                        return False
                    m[j] -= 1

        return True
--


=================================================================================================================================

-- Maximum Number of Occurances of a substring


-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/
-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/1404853330/


--
from collections import defaultdict
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        string_count = defaultdict(int)
        ans = 0
        for i in range(len(s) - minSize + 1):
            string = s[i : i + minSize]
            unique_string = set(string)
            
            # since the length is used you can use length to get the maximum unique letters
            if len(unique_string) <= maxLetters:
                string_count[string] += 1
                ans = max(ans, string_count[string])

        return ans
--



===============================================================================================================================

-- Sum of Mutated Array Closest to Target


-
- https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/description/

--
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:        
        
        arr.sort()

        prefix_sum = [0]
        for num in arr:
            prefix_sum.append(prefix_sum[-1] + num)

        def helper(arr, value):
            left, right = 0, len(arr) - 1

            while left <= right:
                mid = (left + right)// 2

                if arr[mid] > value:
                    right = mid - 1
                else:
                    left = mid + 1
                
            return left


        left = 0
        right = max(arr)
        closest_sum_diff = float('inf')
        best_value = right

        while left <= right:
            mid = (left + right) // 2

            index = helper(arr, mid)

            # get the total sum after replacing the number with the mid
            curr_sum = prefix_sum[index] + (len(arr) - index) * mid
            diff = abs(curr_sum - target)

            if diff < closest_sum_diff or (diff == closest_sum_diff and mid < best_value):
                best_value = mid
                closest_sum_diff = diff
            
            if curr_sum < target:
                left = mid + 1
            else:
                right = mid - 1

        
        return best_value
--

===============================================================================================================================

-- Deepest leaves sum


-- https://leetcode.com/problems/deepest-leaves-sum/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:

        # returning the array with depth and the node
        def dfs(node, depth):
            if not node:
                return (0, 0)

            if not node.left and not node.right:
                return (node.val, depth)
            
            left = dfs(node.left, depth + 1)
            right = dfs(node.right, depth + 1)

            if left[1] > right[1]:
                return left
            elif right[1] > left[1]:
                return right
            else:
                return (left[0] + right[0], left[1])
        
        return dfs(root, 0)[0]
--


=============================================================================================================================


-- all elements in two binary search trees


-- https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def dfs(node, arr):
            if not node:
                return None

            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)

            return arr
        
        arr1, arr2 = [], []
        arr1 = dfs(root1, arr1) if root1 else []
        arr2 = dfs(root2, arr2) if root2 else []

        i = 0
        j = 0
        ans = []
        n = len(arr1)
        m = len(arr2)

        while i < n and j < m:
            if arr1[i] <= arr2[j]:
                ans.append(arr1[i])
                i += 1
            else:
                ans.append(arr2[j])
                j += 1
        
        ans.extend(arr1[i:])
        ans.extend(arr2[j:])
        
        return ans
        
            
        
--


==========================================================================================================================

-- Jump game 3


-- https://leetcode.com/problems/jump-game-iii/submissions/1405149002/
--


--
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        # Using queue and BFS to get the solution since you can jump to i - arr[i] or i + arr[i]


        q = []
        q.append(start)
        vis = [0] * len(arr)
        n = len(arr)

        while q:

            index = q.pop(0)

            vis[index] = 1
 
            if arr[index] == 0:
                return True

            left = index - arr[index]

            if left >= 0 and not vis[left]:
                q.append(left)
            
            right = index + arr[index]
            if right < n and not vis[right]:
                q.append(right)
        
        return False
--


==============================================================================================================================


-- Xor queries of a subarrya


-- https://leetcode.com/problems/xor-queries-of-a-subarray/
--

--
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        prefix = [0] * (len(arr) + 1)

        for i in range(1, len(arr) + 1):
            prefix[i] = prefix[i - 1] ^ arr[i - 1]

        result = []
        for left, right in queries:
            result.append(prefix[left] ^ prefix[right + 1])
        
        return result
        
--


============================================================================================================================

-- Subarray with given sum


-- https://www.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1?page=1&sortBy=submissions
--


-
class Solution:
    def subArraySum(self,arr, n, s): 
       #Write your code 
       
        left = 0
       
        for right in range(n):
           
            cur_sum += arr[right]
           
            if cur_sum == s:
                return [left + 1, right + 1]
           
            while cur_sum > s and left <= right:
                cur_sum -= arr[left]
                left += 1
            
            if cur_sum == s and s != 0:
                return [left + 1, right + 1]
        
        return [-1]
-


======================================================================================================================

-- Get watched by your friends


-- https://leetcode.com/problems/get-watched-videos-by-your-friends/
--

--
class Solution:
    def watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, level: int) -> List[str]:

        q = []

        # node and the depth
        q.append((id, 0))
        vis = [0] * len(w)
        vis[id] = 1
        res = []

        while q:
            node, cur_level = q.pop(0)

            if cur_level == level:
                res.append(node)
            elif cur_level < level:
                for i in f[node]:
                    if not vis[i]:
                        vis[i] = 1
                        q.append((i, cur_level + 1))
        
        m = {}
        
        # Count the frequency of videos watched by friends at the target level
        for index in res:
            for v in w[index]:
                if v in m:
                    m[v] += 1
                else:
                    m[v] = 1

        return sorted(m.keys(), key=lambda x: (m[x], x))

            

        
--

========================================================================================================================


-- Matrix block sum


-- https://leetcode.com/problems/matrix-block-sum/
--


--
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        # Step 1: Build prefix sum array with extra row and column
        prefix = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # Step 2: Calculate the block sum using the prefix sum
        def get_sum(r1, c1, r2, c2):
            r1, c1 = max(0, r1), max(0, c1)  # handle boundaries
            r2, c2 = min(m, r2), min(n, c2)  # handle boundaries
            return prefix[r2][c2] - prefix[r1][c2] - prefix[r2][c1] + prefix[r1][c1]

        result = [[0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                r1, c1 = i - k, j - k
                r2, c2 = i + k + 1, j + k + 1
                result[i][j] = get_sum(r1, c1, r2, c2)

        return result

--

============================================================================================================================


-- Sum of nodes with even values grandparent


-- https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
--


--
    def sumEvenGrandparent(self, root: TreeNode) -> int:

        def dfs(node, par, grand_par):
            if not node:
                return 0

            sum_of_nodes = 0

            if grand_par and grand_par % 2 == 0:
                sum_of_nodes += node.val
            
            sum_of_nodes += dfs(node.left, node.val, par)
            sum_of_nodes += dfs(node.right, node.val, par)

            return sum_of_nodes
        
        return dfs(root, None, None)
--

===========================================================================================================================


-- Minimum flips to make a or b equal to c


-- https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/submissions/1405746911/
--


--
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        flips = 0

        for i in range(32):
            bit_a = (a >> i) & 1
            bit_b = (b >> i) & 1
            bit_c = (c >> i) & 1

            if bit_c == 1:
                if bit_a == 0 and bit_b == 0:
                    flips += 1 
            else:
                if bit_a == 1:
                    flips += 1
                if bit_b == 1:
                    flips += 1

        return flips

--


========================================================================================================================

-- Print words vertically


-- https://leetcode.com/problems/print-words-vertically/
--

--
class Solution:
    def printVertically(self, s: str) -> List[str]:
        split_arr = s.split()
        max_str_len = max(len(word) for word in split_arr)


        res = []

        i = 0
        while i < max_str_len:
            string_len = ""

            for word in split_arr:
                if i < len(word):
                    string_len += word[i]
                else:
                    string_len += " "
            res.append(string_len.rstrip())
            i += 1

        return res     
--


============================================================================================================================

-- Delete leaves with a given value


-- https://leetcode.com/problems/delete-leaves-with-a-given-value/
--


--
class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        temp = root

        def dfs(node, target):

            if not node:
                return None

            node.left = dfs(node.left, target)
            node.right = dfs(node.right, target)

            if not node.left and not node.right and node.val == target:
                return None
            return node
        
        return dfs(root, target)
--

===========================================================================================================================

-- break a Palindrome (Important)


-- https://leetcode.com/problems/break-a-palindrome/description/
--


--
class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n <= 1:
            return ""

        # Traverse the string untill the half length 
        # if the character is "a" is not found at that position, replace and return
        # else if all the characters are "a" then replace the last element with next character "b"

        res = list(palindrome)

        for i in range(len(res) // 2):
            if palindrome[i] != 'a':
                res[i] = 'a'
                return "".join(res)
        
        res[-1] = 'b'
        return "".join(res)
--


=====================================================================================================================


-- Sort the matrix diagonally


-- https://leetcode.com/problems/sort-the-matrix-diagonally/
--


--
from collections import defaultdict

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:

        diagonals = defaultdict(list)
        
        m, n = len(mat), len(mat[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i - j has the same slope for diagonal elements
        for i in range(m):
            for j in range(n):
                heapq.heappush(diagonals[i - j], mat[i][j])
        
        # Step 2: Replace matrix elements with the sorted diagonal elements from the heap
        for i in range(m):
            for j in range(n):
                mat[i][j] = heapq.heappop(diagonals[i - j])
        
        return mat
--


===============================================================================================================================


-- Filter restaurents by vegan friendly price and distance


-- https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/submissions/1405999741/
--


--
class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        n = len(restaurants)
        res = []
        for i in range(n):
            if (veganFriendly == 0 or restaurants[i][2] == veganFriendly) and restaurants[i][3] <= maxPrice and restaurants[i][4] <= maxDistance:
                res.append((restaurants[i][1], restaurants[i][0]))

        res.sort(reverse=True,key=lambda x:(x[0], x[1]))

        return [v for u, v in res]
--


===========================================================================================================================

-- Reduce array size to the half


-- https://leetcode.com/problems/reduce-array-size-to-the-half/
--


--
from heapq import heappop, heappush
from collections import defaultdict
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        m = defaultdict(int)

        n = len(arr)

        for i in range(n):
            m[arr[i]] += 1
        
        # m now has the freqeuncy array
        m = sorted(m.values(), reverse=True)
        cnt = 0
        removed_el = 0

        # iterate through the frequency array reduce that frequency amount and increment the count
        for i in m:
            removed_el += i
            cnt += 1

            if removed_el >= n // 2:
                break

        return cnt
            
--


==================================================================================================================================

-- Maximum prodcut of splitted binary tree


-- https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7  # To return the result modulo 10^9 + 7
        total_sum = 0  # To store the total sum of the tree
        max_product = 0  # To store the maximum product

        # First, get the total sum of the entire tree
        def get_total_sum(node):
            if not node:
                return 0
            return node.val + get_total_sum(node.left) + get_total_sum(node.right)

        # Second, calculate the max product by finding each subtree's sum
        def get_subtree_sum(node):
            nonlocal max_product
            if not node:
                return 0

            # Get the sum of the current subtree
            left_sum = get_subtree_sum(node.left)
            right_sum = get_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # Calculate product of splitting the tree at this subtree
            max_product = max(max_product, (total_sum - subtree_sum) * subtree_sum)

            return subtree_sum

        # Step 1: Calculate the total sum of the tree
        total_sum = get_total_sum(root)

        # Step 2: Traverse again to calculate the max product
        get_subtree_sum(root)

        # Return the maximum product modulo 10^9 + 7
        return max_product % MOD
--


===================================================================================================================================


-- Number of subarrys of size k and average greater than or equal to threshold


-- https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
--


--
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        n = len(arr)
        left = 0
        right = 0
        cur_sum = 0
        cnt = 0

        while right < n:
            cur_sum += arr[right]

            if right - left + 1 < k:
                right += 1
                continue
            else:
                if (cur_sum // k)  >= threshold:
                    cnt += 1
                
                cur_sum -= arr[left]
                
                right += 1
                left += 1 
        
        return cnt
            
        
--

===========================================================================================================================

-- Angle between hands of a clock


-- https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/submissions/1406105855/
--


--
from collections import defaultdict

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        map_s = defaultdict(int)
        map_t = defaultdict(int)
        n = len(s)
        m = len(t)
        i = 0
        j = 0

        while i < n or j < m:
            if i < n:
                map_s[s[i]] += 1
            if j < n:
                map_t[t[i]] += 1
            i += 1
            j += 1
        

        cnt = 0

        for char in map_s:
            if map_s[char] > map_t[char]:
                cnt += map_s[char] - map_t[char]

        return cnt       

        
--


====================================================================================================================


-- Tweet Counts per Frequency

-- https://leetcode.com/problems/tweet-counts-per-frequency/description/


--
--

============================================================================================================================


-- Maximum number of events that can be attended


-- https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
--


--
from heapq import heappush, heappop

class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        
        events.sort()
        n = len(events)

        current_day = 0
        event_count = 0
        i = 0

        heap = []

        while i < n or heap:
            
            # is not heap move the next available date of start date
            if not heap:
                current_day = events[i][0]
            
            # add all the events which is on the current day
            while i < n and events[i][0] <= current_day:
                heappush(heap, events[i][1])
                i += 1
            
            # Remove events from the heap that have already ended
            while heap and heap[0] < current_day:
                heappop(heap)

            if heap:
                heappop(heap)
                event_count += 1
        
            current_day += 1

        return event_count

            

        
--


=============================================================================================================================


-- Number of substrings containing all three characters


--
--

--
from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        char_count = defaultdict(int)
        n = len(s)

        i = 0
        j = 0
        k = 3
        cnt = 0
        
        while j < n:
            char_count[s[j]] += 1

            while len(char_count) == 3:

                cnt += len(s) - j
                char_count[s[i]] -= 1

                if char_count[s[i]] == 0:
                    del char_count[s[i]]
                i += 1
            j += 1
        
        return cnt

--


==============================================================================================================================

-- Validate binary tree nodes

-- https://leetcode.com/problems/validate-binary-tree-nodes/
--


--
class Solution:
    def validateBinaryTreeNodes(self, n: int, left: List[int], right: List[int]) -> bool:

        indegree = [0] * n

        i = 0

        while i < n:
            if left[i] != -1:
                indegree[left[i]] += 1
            if right[i] != -1:
                indegree[right[i]] += 1

            i += 1

        # root count should be equal to 1 if not return False
        root_count = 0
        root = -1
        for i in range(n):
            if indegree[i] == 0:
                root_count += 1
                root = i
        
        # If there's not exactly one root, it's not a valid binary tree
        if root_count != 1:
            return False
        
        vis = [0] * n
        cycle = True
        def dfs(node, vis):
            nonlocal cycle
            if node == -1:
                return

            if vis[node]: # there is a cycle in the binary tree
                cycle = False
                return 

            vis[node] = 1

            dfs(left[node], vis)
            dfs(right[node], vis)

        # dfs to check all the nodes to be connected or not
        dfs(root, vis)
        return all(vis) and cycle
    
        
--


==========================================================================================================================

-- Closest divisers 


-- https://leetcode.com/problems/closest-divisors/submissions/1407425844/
--



--
import math
class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        
        def find_closest_product(n):
            for i in range(int(math.sqrt(n)), 0, -1):
                if n % i == 0:
                    return [i, n // i]

        num1_divisor = find_closest_product(num + 1)
        num2_divisor = find_closest_product(num + 2)

        if abs(num1_divisor[0] - num1_divisor[1]) > abs(num2_divisor[0] - num2_divisor[1]):
            return num2_divisor
        else:
            return num1_divisor
        
--


====================================================================================================================================


-- Rank team by votes  (Imp)


-- https://leetcode.com/problems/rank-teams-by-votes/submissions/1407807178/
--


--
class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        
        teams = len(votes[0])
        d = {}

        for vote in votes:
            for i, char in enumerate(vote):
                if char not in d:
                    d[char] = [0] * len(vote)
                d[char][i] += 1

        voted_name = sorted(d.keys())
        print(voted_name, d)

        return "".join(sorted(voted_name, key=lambda x:d[x], reverse=True))
--


================================================================================================================================

-- Linked list in a binary tree


-- https://leetcode.com/problems/linked-list-in-binary-tree/
--


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        def dfs(listnode, treenode):
            if not listnode:  # If we've reached the end of the list, it's a match
                return True
            if not treenode:  # If the tree node is None, no match
                return False
            if listnode.val != treenode.val:  # If values don't match, return False
                return False
            # Recursively check both left and right subtrees
            return dfs(listnode.next, treenode.left) or dfs(listnode.next, treenode.right)


        if not root:
            return False
        
        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

--


==================================================================================================================


-- Find the longest substring containing vowels in even counts (Imp)


-- https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/
--


--
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # Map vowels to their bit positions
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        
        # Bitmask to track the parity of vowel counts
        bitmask = 0
        
        # Dictionary to store the first occurrence of each bitmask
        position_map = {0: -1}
        
        # Variable to store the maximum length of the valid substring
        max_len = 0
        
        for i, char in enumerate(s):
            # If the character is a vowel, flip the corresponding bit
            if char in vowels:
                bitmask ^= vowels[char]
            
            # If the current bitmask has been seen before
            if bitmask in position_map:
                # Update max_len with the distance between current index and previous occurrence of the same bitmask
                max_len = max(max_len, i - position_map[bitmask])
            else:
                # Otherwise, store the first occurrence of this bitmask
                position_map[bitmask] = i
        
        return max_len

--


========================================================================================================================

-- Longest zig zag path in a binary tree


-- https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
--


--
class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def traverse(node, cnt, prev):
            nonlocal ans
            if not node:
                ans = max(ans, cnt)
                return
            if prev:
                traverse(node.left, cnt+1, 0)
                traverse(node.right, 0, 1)
            else:
                traverse(node.right, cnt+1, 1)
                traverse(node.left, 0, 0)
        traverse(root.left, 0, 0)
        traverse(root.right, 0, 1)
        return ans
--


=====================================================================================================================

-- Number of times binary string is prefix aligned


-- https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/
--


--
class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        max_flipped = 0

        cnt = 0

        for i, flip in enumerate(flips, 1): # 1 at the end make it 1 index
            max_flipped = max(max_flipped, flip)

            if max_flipped == i:
                cnt += 1
        
        return cnt
--


=============================================================================================================================
-- Time needed to inform all employees


-- https://leetcode.com/problems/time-needed-to-inform-all-employees/
--


--
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        
        # construct the graph from the given node

        g = defaultdict(list)

        for i, emp in enumerate(manager):
            if emp != -1:
                g[emp].append(i)
    

        def dfs(node):
            if node not in g:
                return 0
            max_time = 0

            for i in g[node]:
                max_time = max(dfs(i), max_time)
            return max_time + informTime[node]



        return dfs(headID)
--


=================================================================================================================================

-- Balanace a binary tree


-- https://leetcode.com/problems/balance-a-binary-search-tree/submissions/1409087547/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        # for the bst given get eh elements in the binary search tree to an array through inorder traversal
        # get the root and the left part comes to the left side and right part comes to right side of the root

        arr = []

        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            arr.append(node.val)
            inorder(node.right)

        inorder(root)

        def dfs(left, right):
            if left > right:
                return None

            mid = (left + right) // 2

            node = TreeNode(arr[mid])

            node.left = dfs(left, mid - 1)
            node.right = dfs(mid + 1, right)

            return node

        
        return dfs(0, len(arr) - 1)

--


=============================================================================================================================



-- Cinema seat allocation


--
--


--
class Solution:
	def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
		seats = collections.defaultdict(set)

		for i,j in reservedSeats:
			if j in [2,3,4,5]:
				seats[i].add(0)
			if j in [4,5,6,7]:
				seats[i].add(1)
			if j in [6,7,8,9]:
				seats[i].add(2)
		res = 2*n
		for i in seats:
			if len(seats[i]) == 3:
				res -= 2
			else:
				res -= 1

		return res
--


==========================================================================================================================

-- Sort the integers by the power value


-- 
-- https://leetcode.com/problems/sort-integers-by-the-power-value/


--
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:

        def get_power_value(x):
            steps = 0

            while x > 1:
                if x % 2 == 0:
                    x = x // 2
                else:
                    x = x * 3 + 1
                steps += 1
            return steps

        res = []
        for i in range(lo, hi + 1):
            res.append((get_power_value(i), i))
        
        res.sort(key=lambda x:x[0])

        return res[k - 1][1]
            

        
--


==========================================================================================================================


-- Count the number of teams


-- https://leetcode.com/problems/count-number-of-teams/submissions/1409330184/
--


--
class Solution:
    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        if n < 3:
            return 0
        
        # Initialize arrays to count smaller and larger soldiers to the left and right
        left_smaller = [0] * n
        left_larger = [0] * n
        right_smaller = [0] * n
        right_larger = [0] * n
        
        # Calculate the left_smaller and left_larger for each soldier
        for i in range(n):
            for j in range(i):
                if rating[j] < rating[i]:
                    left_smaller[i] += 1
                elif rating[j] > rating[i]:
                    left_larger[i] += 1
        
        # Calculate the right_smaller and right_larger for each soldier
        for i in range(n):
            for j in range(i + 1, n):
                if rating[j] > rating[i]:
                    right_larger[i] += 1
                elif rating[j] < rating[i]:
                    right_smaller[i] += 1
        
        # Calculate the number of valid teams
        total_teams = 0
        for i in range(n):
            # Increasing triplets
            total_teams += left_smaller[i] * right_larger[i]
            # Decreasing triplets
            total_teams += left_larger[i] * right_smaller[i]
        
        return total_teams


        
--


==============================================================================================================================

-- Contruct k paindrome strings


-- https://leetcode.com/problems/construct-k-palindrome-strings/submissions/1409350280/
--


--
class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False

        n = len(s)
        m = {}
        
        for i in s:
            m[i] = m.get(i, 0) + 1
        
        # the frequency of the character is greter than k then it is impossible to form the palindromic string 
        # else it is true
        odd_count = sum(1 for count in m.values() if count % 2 != 0)

        return odd_count <= k 

        
--

=============================================================================================================================


-- Number of steps to reduce in binary representation to one



--
-- https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/


--
class Solution:
    def numSteps(self, s: str) -> int:
        steps = 0
        
        while s != "1":
            if s[-1] == "0":
                s = s[:-1]
            else:
                # convert the string to decimal increment and then convert back to binary eg "0b1110"
                s = bin(int(s, 2) + 1)[2:]
            steps += 1

        return steps
        
--

===============================================================================================================================


-- Longest happy string


-- https://leetcode.com/problems/longest-happy-string/submissions/1409397836/
--


--
from collections import Counter

class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        m = Counter({"a": a, "b": b, "c": c})
        res = ["#"]

        while True:
            (a1, count1), (a2, count2) = m.most_common(2)

            if a1 == res[-1] == res[-2]:
                a1 = a2 # if 2 char is already present in the response array just use the second character

            if not m[a1]:
                break
            res.append(a1)
            m[a1] -= 1
            
        
        return "".join(res[1:])
--


========================================================================================================================

-- Queries on a permutaion with key (Imp)



-- https://leetcode.com/problems/queries-on-a-permutation-with-key/
--


--
class Solution: 
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        result = []
        
        m = [x for x in range(1, m + 1)]
        
        for x in queries:
            result.append(m.index(x))  # get the index of the q
            m.remove(x) # remove the element from that index
            m.insert(0, x) # inser the element at the start
        
        return result
--


=============================================================================================================================


-- Html entity parser


-- https://leetcode.com/problems/html-entity-parser/
--


--
class Solution:
    def entityParser(self, text: str) -> str:
        m = {
            '&quot;': '"',
            '&apos;': '\'',
            '&amp;': '&',
            '&gt;': '>',
            '&lt;': '<',
            '&frasl;': '/'
        }

        # minlen = 6, maxlen = 4


        def checker(start):
            # Try to find the longest possible entity from the current position
            for length in range(4, 8):  # Entities have lengths between 4 and 6
                candidate = text[start:start + length]
                if candidate in m:
                    return m[candidate], length  # Return the entity replacement and its length
            return False, 1


        n = len(text)
        i = 0
        res = ""
        while i < n:

            if text[i] != "&":
                res += text[i]
                i += 1
            else:
                found, length = checker(i)
                if found:
                    res += found
                    i += length
                else:
                    res += text[i]
                    i += 1
        return res


        
--

============================================================================================================================


-- Find the minimum number of fibonacci whose sum is k



--
-- https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/submissions/1409497619/


--
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        
        # the idea here is to subtract from the largest fib from the end of the array

        fib = [1, 1]

        while fib[-1] <= k:
            fib.append(fib[-1] + fib[-2])
        
        index = len(fib) - 1
        cnt = 0

        while k > 0:
            if fib[index] <= k:
                k -= fib[index]
                cnt += 1
            index -= 1
        
        return cnt 



        
--


===========================================================================================================================


-- Four divisors


-- https://leetcode.com/problems/four-divisors/
--


--
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:

        def divisors(num):
            div = set()

            for i in range(1, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    div.add(i)
                    div.add(num // i)
            if len(div) == 4:
                
                return sum(div)
            return False
        
        n = len(nums)
        cnt = 0

        for i in range(n):
            c = divisors(nums[i])
            if c:
                cnt += c
        
        return cnt
--

======================================================================================================================================


-- Check if there is a Valid path in a grid


--
-- https://leetcode.com/problems/minimum-number-of-frogs-croaking/submissions/1409685642/


--
class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        c = r = o = a = k = 0
        frogs = 0 
        max_frogs = 0 

        for char in croakOfFrogs:
            if char == 'c':
                c += 1
                frogs += 1  # A new frog starts croaking
                max_frogs = max(max_frogs, frogs)  # Update maximum active frogs
            elif char == 'r':
                r += 1
                if r > c:
                    return -1  # More 'r' than 'c', invalid sequence
            elif char == 'o':
                o += 1
                if o > r:
                    return -1  # More 'o' than 'r', invalid sequence
            elif char == 'a':
                a += 1
                if a > o:
                    return -1  # More 'a' than 'o', invalid sequence
            elif char == 'k':
                k += 1
                if k > a:
                    return -1  # More 'k' than 'a', invalid sequence
                frogs -= 1 

        # After processing, all counts should be equal
        if c == r == o == a == k:
            return max_frogs
        else:
            return -1 
--


============================================================================================================================

-- Diagonal traversal



-- https://leetcode.com/problems/diagonal-traverse-ii/
--


--
from collections import defaultdict

class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        diagonals = defaultdict(list)
        
        m, n = len(nums), len(nums[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i + j has the same slope for diagonal elements
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                diagonals[i + j].append(nums[i][j])

        res = []
        # Step 2: Append elements in the order of diagonals
        for k in sorted(diagonals.keys()):
            res.extend(reversed(diagonals[k]))  # Reversed to maintain the correct diagonal order

        return res
--


===============================================================================================================================


-- Max diff you can get from changing an integer


-- https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/submissions/1410678378/
--


--
class Solution:
    def maxDiff(self, num: int) -> int:
        num_str = str(num)

        max_a = num_str
        for i in num_str:
            if i != "9":
                max_a = num_str.replace(i, "9")
                break
        
        max_a = int(max_a)


        min_b = num_str
        if min_b[0] != "1":
            min_b = min_b.replace(min_b[0], "1")
        else:
            for i in num_str[1:]:
                if i != "0" and i != "1":
                    min_b = num_str.replace(i, "0")
                    break
        min_b = int(min_b)
        return max_a - min_b

--


=============================================================================================================================


-- Check if a string can break another string


--
--


--
class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        count1 = [0] * 26
        count2 = [0] * 26
        
        for c in s1:
            count1[ord(c) - ord('a')] += 1
        for c in s2:
            count2[ord(c) - ord('a')] += 1
        
        s1_breaks_s2 = True
        s2_breaks_s1 = True
        
        cumulative_s1 = 0
        cumulative_s2 = 0
        
	# if the cumulative is less than the other it wont break the other
        for i in range(26):
            cumulative_s1 += count1[i]
            cumulative_s2 += count2[i]
            
            if cumulative_s1 < cumulative_s2:
                s1_breaks_s2 = False
            if cumulative_s2 < cumulative_s1:
                s2_breaks_s1 = False
        
        return s1_breaks_s2 or s2_breaks_s1

--


==============================================================================================================================

-- Check if a there is a valid path in agrid


--
--


--
from collections import deque

class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0])
        directions = {
            # in that [1, 4, 6] in the left the number can be 1, 4, 6
            1: [(0, -1, [1, 4, 6]), (0, 1, [1, 3, 5])], # in an array have two directions mentioned left and right ones
            2: [(-1, 0, [2, 3, 4]), (1, 0, [2, 5, 6])],  # Up, Down
            3: [(0, -1, [1, 4, 6]), (1, 0, [2, 5, 6])],  # Left, Down
            4: [(0, 1, [1, 3, 5]), (1, 0, [2, 5, 6])],   # Right, Down
            5: [(0, -1, [1, 4, 6]), (-1, 0, [2, 3, 4])], # Left, Up
            6: [(0, 1, [1, 3, 5]), (-1, 0, [2, 3, 4])]   # Right, Up
        }

        q = deque([(0, 0)])
        visited = set()
        visited.add((0, 0))

        while q:
            x, y = q.popleft()
            
            if x == m - 1 and y == n - 1:
                return True

            # in this going both sides
            for a, b, valid_types in directions[grid[x][y]]:
                nx = x + a
                ny = y + b

                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                    if grid[nx][ny] in valid_types:
                        q.append((nx, ny))
                        visited.add((nx, ny))

        
        return False

--


===============================================================================================================================


-- Circle and rectangle overlapping



-- https://leetcode.com/problems/circle-and-rectangle-overlapping/
--


--
class Solution:
    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        nearest_x = max(x1, min(x2, xCenter))
        nearest_y = max(y1, min(y2, yCenter))

        # Use Euclidean formula to get the Euclidean dist between circle and rectangle

        disx = nearest_x - xCenter
        disy = nearest_y - yCenter

        return disx ** 2 + disy ** 2 <= radius ** 2
--


===============================================================================================================================

-- The kth lexicographical string of all strings
of length k



-- https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/submissions/1411165093/
--


--
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        string = "abc"
        cnt = [0]
        res = []

        def backtrack(current, n):
            if len(current) == n:
                cnt[0] += 1
                if cnt[0] == k:
                    res.append(current)
                return
            
            for i in 'abc':
                if not current or current[-1] != i:
                    backtrack(current + i, n)
                
                    if res:
                        return
        
        backtrack("", n)
    
        # If we found the k-th happy string, return it, otherwise return an empty string
        return res[0] if res else ""



        
--

================================================================================================================================


-- Display table of food orders in a restaurant


-- https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/submissions/1411790865/
--


--
from typing import List

class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = []

        pre = [0] * n
        suf = [0] * n
        pre[0] = nums[0]
        suf[n - 1] = nums[n - 1]

        for i in range(1, n):
            pre[i] = pre[i - 1] + nums[i]

        for i in range(n - 2, -1, -1):
            suf[i] = suf[i + 1] + nums[i]

        for i in range(n):
            temp = (i + 1) * nums[i] - pre[i]
            temp += (suf[i] - (n - i) * nums[i])
            ans.append(temp)

        return ans

--


================================================================================================================================


-- Longest Continuous subarray with absolute diff less than or equal to limit (Neetcode) (Imp)


-- https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
--


--
from collections import defaultdict
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        # using monotonic queue to get the solution
        # Use 2 queues, max queue and min queue

        min_queue = deque() # monotonically increasing
        max_queue = deque() # monotonically decrease
        n = len(nums)

        left = 0
        right = 0
        res = 0

        for right in range(n):
            while min_queue and nums[right] < min_queue[-1]:
                min_queue.pop()

            while max_queue and nums[right] > max_queue[-1]:
                max_queue.pop()

            max_queue.append(nums[right])
            min_queue.append(nums[right])

            while max_queue[0] - min_queue[0] > limit:
                if nums[left] == max_queue[0]:
                    max_queue.popleft()
                if nums[left] == min_queue[0]:
                    min_queue.popleft()
                left += 1
            
            res = max(res, right - left + 1)
    
        return res
--


=============================================================================================================================


-- Build an array with stack


--
--


--
class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        stack = []
        current = 1

        for num in target:

            while current < num:
                stack.append("Push")
                stack.append("Pop")
                current += 1
            
            stack.append("Push")
            current += 1
        
        return stack
--

===============================================================================================================================

-- Simplified fractions



-- https://leetcode.com/problems/simplified-fractions/
--


--
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []

        res = set()
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                if j / i in res:
                    continue
                
                temp = str(j) + '/' + str(i)
                ans.append(temp)
                res.add(j / i)  # Add the fraction tuple to the set
        return ans
--


--
from math import gcd
from typing import List

class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []
        
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                # Check if the fraction is in its simplest form using GCD
                if gcd(j, i) == 1:
                    ans.append(f"{j}/{i}")
        
        return ans

--


============================================================================================================================



-- Count good nodes in binary tree


-- https://leetcode.com/problems/count-good-nodes-in-binary-tree/
--

--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:

        res = []

        def dfs(node, maximum):
            if not node:
                return 
            
            if node.val >= maximum:
                res.append(node.val)
            
            dfs(node.left, max(node.val, maximum))
            dfs(node.right, max(node.val, maximum))

            return maximum

        dfs(root, root.val)
        return len(res)
      
--

============================================================================================================================


-- People whose list of favorite companies is not a subset of another list


-- https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
--


--
class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        result = []

        favoriteSets = [set(arr) for arr in favoriteCompanies]   

        for i in range(len(favoriteSets)):
            isSubset = False
            for j in range(len(favoriteSets)):
                if i != j and favoriteSets[i].issubset(favoriteSets[j]):
                    isSubset = True
                    break
            if not isSubset:
                result.append(i)
        
        return sorted(result)     
--


================================================================================================================================

--  Count triplets that can form two arrays of equal xor


--
-- https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/


--
class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        n = len(arr)
        prefixXor = 0
        count = 0
        freq = {0: 1}
        total = {0: 0}
        
        for i in range(n):
            prefixXor ^= arr[i]
            
            if prefixXor in freq:
                count += freq[prefixXor] * i - total[prefixXor]
            
            freq[prefixXor] = freq.get(prefixXor, 0) + 1
            total[prefixXor] = total.get(prefixXor, 0) + i + 1
        
        return count
--


=======================================================================================================================================

-- Maximum number of vowels ina  substring


-- https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
--


--
from collections import defaultdict

class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        cnt = 0
        left = 0
        right = 0
        n = len(s)
        ans = 0

        while right < n:
            if s[right] in "aeiou":
                cnt += 1

            if right - left + 1 < k:
                right += 1

            elif right - left + 1 == k:
                ans = max(ans, cnt)
                
                if s[left] in "aeiou":
                    cnt -= 1

                left += 1
                right += 1

        return ans

--


=========================================================================================================================


-- Check if a string contains all binary codes of size k


-- https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/
--

-
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        unique_substrings = set()
        n = len(s)
        
        for i in range(n - k + 1):
            substring = s[i:i + k]
            unique_substrings.add(substring)
        
        total_binary_codes = 2 ** k
        
        # you can also check that if the len of unique substrings equal to total binary codes
        return len(unique_substrings) == total_binary_codes

-

=============================================================================================================================

-- Pseudo palindromic path in a binary tree


--
-- https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/


--
# Definition for a binary tree node.
# class TreeNode:k
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node:
                return 0
            
            path ^= (1 << node.val)
            
            if not node.left and not node.right:
                if path & (path - 1) == 0:
                    return 1
                else:
                    return 0
            
            return dfs(node.left, path) + dfs(node.right, path)
        
        return dfs(root, 0)
        
--


========================================================================================================================


-- Course schedule IV (Imp)


-- https://leetcode.com/problems/course-schedule-iv/
--


--
from collections import defaultdict, deque
from typing import List

class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        # Create a graph and indegree array
        g = defaultdict(list)
        indegree = [0] * numCourses

        # Build the graph and indegree array
        for u, v in prerequisites:
            g[u].append(v)
            indegree[v] += 1

        # Initialize the queue for topological sorting
        q = deque()
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)

        # Reachable nodes tracking
        reachable_array = defaultdict(set)

        topo_order = []
        # Perform topological sorting
        while q:
            temp = q.popleft()  # use popleft for O(1) complexity
            topo_order.append(temp)
            for node in g[temp]:
                indegree[node] -= 1
                if indegree[node] == 0:
                    q.append(node)

        # Propagate reachable nodes
        for course in topo_order:
            for neighbor in g[course]:
                reachable_array[neighbor].add(course)
                reachable_array[neighbor].update(reachable_array[course])

        # Check each query
        result = []
        for u, v in queries:
            result.append(u in reachable_array[v])

        #   reachable_array = {
        #       1: {0},        # Course 1 can be reached by course 0
        #       2: {0, 1},     # Course 2 can be reached by courses 0, 1
        #       3: {0, 1, 2},  # Course 3 can be reached by courses 0, 1, 2     
        #   }

        return result


--


============================================================================================================================


-- Maximum area of a piece of cake after horizontal and vertical cuts



-- https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/submissions/1412723062/
--


--
class Solution:
    def maxArea(self, h: int, w: int, hr: List[int], vr: List[int]) -> int:
        hr.sort()
        vr.sort()


        max_hr = max(hr[0], h - hr[-1]) # from the edges to first and last cit
        for i in range(1, len(hr)):
            max_hr = max(max_hr, hr[i] - hr[i - 1])
        
        max_vr = max(vr[0], w - vr[-1])
        for j in range(1, len(vr)):
            max_vr = max(max_vr, vr[j] - vr[j - 1])

        MOD = 10**9 + 7
        return (max_vr * max_hr) % MOD
      
--

===========================================================================================================================

-- Removing stars from a string


-- https://leetcode.com/problems/removing-stars-from-a-string/
--


--
class Solution:
    def removeStars(self, s: str) -> str:

        stack = []

        for i in range(len(s)):
            if s[i] == "*" and stack:
                stack.pop()
            elif s[i] != "*":
                stack.append(s[i])
        
        return "".join(stack)
--


===============================================================================================================================


-- Optimal partition of string


-- https://leetcode.com/problems/optimal-partition-of-string/
--


--
from collections import defaultdict
class Solution:
    def partitionString(self, s: str) -> int:
        cnt = 0
        m = {}

        for i in range(len(s)):
            if s[i] in m:
                cnt += 1
                m = {}
            m[s[i]] = m.get(s[i], 0) + 1
        
        return cnt + 1
--


=============================================================================================================================

-- Reorder to make all paths lead to the city zero



-- https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
--


--
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        adj = defaultdict(list)
    
        for a, b in connections:
            adj[a].append((b, 1))  # road from a to b needs to be reordered
            adj[b].append((a, 0))  # road from b to a is fine as it is
        
        def dfs(node, parent):
            changes = 0
            for neighbor, needs_reorder in adj[node]:
                if neighbor == parent:
                    continue
                changes += needs_reorder
                changes += dfs(neighbor, node)
            return changes
        
        return dfs(0, -1)
--


===============================================================================================================================


-- The k strongest values in a array


-- https://leetcode.com/problems/the-k-strongest-values-in-an-array/
--

--
class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        n =len(arr)
        median = arr[(n - 1) // 2]

        # Step 2: Sort the array based on strength
        arr.sort(key=lambda x: (abs(x - median), x), reverse=True)

        # Step 3: Return the first k strongest elements
        return arr[:k]
--


=========================================================================================================================


-- Find two non overlapping sub arrays each with target sum


-- https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/
--


--
class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        n = len(arr)
        inf = float('inf')
        
        min_len = [inf] * n        
        res = inf
        
        left = 0
        curr_sum = 0
        best_len = inf
        
        for right in range(n):
            curr_sum += arr[right]
            
            while curr_sum > target:
                curr_sum -= arr[left]
                left += 1
            
            # When a valid sub-array with sum equal to target is found
            if curr_sum == target:
                # checking if the subarray with sum equals target found before
                if left > 0 and min_len[left - 1] != inf:
                    # Get the length of the sub which was found before
                    res = min(res, min_len[left - 1] + (right - left + 1))
                
                # Update the best_len with the minimum length of sub-array found so far
                best_len = min(best_len, right - left + 1)
            
            min_len[right] = best_len
        
        return res if res != inf else -1
--


========================================================================================================================


-- Least number of unique integers after k removals


-- https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
--


--
from collections import defaultdict
class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        m = defaultdict(int)

        for i in arr:
            m[i] += 1
        
        sorted_list = sorted(m.values())
        cnt = len(sorted_list)

        for i in sorted_list:
            if i <= k:
                cnt -= 1
                k -= i
            else:
                break
        
        return cnt

        
--


===========================================================================================================================


-- Kth factor of n submissions



-- https://leetcode.com/problems/the-kth-factor-of-n/submissions/1412939794/
--

--
class Solution:
    def kthFactor(self, n: int, k: int) -> int:

        def divisors(num):
            div = []

            for i in range(1, num // 2 + 1):
                if num % i == 0:
                    div.append(i)
            div.append(num)
            return div
        
        arr = divisors(n)

        if len(arr) < k:
            return -1
        
        return arr[k - 1]
--

========================================================================================================================

-- Remove methods from projext


-- https://leetcode.com/contest/weekly-contest-418/problems/remove-methods-from-project/
--



--
from collections import defaultdict
class Solution:
    def remainingMethods(self, n: int, k: int, edges: List[List[int]]) -> List[int]:
        g = defaultdict(list)

        for u, v in edges:
            g[u].append(v)
        
        # from kth node traverse to all the neighbouring nodes and mark them as visited

        vis = [False] * n

        def dfs(node):
            if vis[node]: return
            vis[node] = True

            for neighbour in g[node]:
                    dfs(neighbour)
        
        # no we have marked all the suspicious edges or falty edges 
        dfs(k)

        # we now have to check if the non falty edges are connected to the visited ones if yes then take 
        # all the nodes from 0 to n - 1 else take only the ones that are non visited
        take_all = False
        for u, v in edges:
            if not vis[u] and vis[v]:
                take_all = True

        res = []
        for i in range(n):
            if take_all or not vis[i]:
                res.append(i)

        return res 
--


=======================================================================================================================

--  Construct 2d gird matching graph layout (Incomplete) (Imp)


-- https://leetcode.com/contest/weekly-contest-418/problems/construct-2d-grid-matching-graph-layout/
--

--
from collections import deque, defaultdict
from typing import List

class Solution:
    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        # Helper function to handle dimension and find path
        def handleDimension(adj):
            n = len(adj)
            src, dest = -1, -1
            
            for i in range(n):
                if len(adj[i]) > 1:
                    continue
                if src == -1:
                    src = i
                elif dest == -1:
                    dest = i
            
            if dest == -1:
                return []

            path = getPath(src, dest, adj)
            return path

        # BFS function to get path from src to dest
        def getPath(src, dest, adj):
            n = len(adj)
            
            def bfs(src):
                dist = [-1] * n
                from_node = [-1] * n
                q = deque([src])
                dist[src] = 0
                
                while q:
                    u = q.popleft()
                    
                    for v in adj[u]:
                        if dist[v] == -1:  # Not visited
                            dist[v] = dist[u] + 1
                            from_node[v] = u
                            q.append(v)
                
                return from_node
            
            from_node = bfs(src)
            path = []
            
            node = dest
            while node != -1:
                path.append(node)
                node = from_node[node]
            
            path.reverse()  # Reverse to get the path from src to dest
            return path

        # Build adjacency list
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        # Check for the edge case.
        path = handleDimension(adj)
        print(path)
        if path:
            return []

        # Find all corners (nodes with only 2 edges)
        corners = []
        for i in range(n):
            if len(adj[i]) == 2:
                corners.append(i)

        if len(corners) < 4:
            return []  # Not enough corners to form a grid

        # Find the minimum path size between corners
        paths_size = [
            len(getPath(corners[0], corners[1], adj)),
            len(getPath(corners[0], corners[2], adj)),
            len(getPath(corners[0], corners[3], adj))
        ]
        
        min_index = paths_size.index(min(paths_size))
        cols = paths_size[min_index]
        rows = n // cols
        
        # Fill the first row of the matrix
        ans = [[-1 for _ in range(cols)] for _ in range(rows)]
        ans[0] = getPath(corners[0], corners[min_index + 1], adj)

        # Fill the grid with remaining nodes
        for r in range(rows):
            for c in range(cols):
                # Find the neighbors that have already been placed.
                neighbors = set()
                if r > 0:
                    neighbors.add(ans[r-1][c])  # Above
                if c > 0:
                    neighbors.add(ans[r][c-1])  # Left
                
                # Place the neighbor that has not been placed yet.
                u = ans[r][c]
                for v in adj[u]:
                    if v not in neighbors:
                        ans[r][c] = v
                        break
        print(ans)
        return [[]]

--

=========================================================================================================================

-- Longest subarray of 1s after deleting one element 


-- https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/submissions/1413535232/
--


--
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        zero_count = 0
        max_len = 0
        n = len(nums)

        for right in range(n):
            if nums[right] == 0:
                zero_count += 1

            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            
            # right - left instead of right - left + 1 coz you are requried to delete one element in the array
            
            max_len = max(max_len, right - left)

        return max_len
--


============================================================================================================================


-- Number of subsequence that satify the given sum condition


-- https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/submissions/1413648296/
--


--
class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        # in a sorted array number of subsequence formed is 2^(j - i)
        # and the numbers between i and j can either be included or be excluded in the subsequence

        # if num[i] + num[j] <= target then we add 2^(j - i) to the count

        # if the num[i] + num[j] > target, then move j to left

        i = 0
        MOD = 10**9 + 7
        n = len(nums)
        j = n - 1
        nums.sort()

        power_of_two = [1] * n
        for i in range(1, n):
            power_of_two[i] = (power_of_two[i - 1] * 2) % MOD

        i =0
        cnt = 0
        while i <= j:
            if nums[i] + nums[j] <= target:
                cnt = (cnt + power_of_two[j - i]) % MOD
                i += 1
            else:
                j -= 1
        
        return cnt

        
--


=============================================================================================================================


-- Sentence Similarity III


--
-- https://leetcode.com/problems/sentence-similarity-iii/?envType=daily-question&envId=2024-10-06


--
class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        words1 = sentence1.split(" ")
        words2 = sentence2.split(" ")


        if len(words1) > len(words2):
            words1, words2 = words2, words1

        # Match words from the start and end
        i = 0
        while i < len(words1) and words1[i] == words2[i]:
            i += 1
        
        j = 0
        while j < len(words1) - i and words1[-(j+1)] == words2[-(j+1)]:
            j += 1
        
        # If the remaining middle part (if any) is matched, return True
        return i + j >= len(words1)

        
--


=============================================================================================================================


-- Append characters to string to make subsequence


-- https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/
--


--
from collections import defaultdict
class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        i = 0
        j = 0

        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                j += 1
            i += 1

        return len(t) - j
--

===========================================================================================================================


-- determine if two strings are close


-- https://leetcode.com/problems/determine-if-two-strings-are-close/submissions/1415047021/
--


--
from collections import defaultdict, Counter
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if set(word1) != set(word2):
            return False
        m1 = Counter(word1)
        m2 = Counter(word2)
        
        return sorted(m1.values()) == sorted(m2.values())
        
--


==========================================================================================================================



-- Minimum operations to reduce x to zero


--
-- https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/



--
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        # instead of removing from the ends we can frind out the middle ones which should not be considered
        # We need to find the maximum length subarray which sum equals sum(arr) - x
        target = sum(nums) - x
        if target < 0: # if target is less than 0 then x is greater than sum(arr)
            return -1
        if target == 0: # if x is qual to sum(arr) then return len(nums) 
            return len(nums)

        

        left = 0

        ans = -1
        csum = 0

        for right in range(len(nums)):
            csum += nums[right]

            while csum > target:
                csum -= nums[left]
                left += 1

            if csum == target:
                ans = max(ans, right - left + 1)

        return len(nums) - ans if ans != -1 else -1
        
--

=======================================================================================================================



-- Minimum jumps to reach home (BFS/ DFS) (Imp)


-- https://leetcode.com/problems/minimum-jumps-to-reach-home/
--


--
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        from collections import deque

        max_limit = 6000  # Upper bound for search (arbitrary large value to prevent infinite loops)
        forbidden_set = set(forbidden)
        
        # Queue will store (position, last_jump_was_backward, jumps_count)
        queue = deque([(0, False, 0)])  # Start from position 0, not backward jump, 0 jumps so far
        visited = set([(0, False)])  # Track visited positions with the direction
        
        while queue:
            pos, last_backward, jumps = queue.popleft()
            
            # If we reached home, return the number of jumps
            if pos == x:
                return jumps
            
            # Move forward
            new_pos_forward = pos + a
            if new_pos_forward not in forbidden_set and new_pos_forward <= max_limit and (new_pos_forward, False) not in visited:
                visited.add((new_pos_forward, False))
                queue.append((new_pos_forward, False, jumps + 1))
            
            # Move backward (only if the last jump was not backward)
            new_pos_backward = pos - b
            if not last_backward and new_pos_backward >= 0 and new_pos_backward not in forbidden_set and (new_pos_backward, True) not in visited:
                visited.add((new_pos_backward, True))
                queue.append((new_pos_backward, True, jumps + 1))
        
        # If we exhaust the queue and didn't reach x, return -1
        return -1

--

=============================================================================================================================


-- Minimum deltions to make string balanced



-- https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/submissions/1415395634/
--


--
class Solution:
    def minimumDeletions(self, s: str) -> int:
        minDeletions = 0
        bcount = 0

        for i in s:
            if i == 'b':
                bcount += 1
            else:
                minDeletions = min(minDeletions + 1, bcount)
        return minDeletions
        
--


===========================================================================================================================

-- Minimum operations to make the integer zero


-- https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/
--


--
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(61):
            target = num1 - k * num2
            if target >= 0 and target.bit_count() <= k <= target:
                return k
        return -1
--


======================================================================================================================


-- Sell Diminishing valued colored balls



-- https://leetcode.com/problems/sell-diminishing-valued-colored-balls/
--


--
class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True) # inventory high to low 
        inventory += [0]
        ans = 0
        k = 1
        for i in range(len(inventory)-1): 
            if inventory[i] > inventory[i+1]: 
                if k*(inventory[i] - inventory[i+1]) < orders: 
                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum 
                    orders -= k*(inventory[i] - inventory[i+1])
                else: 
                    q, r = divmod(orders, k)
                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)
                    return ans % 1_000_000_007
            k += 1
--


=============================================================================================================


-- Count zero request servers


-- https://www.youtube.com/watch?v=cIHKCWVBqW0
-- https://leetcode.com/problems/count-zero-request-servers/


--
class Solution:
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:

        # TLE 
        cnt = 0
        res = []

        for query in queries:
            start = query - x
            end = query
            
            count = 0
            
            serverids = set()
            
            for id, time in logs:
                if time >= start and time <= end:
                    serverids.add(id)

            res.append(n - len(serverids))
        return res
    
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:

        # first push all the queries and logs in one array 
        # for logs push it with (time, n + i) n -> no. servers
        # for queries push it as zero based index with server id as 0 based index

        # use queue to sort out the list and remove the intervals which comes before the specified time intervals

        b = []

        for i in range(len(logs)):
            # push (time, id - 1) 
            b.append((logs[i][1], logs[i][0] - 1))

        for i in range(len(queries)):
            # push it as (query, n + i) => n + i determines that it is query and not log in future
            b.append((queries[i], n + i))
        
        # now sort the list out
        b.sort()
        from collections import deque

        q = deque()
        count = 0 # to keep the number of servers which are active at that interval
        d = {} # d to store the server count
        m = len(b)

        ans = [0] * len(queries)

        for i in range(m):
            # this condition tells you that whether the second part is server or the log
            if b[i][1] >= n:

                # traverse through the queue and get the time intervals in the range (b[i][1] - x) to b[i][1]
                while q and b[q[0]][0] < b[i][0] - x:
                    server = b[q[0]][1]
                    d[server] -= 1
                    if d[server] == 0:
                        count -= 1
                    q.popleft()
                ans[b[i][1] - n] = n - count

            else:
                q.append(i) # insert the index to the queue
                server = b[i][1]
                d[server] = d.get(server, 0) + 1

                if d[server] == 1:
                    count += 1
        return ans
--


============================================================================================================

-- Divide players into teams of equal skill


--
-- https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/


--
class Solution:
    def dividePlayers(self, skill: List[int]) -> int:

        # 1, 2, 3, 3, 4, 5
        skill.sort()

        left = 0
        right = len(skill) - 1  # Set right to point to the last element

        equal_sum = skill[left] + skill[right]
        ans = [] 

        while left < right: 
            current_sum = skill[left] + skill[right]
            if current_sum != equal_sum:
                return -1 
            ans.append(skill[left] * skill[right])
            left += 1
            right -= 1 

        return sum(ans)
        
--


==========================================================================================================

-- Contruct the longest new string


-- https://leetcode.com/problems/construct-the-longest-new-string/
--


--
class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        
        # Case 1: If x == y:

        # If the number of "AA" strings is equal to the number of "BB" strings, we can alternate between "AA" and "BB", possibly adding "AB" strings in between.
        # The total length in this case would be 


        # 2(x+y+z)=4x+2z, as each "AA" or "BB" contributes 2 characters, and each "AB" contributes 2 characters.

        # Case 2: If x > y:

        # If there are more "AA" strings than "BB" strings, we should try to alternate as much as possible, but eventually, we will run out of "BB" strings.
        # Once all "BB" strings are used, we need to ensure that the remaining "AA" strings do not form "AAA".
        # To do this, we can add an "AB" string in between to break the sequence of "AA"s.
        # The maximum number of usable "AA" strings without forming "AAA" is 
        # 2
        # 𝑦
        # +
        # 1
        # 2y+1 (one more than twice the number of "BB" strings).
        # The total length in this case would be 

        # 2(2y+1+z)=4y+2+2z.
        # Case 3: If y > x:

        # Similarly to the previous case, if there are more "BB" strings than "AA" strings, we try to alternate, but once we run out of "AA" strings, we must avoid forming "BBB".
        # The maximum number of usable "BB" strings without forming "BBB" is 

        # 2x+1.
        # The total length in this case would be 
        #2(2x+1+z)=4x+2+2z.

        if x == y:
            return 4 * x + 2 * z
        elif x > y:
            return 4 * y + 2 + 2 * z
        else:
            return 4 * x + 2 + 2 * z
        
--


=========================================================================================================


-- Minimum time to repair cars


-- https://leetcode.com/problems/minimum-time-to-repair-cars/
--


--
from typing import List

class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        n = len(ranks)
        
        # Helper function to check if a given time is sufficient to repair all cars
        def checker(time):
            total_cars = 0  # Reset total cars for each check
            for rank in ranks:
                max_cars = int((time // rank) ** 0.5)  # Formula to calculate how many cars can be repaired by the mechanic
                total_cars += max_cars
                if total_cars >= cars:
                    return True
            return False

        # Binary search for the minimum time
        left, right = 0, max(ranks) * cars * cars

        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                right = mid - 1
            else:
                left = mid + 1

        # `left` will have the minimum time required to repair the cars
        return left

--


===========================================================================================================

-- Number of even and odd bits


-- https://leetcode.com/problems/number-of-even-and-odd-bits/submissions/1417287009/
--


--
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        even = 0
        odd = 0


        num_str = bin(n)[2:][::-1]  
        
        i = 0
        n = len(num_str)
        while i < n:
            if num_str[i] == '1': 
                if i % 2 == 0:
                    even += 1
                else:
                    odd += 1
            i += 1
        return [even, odd]

        

    
        
--


==============================================================================================================

-- Decremental string Concatination


--
-- https://leetcode.com/problems/number-of-even-and-odd-bits/submissions/1418333002/


--
--


===============================================================================================================


-- Find score of an array after marking all elements



-- https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/submissions/1419529278/
--


--
class Solution:
    def findScore(self, nums: List[int]) -> int:
        n = len(nums)

        sorted_nums = sorted((num, i) for i, num in enumerate(nums))
        marked = [False] * n

        csum = 0  

        # [1, 2, 2, 3, 3, 5]

        for num, index in sorted_nums:
            if not marked[index]:
                csum += num

                if index - 1 >= 0:
                    marked[index - 1] = True
                if index + 1 < n:
                    marked[index + 1] = True
            
        return csum
--


===============================================================================================================


--Maximize greatest of an array


--
-- https://leetcode.com/problems/maximize-greatness-of-an-array/


--
class Solution:
    def maximizeGreatness(self, nums: List[int]) -> int:
        sorted_array = sorted(nums)

        perm_sorted = sorted(nums)

        i = 0 # pointing to the numbers in sorted_array
        j = 0 # pointing to the numbers in perm_sortted

        greatest_flips = 0

        while i < len(sorted_array) and j < len(perm_sorted):
            if perm_sorted[j] > sorted_array[i]:
                greatest_flips += 1
                i += 1
                j += 1
            else:
                j += 1
        return greatest_flips
        
--


=================================================================================================================


-- Distribute money to maximum children


-- https://leetcode.com/problems/distribute-money-to-maximum-children/
--


--
class Solution:
    def distMoney(self, money: int, children: int) -> int:
        #money left after distributing 1$ to each child
        money=money-children
        c=0
        if  money>=0:
            while money>=7:
                money-=7 
                #addition of 7$ more to each child will make it 8$
                c+=1 
            if money==3 and c==children-1:
                c-=1 #because 1+3=4$
            elif c==children and money>0:
                c-=1 #all the remaining money is taken up by one child
            elif c>children:
                c=children-1 #all the remaining money is given to one child
            return c
        else:
            return -1
--


===================================================================================================================


-- Kth largest sum in a binary tree


-- https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/
--


--
class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:

        q = []
        q.append(root)
        ans = []

        while q:
            size = len(q)
            csum = 0
            for i in range(size):
                temp = q.pop(0)
                csum += temp.val

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
            ans.append(csum)
        ans.sort(reverse=True)
        print(ans)
        return ans[k-1] if k - 1 < len(ans) else -1
--


=================================================================================================================


-- Count the ways to group overlapping ranges 


-- https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/submissions/1422407210/
--


--
class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ranges.sort()

        prev_end = ranges[0][1]
        group = 1
        MOD = 10**9 + 7

        for i in range(len(ranges)):
            start, end = ranges[i]

            if start <= prev_end:
                prev_end = max(prev_end, end)
            else:
                group += 1
                prev_end = end
        
        return pow(2, group, MOD)
--

=================================================================================================================


--  Find the divisibilyt array of a string


--
-- https://leetcode.com/problems/find-the-divisibility-array-of-a-string/


--from typing import List

class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        res = []
        current_remainder = 0

        for char in word:
            current_remainder = (current_remainder * 10 + int(char)) % m # use this method instead of convertiing the huge string to number
            if current_remainder == 0:
                res.append(1)
            else:
                res.append(0)
        
        return res
--


=======================================================================================================


-- Count the number of square free subsets


-- https://leetcode.com/problems/count-the-number-of-square-free-subsets/
--


--
class Solution:
    def squareFreeSubsets(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        candidates = set([2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30])

        # get the frequency for the square free numbers
        cnt = defaultdict(int)
        for num in nums:
            if num in candidates:
                cnt[num] += 1
        
        def count(arr):
            if not arr:
                return 1
            arr1 = []
            for num in arr[1:]:
                if math.gcd(num, arr[0]) == 1:
                    arr1.append(num)
            return (count(arr[1:]) + cnt[arr[0]] * count(arr1)) % MOD
            
        ones = nums.count(1)
        
        tmp = 1
        for _ in range(ones):
            tmp = (tmp * 2) % MOD
        return (count(list(cnt)) * tmp - 1) % MOD
--


============================================================================================================================


-- Minimum operations to reduce an integer to 0



-- https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/
--


--
from collections import deque

class Solution:
    def minOperations(self, n: int) -> int:
        q = deque()

        # (number, operations count)
        q.append((n, 0))
        vis = set()
        vis.add(n)

        powers_of_2 = [1 << i for i in range(30)]  # Precompute powers of 2 up to 2^29

        while q:
            num, op = q.popleft()

            if num == 0:
                return op  # Return the number of operations

            for i in powers_of_2:
                new_num_add = num + i
                new_num_sub = num - i

                # Check if we can add or subtract i to get closer to 0
                if new_num_add not in vis:
                    vis.add(new_num_add)
                    q.append((new_num_add, op + 1))

                if new_num_sub not in vis and new_num_sub >= 0:  # Only consider non-negative numbers
                    vis.add(new_num_sub)
                    q.append((new_num_sub, op + 1))

        return -1  # If no solution is found (although this should never happen)

--


==========================================================================================================================

-- Count the total number of colored cells


-- https://leetcode.com/problems/count-total-number-of-colored-cells/submissions/1423536173/
--


--
class Solution:
    def coloredCells1(self, n: int) -> int:

        if n == 1:
            return 1

        dp = [0] * (n + 1)

        dp[0] = 0
        dp[1] = 1

        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + (4 * (i - 1))
        

        return dp[n]
    
    def coloredCells(self, n: int) -> int:
        total_cells = 1
        if n == 1:
            return total_cells
        for i in range(2, n+1):
            total_cells += 4 * (i - 1)
        return total_cells
        
--

==========================================================================================================================

-- Rearrange array to maximize prefix score


-- https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/description/
--

--
class Solution:
    def maxScore1(self, nums: List[int]) -> int:
        return sum(n > 0 for n in accumulate(sorted(nums, reverse=True)))
    
    def maxScore(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
    
        prefix_sum = 0
        positive_count = 0
        
        # Calculate prefix sums and count how many are positive
        for num in nums:
            prefix_sum += num
            if prefix_sum > 0:
                positive_count += 1
            else:
                break  # Once the prefix sum becomes non-positive, stop counting
        
        return positive_count
--


========================================================================================================================


-- Count the number of beautiful subarrays (Imp)


-- https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/
--


--
class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        prefix = 0

        # cal the prefix xor if the number is already present in the array then the subarry from left to right is subarray

        xor = {0 : 1}
        n = len(nums)
        ans = 0

        for i in range(n):
            prefix ^= nums[i]

            if prefix in xor:
                ans += xor[prefix]
            xor[prefix] = xor.get(prefix, 0) + 1

        return ans 
        
--



========================================================================================================================


-- Minimum score by changing two elements


-- https://leetcode.com/problems/minimum-score-by-changing-two-elements/
--


--
class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
    # Change the two largest values to the third largest value. Third largest value now becomes the max value.
    # Change the two smallest values to the third smallest value. Third smallest value now becomes the min value.
    # Change largest value to second largest value and smallest value to second smallest value. Second largest becomes max value and second smallest becomes min value.


        n = len(nums)

        nums.sort()
        return min(nums[-1] - nums[2], min(nums[n - 2] - nums[1], nums[n - 3] - nums[0]))
--


===========================================================================================================================


-- Substring xor queries


--
-- https://leetcode.com/problems/substring-xor-queries/


--
from typing import List

class Solution:
    def substringXorQueries1(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        n = len(s)

        def checker(target, prev_start):
            for start in range(n):
                val = 0
                for end in range(start, n):
                    val = (val << 1) | int(s[end])

                    if val == target:
                        temp = start
                        while temp + 1 <= end and int(s[temp + 1: end + 1]) == target:
                            temp += 1
                        return ([temp, end], end)  

                    if val > 10**9:
                        break
            return False

        ans = []
        prev = 0 
        for first, second in queries:
            target = first ^ second
            result = checker(target, prev)

            if result:
                res, new_end = result 
                prev = new_end
                ans.append(res)
            else:
                ans.append([-1, -1])
        
        return ans

    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        # for every i at amx we can go till 32 length and then get the smallest substring which matches the target
        # and get the answer for it
        l=len(s) #get length of the given string
        d={} #create empty hashmap
        n=min(32,l) # integer upto 10**9 can be represented within 32 bits, hence we need all substrings upto 32 bits length. Also, length of the given string could be < 32.

        for i in range(n): # generate all substrings of i+1 length
            for j in range(l-i): 
                # l - i because from i to 32 long
                x=s[j:j+i+1] 
                if int(x,2) not in d:
                    d[int(x,2)]=[j,j+i]


        ans=[]
        
        for q in queries:
            x=q[0]^q[1] 
            if x in d:
                ans.append(d[x])
            else:
                ans.append([-1,-1])
        return ans
--

=========================================================================================================================


-- Count the number of fair pairs (Imp)


--
--



--
class Solution:
    def countFairPairs1(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        n = len(nums)
        count = 0
        
        # Iterate over each element in nums
        for i in range(n):
            # Find the lower bound index for nums[i]
            low_index = bisect.bisect_left(nums, lower - nums[i], i + 1)
            # Find the upper bound index for nums[i]
            high_index = bisect.bisect_right(nums, upper - nums[i], i + 1)
            
            # Count valid pairs with nums[i]
            count += (high_index - low_index)
        
        return count
    
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()

        # first check for all left and right compare it with upper and lower range

        # and add the pairs to the values if sorted array then right - left gives the number of paires
        n = len(nums)

        left = 0
        right = n - 1
        val1 = 0

        # counting first for upper and then lower
        while left < right:
            if nums[left] + nums[right] <= upper:
                val1 += right - left
                left += 1
            else:
                right -= 1
        

        # now calculate for the pairs which are less than lower so that at the end you can subtract the sum at the end 
        left = 0
        right = n - 1
        val2 = 0

        while left < right:
            if nums[left] + nums[right] < lower:
                val2 += right - left
                left += 1
            else:
                right -= 1
        return val1 - val2
--


=============================================================================================================================


-- Find the array concatenation value

-- https://leetcode.com/problems/find-the-array-concatenation-value/submissions/1425667879/
--


--
class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:

        ans = 0
        left = 0
        n = len(nums)
        right = n - 1

        while left <= right:
            if left == right:
                ans += nums[left]
            else:
                temp = int(str(nums[left]) + str(nums[right]))
                ans += temp
            left += 1
            right -= 1
        return ans
--


==============================================================================================================================

-- House Robber IV


-- https://leetcode.com/problems/house-robber-iv/
--

--
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        def can_steal_with_capability(cap):
            count = 0
            i = 0
            while i < len(nums):
                if nums[i] <= cap:
                    count += 1
                    i += 2  # Skip the next house to ensure non-adjacency
                else:
                    i += 1
            return count >= k

        low, high = min(nums), max(nums)
        
        while low < high:
            mid = (low + high) // 2
            if can_steal_with_capability(mid):
                high = mid  # Try to lower the capability
            else:
                low = mid + 1  # Increase the capability
        
        return low
--

===============================================================================================================================

-- Count the vowel strin in ranges


-- https://leetcode.com/problems/count-vowel-strings-in-ranges/
--



--
class Solution:
    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        n = len(words)
        prefix_sum = [0] * n
        vowels = "aeiou"

        for i in range(n):
            if words[i] and words[i][0] in vowels and words[i][-1] in vowels:
                prefix_sum[i] = 1

            if i > 0:
                prefix_sum[i] += prefix_sum[i - 1]
        
        ans = []
        for l, r in queries:
            if l > 0:
                ans.append(abs(prefix_sum[r]  - prefix_sum[l - 1]))
            else:
                ans.append(prefix_sum[r])

        return ans 
--


===============================================================================================================


-- Closest nodes queries in a binary search tree


-- https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/submissions/1427315570/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        arr = []            
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            arr.append(node.val)
            inorder(node.right)

        def findmini(num):
            left = 0
            right = len(arr) - 1
            res = -1

            while left <= right:
                mid = (left + right)//2

                if arr[mid] <= num:
                    res = arr[mid]
                    left = mid + 1
                else:
                    right = mid - 1
            return res
        
        def findmaxi(num):
            left = 0
            right = len(arr) - 1
            res = -1

            while left <= right:
                mid = (left + right)//2

                if arr[mid] >= num:
                    res = arr[mid]
                    right = mid - 1
                else:
                    left = mid + 1
            return res
    
        
        inorder(root)
        result = []
        for query in queries:
            mini = findmini(query)
            maxi = findmaxi(query)
            result.append([mini, maxi])
        
        return result
--


================================================================================================================ 

-- Number of unequal triplets in a array


-- https://leetcode.com/problems/number-of-unequal-triplets-in-array/
--


--
class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] != nums[j] and nums[j] != nums[k] and nums[k] != nums[i]:
                        ans += 1
        return ans

    def unequalTriplets(self, nums: List[int]) -> int:
        c = Counter(nums)
        res = 0

        l = 0 
        r = len(nums)

        for i, f in c.items():
            r -= f
            res += l * f * r
            l += f

        return res

        
--

==========================================================================================================================================================

-- Most profitable path in a tree


-- https://leetcode.com/problems/most-profitable-path-in-a-tree/
--


--
class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        from collections import defaultdict
        graph = defaultdict(list)
        for src, des in edges:
            graph[src].append(des)
            graph[des].append(src)
        
        # bob traversal
        bobPath = dict()
        def bobTravel(bob, time):
            bobPath[bob] = time 
            if bob == 0: return True

            for neighbor in graph[bob]: # graph[1]
                if not bobPath.get(neighbor):
                    if bobTravel(neighbor, time + 1): 
                        return True
                    del bobPath[neighbor]
                        
                    
            return False            


        # alice traversal
        # alice traverses each node and collects the reward/price depending
        # on the node, the amount at each node depends on bob's path
        # case 1: collision => amount // 2 . node in bob's path and at the same time
        # case 2: already visited by bob: node in bob's path and it's time more than bob's time
        # otherwise collect/incur full amount from the gate.
        # as soon as the traversal reaches the leaf node, make changes to the global max_profit if applicable
        # and return 
        bobTravel(bob, 1)
        max_profit = - float('inf')
        
        visited = [0] * len(graph)
        def aliceTraversal(node, time, amt):
            nonlocal max_profit 
            if bobPath.get(node):
                if time == bobPath[node]:
                    amt += amount[node] // 2
                if time < bobPath[node]:
                    amt += amount[node]
            else:
                amt += amount[node]
            visited[node] = 1
            cnt = 0
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    cnt += 1
                    aliceTraversal(neighbor, time + 1, amt)
            
            if cnt == 0:
                max_profit = max(max_profit, amt)
            
        aliceTraversal(0, 1, 0)
        return max_profit
--


==========================================================================================================================================================


-- Find the sequence of strings appeared on the screen


--
-- https://leetcode.com/problems/find-the-sequence-of-strings-appeared-on-the-screen/


--
class Solution:
    def stringSequence(self, target: str) -> List[str]:

        res = []

        i = 0
        n = len(target)
        string = ""

        while i < n:
            for char in range(26):
                temp = chr(char + ord('a'))
                print(temp, i, target[i])
                if target[i] == temp:
                    string += temp
                    res.append(string)
                    i += 1
                    break
                else:
                    string += temp
                    res.append(string)
                    string = string[:-1]

        return res
--


==============================================================================================================================================================


-- Count substrings with k frequency (Imp)


-- https://leetcode.com/problems/count-substrings-with-k-frequency-characters-i/
--


--
from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        ans = 0
        l = 0
        d = {}
        for c in s:
            d[c] = d.get(c, 0) + 1
            while d[c] == k:
                d[s[l]] -= 1
                l += 1
            ans += l
        return ans
--


============================================================================================================================================================


-- Minimum division operations to make array non decreasing


-- https://leetcode.com/problems/minimum-division-operations-to-make-array-non-decreasing/
--


--
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums) - 1, 0, -1):
            if nums[i] < nums[i - 1]:
                nums[i - 1] = self.findNum(nums[i], nums[i - 1])
                if nums[i - 1] == -1: return -1
                ans += 1
        return ans
    
    def findNum(self, n1, n2):
        for i in range(n1, 1, -1):
            if n2 % i == 0: return i
        return -1
--


============================================================================================================================================================

-- Count ways to build good strings (Imp)


-- https://leetcode.com/problems/count-ways-to-build-good-strings/
--


--
class Solution:
    def countGoodStrings1(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 10**9 + 7
    
        # Initialize dp array for lengths up to high
        dp = [0] * (high + 1)
        dp[0] = 1  # There is one way to create an empty string

        # Fill dp array
        for i in range(1, high + 1):
            if i - zero >= 0:
                dp[i] = (dp[i] + dp[i - zero]) % MOD
            if i - one >= 0:
                dp[i] = (dp[i] + dp[i - one]) % MOD

        # Count the number of good strings
        total_good_strings = sum(dp[low:high + 1]) % MOD
        
        return total_good_strings

    def countGoodStrings2(self, low: int, high: int, zero: int, one: int) -> int:
        mod = 10**9 + 7
        # dp = {0 : 1} # base case length -> number of strings of length 0
        dp = {}

        def dfs(length):
            if length > high:
                return 0

            if dp.get(length, 0):
                return dp[length]

            for_zero = dfs(length + zero)
            for_one = dfs(length + one)

            res = 1 if length >= low else 0
            res += for_zero + for_one

            dp[length] = res % mod
            return res % mod

        return dfs(0) 

    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = {0: 1} #  base case length -> number of strings of length 0
        mod = 10**9 + 7

        # using this approach since i got TLE

        for i in range(1, high + 1):
            dp[i] = (dp.get(i - one, 0) + dp.get(i - zero, 0)) % mod
        
        return sum([dp[i] for i in range(low, high + 1)]) % mod
--


==========================================================================================================================================================

-- Total Cost to hire k workers


-- https://leetcode.com/problems/total-cost-to-hire-k-workers/submissions/1428245288/
--


--
from heapq import heappush, heappop
from typing import List

class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        left = 0
        right = n - 1

        heapl = []
        heapr = []

        for i in range(candidates):
            if left <= right:
                heappush(heapl, (costs[left], left))
                left += 1
            if left <= right:
                heappush(heapr, (costs[right], right))
                right -= 1

        total = 0
        # Select the minimum cost for 'k' times
        for i in range(k):
            if not heapl:
                temp = heappop(heapr)
                total += temp[0]
            elif not heapr:
                temp = heappop(heapl)
                total += temp[0]
            else:
                if heapl[0][0] <= heapr[0][0]:
                    total += heappop(heapl)[0]
                    if left <= right:
                        heappush(heapl, (costs[left], left))
                        left += 1
                else:
                    total += heappop(heapr)[0]
                    if left <= right:
                        heappush(heapr, (costs[right], right))
                        right -= 1

        return total

--


============================================================================================================================================================


-- Maximum sum of distinct subarrays with length k


--
-- https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/


--
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        left = 0
        right = 0

        n = len(nums)
        total = 0
        ans = 0
        csum = 0
        m = {}

        while right < n:
            csum += nums[right]
            m[nums[right]] = m.get(nums[right], 0) + 1

            if right - left + 1 < k:
                right += 1

            elif right - left + 1 == k:
                if len(m) == k:
                    ans = max(ans, csum)
                
                m[nums[left]] = m.get(nums[left], 0) - 1

                if m[nums[left]] == 0:
                    del m[nums[left]]

                csum -= nums[left]
                left += 1
                right += 1

        return ans

--


===========================================================================================================================================================


-- Distinct prime facotrs of product of array


--
--


--
class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:

        # get the prime factors for every number
        def prime_factor(num):
            factor = set()

            # first check for the number divisible by 2
            while num % 2 == 0:
                factor.add(2)
                num //= 2
            
            for i in range(3, int(num**0.5) + 1, 2):
                while num % i == 0:
                    factor.add(i)
                    num //= i
            
            # if num is prime number greater than 2
            if num > 2:
                factor.add(num)
            return factor
        
        prime_factors = set()

        for i in nums:
            prime_factors.update(prime_factor(i))

        return len(prime_factors)

          
--

==========================================================================================================================================================


-- parition string into substrings with values at most k


--
-- https://leetcode.com/problems/partition-string-into-substrings-with-values-at-most-k/


--
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        current_string = ""
        count = 0

        for char in s:
            current_string += char

            if int(current_string) > k:
                count += 1
                current_string = char

                if int(current_string) > k:
                    return -1
        
        if current_string:
            count += 1
        return count        
--


======================================================================================================================================================

-- Closest prime numberds in range


--
-- https://leetcode.com/problems/closest-prime-numbers-in-range/


--
class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def is_prime(n):
            if n <= 1:
                return False
            if n <= 3:
                return True
            if n % 2 == 0 or n % 3 == 0:
                return False
            i = 5
            while i * i <= n:
                if n % i == 0 or n % (i + 2) == 0:
                    return False
                i += 6
            return True

        res = []
        for i in range(left, right + 1):
            if is_prime(i):
                res.append(i)

        
        mini = float("inf")
        ans = [-1, -1]

        for i in range(1, len(res)):
            minimum_diff = res[i] - res[i - 1]

            if minimum_diff < mini:
                mini = minimum_diff
                ans = [res[i - 1], res[i]]
        return ans
--


====================================================================================================================================================

-- Make the number of distinct characters equal


-- https://leetcode.com/problems/make-number-of-distinct-characters-equal/submissions/1428539211/
--

--
class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        cnt1, cnt2 = [0 for i in range(26)], [0 for i in range(26)]

        # count the frequency for word1 and word2
        for i in range(len(word1)):
            cnt1[ord(word1[i]) - ord('a')] += 1
        for i in range(len(word2)):
            cnt2[ord(word2[i]) - ord('a')] += 1

        # swap the words
        for i in range(26):
            for j in range(26):
                if cnt1[i] != 0 and cnt2[j] != 0:
                    # Swap
                    cnt1[j] += 1
                    cnt2[j] -= 1
                    cnt1[i] -= 1
                    cnt2[i] += 1
                    # Check Validity
                    if self.isValid(cnt1, cnt2):
                        return True
                    # Restore
                    cnt1[j] -= 1
                    cnt2[j] += 1
                    cnt1[i] += 1
                    cnt2[i] -= 1
        return False
    
    def isValid(self, c1, c2):
        d1, d2 = 0, 0
        for i in range(26):
            if c1[i] != 0:
                d1 += 1
            if c2[i] != 0:
                d2 += 1
        return d1 == d2
--


==================================================================================================================================================

-- Count the number of good subarrays


-- https://leetcode.com/problems/count-the-number-of-good-subarrays/
--


--
from collections import defaultdict
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        m = defaultdict(int)
        left = 0
        n = len(nums)
        good_subarrays = 0
        result = 0
        
        for right in range(n):
            # calculate all the pairs 
            good_subarrays += m[nums[right]]
            m[nums[right]] += 1

            while good_subarrays >= k:
                # include the subarrays to the result
                result += n - right

                # from left reduce the window and calculate the subarrays
                m[nums[left]] -= 1
                good_subarrays -= m[nums[left]]
                left += 1

        return result
            
                
--


==================================================================================================================================================

-- Minimum operations to make array equal II

-- https://leetcode.com/problems/minimum-operations-to-make-array-equal-ii/description/
--


--
class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        if k == 0:
            return 0 if nums1 == nums2 else -1
        
        total_increase = 0
        total_decrease = 0

        for i in range(len(nums1)):
            diff = nums1[i] - nums2[i]

            if diff % k:
                return -1
            
            if diff > 0:
                # you need to divide the diff with k since the diff can be increased or dcreased in k folds
                total_increase += diff // k
            
            if diff < 0:
                total_decrease += (-diff) // k
            
        if total_increase == total_decrease:
            return total_increase
        return -1
            


        
--


==================================================================================================================================================


-- Maximum tastiness of candy basket 


--
-- https://leetcode.com/problems/maximum-tastiness-of-candy-basket/submissions/1429507557/


--
class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        price.sort()

        def checker(diff):
            # increase the maximum diff
            count = 1
            prev = price[0]

            for i in range(1, len(price)):
                if price[i] - prev >= diff:
                    count += 1
                    prev = price[i]
                    if count == k:
                        return True
            return False

        left = 0
        # get the right which has maximum diff
        right = price[-1] - price[0]

        result = 0
        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        return result            

        
--


================================================================================================================================================


-- Take k of each char from left and right


--
-- https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/submissions/1430507073/


--
class Solution:
    def takeCharacters(self, s: str, k: int) -> int:

        # instead of removing from both the ends 
        # you can you technique to get the longest substring to get the characters count(char) - k
        # if any character count goes below 0 then return -1

        # for all the character count decrease by k
        limit = {char: s.count(char) - k for char in "abc"}

        if any(x < 0 for x in limit.values()):
            return -1
        
        cnts = {c: 0 for c in 'abc'}
        ans = l = 0
        for r, c in enumerate(s):
            cnts[c] += 1

            while cnts[c] > limit[c]:
                cnts[s[l]] -= 1
                l += 1
            ans = max(ans, r - l + 1)
        return len(s) - ans
--

===============================================================================================================================================

-- Minimize the maximum of two arrays


--
-- https://leetcode.com/problems/minimize-the-maximum-of-two-arrays/


--
class Solution: 
	def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int: 
		lo, hi = 0, 1<<32-1
		mult = lcm(divisor1, divisor2)

		while lo < hi: 
			mid = lo + hi >> 1

            # mid - mid // div1 gives you total number of count which is less than mid

            # un1 + uni2 <= mid - mid //mul gives you total nuumber of elements which is not divisible by either one
			if uniqueCnt1 <= mid - mid//divisor1 and uniqueCnt2 <= mid - mid//divisor2 and uniqueCnt1+uniqueCnt2 <= mid - mid//mult: 
                hi = mid
			else: 
                lo = mid+1
		return lo 
--


==============================================================================================================================================

-- Reward top k students


-- https://leetcode.com/problems/reward-top-k-students/submissions/1431056624/
--


--
from collections import defaultdict
from typing import List
class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:

        # traverse through the map and check for the feedbacks

        pos = set(positive_feedback)
        neg = set(negative_feedback)

        student = {}

        for i in range(len(report)):
            words = report[i].split()
            _id = student_id[i]

            if _id not in student:
                student[_id] = 0

            for word in words:
                if word in pos:
                    student[_id] += 3
                elif word in neg:
                    student[_id] -= 1
            
        sorted_values = sorted(student.keys(), key=lambda x:(-student[x], x))

        return sorted_values[:k]


--


==================================================================================================================================================

-- Maximum enemy forts that can be captured 


-- https://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/
--


--
class Solution:
    def captureForts(self, f: List[int]) -> int:

        prevOne = False
        cnt = 0
        ans = 0

        n = len(f)
        for i in range(n):
            if f[i] == 0 and prevOne:
                cnt += 1
            elif f[i] == 1:
                cnt = 0
                prevOne = True
            elif f[i] == -1:
                prevOne = False
                ans = max(cnt, ans)
                cnt = 0
        
        prevOne = False
        cnt = 0
        for i in range(n - 1, -1, -1):
            if f[i] == 0 and prevOne:
                cnt += 1
            elif f[i] == 1:
                cnt = 0
                prevOne = True
            elif f[i] == -1:
                prevOne = False
                ans = max(cnt, ans)
                cnt = 0
        
        return ans



        
--


======================================================================================================================================================


-- Remove nodes from linked list


-- https://leetcode.com/problems/remove-nodes-from-linked-list/
--


--
from typing import Optional


# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:

        # Reverse the linked list
        def reverse_head(node):
            if not node:
                return None

            cur = node
            prev = None

            while cur:
                next_node = cur.next
                cur.next = prev
                prev = cur
                cur = next_node
            return prev

        rev_head = reverse_head(head)
        cur = rev_head
        max_element = cur.val

        while cur and cur.next:
            if cur.next.val < max_element:
                cur.next = cur.next.next
            else:
                max_element = cur.next.val
                cur = cur.next
        return reverse_head(rev_head)
--


=====================================================================================================================================================


-- Minimum penalty for a shop



-- https://leetcode.com/problems/minimum-penalty-for-a-shop/submissions/1434224540/
--


--
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        res = 0
        customer_left = 0
        
        for i in range(len(customers)):
            # if customer is greater than 0 there are still customers inside the shop
            # so reset the res to i + i coz the current one is Y
            # if 'N' decreament 1 from customer_left
            if customers[i] == 'Y':
                customer_left += 1

                if customer_left > 0:
                    res = i + 1
                    customer_left = 0                
            else:
                customer_left -= 1
                    
        return res
--

=======================================================================================================================================================


-- Diff between ones and zeros in row and col


-- https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/post-solution/?submissionId=1434246446
--


--
class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0])

        onesRow = [0] * m
        onesCol = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    onesRow[i] += 1
                    onesCol[j] += 1

        diff = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                zerosRow = m - onesRow[i]
                zerosCol = n - onesCol[j]

                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow - zerosCol
        return diff
        

--

========================================================================================================================================================

-- Minimum addition to make integer beautiful


-- https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/
--


--
class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:

        sm = lambda n: sum(map(int,list(str(n))))

        zeros, diff = 10, 0                     #  Ex: n = 5617     ; target = 7

        while sm(n + diff) > target:            #   n    zeros   diff  n+diff  sm(n+diff)
                                                # -----  –––––  –––––  ––––––  –––––––––  
            diff = zeros - n%zeros              # 5617     10      3    5620     13  
                                                # 5617    100     83    5700     12
            zeros*= 10                          # 5617   1000    383    6000      6  <-- less than target
                                                #                 |
        return diff  
--


===========================================================================================================================================================


-- Most popular video creater


--  https://leetcode.com/problems/most-popular-video-creator/
--

--
from collections import defaultdict
class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:

        total_views = defaultdict(int)
        max_views = defaultdict(lambda: (0, ""))  # (max_view_count, id)

        n = len(creators)
        
        for i in range(n):
            creator = creators[i]
            video_id = ids[i]
            view_count = views[i]

            total_views[creator] += view_count

            current_max, current_id = max_views[creator]
            if view_count > current_max:
                max_views[creator] = (view_count, video_id)
            elif view_count == current_max:
                if video_id < current_id or current_id == "":
                    max_views[creator] = (current_max, video_id)

        max_popularity = max(total_views.values())
        result = []

        for creator in total_views:
            if total_views[creator] == max_popularity:
                most_viewed_id = max_views[creator][1]
                result.append([creator, most_viewed_id])

        return result

        

        
--


========================================================================================================================================================


-- Destroy sequential targets


--
-- https://leetcode.com/problems/destroy-sequential-targets/



--
from typing import List

class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        m = {}

        for num in nums:
            reminder = num % space
            if reminder not in m:
                m[reminder] = 1
            else:
                m[reminder] += 1

        max_target = 0
        best_seed = float("inf")

        for num in nums:
            reminder = num % space
            count = m[reminder]

            if count > max_target or (count == max_target and num < best_seed):
                best_seed = num
                max_target = count
        
        return best_seed

--

=========================================================================================================================================================

-- Words within two edits of dictionary


-- https://leetcode.com/problems/words-within-two-edits-of-dictionary/
--


--
from typing import List

class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:

        def is_valid(q, w):
            count = 0
            for i in range(len(q)):
                if q[i] != w[i]:
                    count += 1
                if count > 2:
                    return False
            return count <= 2

        res = []
        for q in queries:
            for d in dictionary:
                if is_valid(q, d):
                    res.append(q)
                    break
        
        return res

--

=========================================================================================================================================================


-- Number of subarrays with gcd equal to k


-- https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/
--


--
class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        
        for i in range(n):
            current_gcd = 0
            for j in range(i, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                
                if current_gcd == k:
                    count += 1
                elif current_gcd < k:
                    break
                    
        return count
--


========================================================================================================================================================


-- Sum of number and its reverse


-- https://leetcode.com/problems/sum-of-number-and-its-reverse/
--


--
    def sumOfNumberAndReverse(self, num: int) -> bool:
        if num < 2:
            return num == 0
        for i in range(num // 2, num):
            rev = int(str(i)[::-1])
            if rev + i == num:
                return True
        return False
--


=========================================================================================================================================================


-- Count the number of distince int after reverse operations


--
-- https://leetcode.com/problems/count-number-of-distinct-integers-after-reverse-operations/


--
class Solution:
    def countDistinctIntegers1(self, nums: List[int]) -> int:
        s = set()
        cnt = 0

        for i in nums:
            temp = int(str(i)[::-1])
            if i not in s:
                cnt += 1
            s.add(i)
            if temp not in s:
                cnt += 1
            s.add(temp)
        
        return cnt
    
    def countDistinctIntegers(self, nums: List[int]) -> int:
    
        unique_integers = set()

        for num in nums:
            unique_integers.add(num)

        for num in nums:
            reversed_num = int(str(num)[::-1])
            unique_integers.add(reversed_num)

        return len(unique_integers)
            
     
--


============================================================================================================================================
 

-- Minimize maximum of array


-- https://leetcode.com/problems/minimize-maximum-of-array/submissions/1438760070/
--


--
import math
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:

        # two approchs 
            # Binary search
            # Normal greedy

        # Normal apporach

        cur_sum = 0
        a = 0  # max_value
        
        for ind, num in enumerate(nums):
            cur_sum += num
            ceil = math.ceil(cur_sum / (ind + 1))
            a = max(a, ceil)
        
        return a

    def minimizeArrayValue(self, nums: List[int]) -> int:
        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))

        
--


============================================================================================================================================


-- Range porduct querirs of powers


-- https://leetcode.com/problems/range-product-queries-of-powers/submissions/1438815532/
--


--
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:

        def get_minimum_pow(num):
            powers = 1
            res = []

            while num:
                if num & 1:
                    res.append(powers)
                powers *= 2
                num = num >> 1
        
            return res
        
        powers = get_minimum_pow(n)
        result = []

        def product_in_range(powers, left, right):
            MOD = 10**9 + 7
            result = 1
            for i in range(left, right + 1):
                result = (result * powers[i]) % MOD
            return result

        for left, right in queries:
            result.append(product_in_range(powers, left, right))
        return result


        
--


==============================================================================================================================================


-- Range product queries of powers


-- https://leetcode.com/problems/range-product-queries-of-powers/
--


--
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        # you can use prefix sum to get apporach as well
        def get_minimum_pow(num):
            powers = 1
            res = []

            while num:
                if num & 1:
                    res.append(powers)
                powers *= 2
                num = num >> 1
        
            return res
        
        powers = get_minimum_pow(n)
        result = []

        def product_in_range(powers, left, right):
            MOD = 10**9 + 7
            result = 1
            for i in range(left, right + 1):
                result = (result * powers[i]) % MOD
            return result

        for left, right in queries:
            result.append(product_in_range(powers, left, right))
        return result


        
--



==================================================================================================================================================


-- Using a robot to print the lexicographically smallesst string


-- https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/
--


--
class Solution:
    def robotWithString(self, s: str) -> str:
        cnt, lo, p, t = Counter(s), 'a', [], []
        for ch in s:
            t += ch
            cnt[ch] -= 1
            while lo < 'z' and cnt[lo] == 0:
                lo = chr(ord(lo) + 1)
            while t and t[-1] <= lo:
                p += t.pop()
        return "".join(p) 
--


======================================================================================================================================================


-- Minimize xor


-- https://leetcode.com/problems/minimize-xor/submissions/1439217586/
--


--
class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        k = bin(num2).count('1') # number of set bits 
        x = 0
        for i in range(31, -1, -1):
            if k == 0:
                break
            
            # check if ith bit of the number is set then or with x
            if (num1 & (1 << i) != 0):
                x |= (1 << i)
                k -= 1

        # this for loop needed when there is not enough set bits in num1
        for i in range(32):
            if k == 0:
                break
            if (x & (1 << i)) == 0:  # If the bit is not set in x
                x |= (1 << i)  # Set this bit in x
                k -= 1
        
        return x
        
        
--


=====================================================================================================================================================


-- Maximum sum of an hourglass


--
-- https://leetcode.com/problems/maximum-sum-of-an-hourglass/


--
class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        if m <= 2 and n <= 2:
            return -1

        max_sum = float('-inf')

        # Iterate over possible hourglass centers
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                # Calculate the hourglass sum centered at grid[i][j]
                hourglass_sum = (
                    grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] +
                    grid[i][j] +
                    grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]
                )
                # Update max_sum if the current hourglass_sum is greater
                max_sum = max(max_sum, hourglass_sum)

        return max_sum
            

        
--


======================================================================================================================================================

-- Bitwise xor of all pairings


-- https://leetcode.com/problems/bitwise-xor-of-all-pairings/
--


--
from typing import List

class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        odd1 = len(nums1) % 2
        odd2 = len(nums2) % 2

        x1 = 0
        for i in nums1:
            x1 ^= i
        x2 = 0
        for j in nums2:
            x2 ^= j

        return (odd1 * x2) ^ (odd2 * x1)

--


=================================================================================================================================================


-- Find all good indices (Imp)


-- https://leetcode.com/problems/find-all-good-indices/
--


--
    def goodIndices(self, nums: List[int], k: int) -> List[int]:

        n = len(nums)

        if n < 2 * k + 1:
            return []

        left = [False] * n
        right = [False] * n

        ls, rs = -1, n

        for i in range(1, n):
            if i >= k:
                if i - ls > k:
                    left[i] = True
            if nums[i] > nums[i - 1]:
                ls = i - 1
        
        for j in range(n - 2, -1, -1):
            if j < n - k:
                if rs - j > k:
                    right[j] = True
            if nums[j] > nums[j + 1]:
                rs = j + 1
        
        res = []
        for i in range(n):
            if left[i] and right[i]:
                res.append(i)
        return res
--


=================================================================================================================================================


-- Reverse odd levels of binary tree


-- https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        q = [root] 
        level = 1

        while q:
            size = len(q)
            current_level = []

            for i in range(size):
                node = q.pop(0)

                current_level.append(node)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            if level % 2 == 0:
                temp = []

                for node in current_level:
                    temp.append(node.val)

                temp = temp[::-1]

                for i in range(len(current_level)):
                    current_level[i].val = temp[i]
            
            level += 1

        return root
        
--

================================================================================================================================================= 


-- Length of the longest alphabetical continuous substring


--
-- https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/submissions/1439768555/


--
class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        
        ans = 1
        count = 1

        for i in range(1, len(s)):
            if ord(s[i]) == ord(s[i - 1]) + 1:
                count += 1
            else:
                ans = max(ans, count)
                count = 1
        ans = max(ans, count)
        return ans
--


===============================================================================================================================================


-- Smallest Subarray with maximum bitwise


-- https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/5993622/easy-solution-bit-manipulation-beats-100/
-- youtube link - https://www.youtube.com/watch?v=PeouhGUGr7Q



--
from typing import List

class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        max_or_setbits = [-1] * 32
        ans = []

        for i in range(n - 1, -1, -1):
            cur = nums[i]
            pos = 0

            while cur:
                if cur & 1:
                    max_or_setbits[pos] = i
                cur //= 2
                pos += 1

            max_index = max(max_or_setbits)
            ans.append(max_index - i + 1 if max_index != -1 else 1)

        return ans[::-1]
--


===============================================================================================================================================


-- Deivide intervals into minimum number of groups



-- https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/
--


--
class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        start = [interval[0] for interval in intervals]
        start.sort()
        end = [interval[1] for interval in intervals]
        end.sort()
        
        ans = 0
        j = 0

        # if i > end[j] meaning the interval than ended and you can move j
        for i in start:
            if i > end[j]:
                j += 1
            else:
                ans += 1
        
        return ans
--


===============================================================================================================================================


-- Number of ways to reach a position after exactly k steps


--
-- https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/


--
class Solution:
    def numberOfWays1(self, startPos: int, endPos: int, target: int) -> int:
        MOD=1e9+7
        dp = {}

        def dfs(cur, k, endPos):
            if (cur, k) in dp:
                return dp[(cur, k)]

            if k == 0:
                return 1 if cur == endPos else 0
            dp[(cur, k)] = (dfs(cur + 1, k - 1, endPos) + dfs(cur - 1, k - 1, endPos)) % MOD
            return dp[(cur, k)]
        
        return int(dfs(startPos, target, endPos) % MOD)

    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:

        dist = endPos-startPos

        if k%2 != dist%2 or abs(dist) > k: return 0

        return comb(k, (dist+k)//2) %1_000_000_007
--


===============================================================================================================================================

-- Maximum rows covered by columns


-- https://leetcode.com/problems/maximum-rows-covered-by-columns/submissions/1440595770/
--


--
class Solution:
    def maximumRows(self, mat: List[List[int]], numSelect: int) -> int:
        
        # using Backtracking and recursion to solve this problem
        m = len(mat)
        n = len(mat[0])

        vis = [False] * n
        ans = 0

        def backtrack(index, cols, cur_cols):
            nonlocal ans
            if cols == cur_cols:
                count = 0
                for i in range(m):
                    flag = True
                    for j in range(n):
                        if mat[i][j] == 1 and not vis[j]:
                            flag = False
                            break
                
                    if flag:
                        count += 1
                ans = max(ans, count)
                return 

            if index >= n:
                return

            vis[index] = True
            backtrack(index + 1, cols, cur_cols + 1)
            vis[index] = False
            
            backtrack(index + 1, cols, cur_cols)
        
        backtrack(0, numSelect, 0)
        return ans
            



--


===============================================================================================================================================


-- Minimum amount of time to collect garbage


-- https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
--


--
class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        m = 0
        g = 0
        p = 0

        last_metal = 0
        last_paper = 0
        last_glass = 0

        for i, house in enumerate(garbage):
            a = house.count('M')
            b = house.count('P')
            c = house.count('G')

            m += a
            g += b
            p += c

            if a:
                last_metal = i
            if b:
                last_paper = i
            if c:
                last_glass = i
        
        # now calculate the total time taken to reach the last particular garbage index
        tm = sum(travel[:last_metal])
        tg = sum(travel[:last_glass])
        tp = sum(travel[:last_paper])

        return tm + tg + tp + m + p + g
--


==============================================================================================================================================

-- Amount of time for binary tree to be infected


--
-- https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/

--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:

        # first calculate the parent array for all the nodes so that the infections can travel in all directions

        adj = {}

        def parent_cal(node, parent):
            if not node:
                return
            
            if node.val not in adj:
                adj[node.val] = []

            if parent:
                adj[node.val].append(parent.val)
                adj[parent.val].append(node.val)

            parent_cal(node.left, node)
            parent_cal(node.right, node) 
        
        parent_cal(root, None)

        q = [start]
        cnt = 0
        vis = set([start])

        while q:
            for _ in range(len(q)):
                temp = q.pop(0)
                for node in adj[temp]:
                    if node not in vis:
                        vis.add(node)
                        q.append(node)
            if q:
                cnt += 1
        
        return cnt
        
--


============================================================================================================================================

-- Shifting letters 2 (Imp)


-- https://leetcode.com/problems/shifting-letters-ii/
--


--
class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        n = len(s)
        delta = [0] * (n + 1)
        
        for start, end, direction in shifts:
            # based on direction add and decrease
            if direction == 1:
                delta[start] += 1
                if end + 1 < n:
                    delta[end + 1] -= 1
            else:
                delta[start] -= 1
                if end + 1 < n:
                    delta[end + 1] += 1

        shift = 0
        result = []
        for i, char in enumerate(s):
            shift += delta[i]

            # the new character
            new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            result.append(new_char)
        
        return ''.join(result)
--


==========================================================================================================================================


-- Time needed to rearrange a binary string


-- https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/submissions/1440931000/
--


--
class Solution:
    def secondsToRemoveOccurrences1(self, s: str) -> int:
        seconds = 0
        while '01' in s:
            s = s.replace('01', '10')
            seconds += 1
        return seconds

    def secondsToRemoveOccurrences(self, s: str) -> int:
        steps, zeroes = 0, 0
        for ch in s:
            if ch == '0':
                zeroes += 1
            elif zeroes > 0:
                # Increment steps after counting the necessary steps for '0's before '1'
                steps = max(steps + 1, zeroes)
        return steps

        
--

=======================================================================================================================================


-- Construct smallest number from di string


-- https://leetcode.com/problems/construct-smallest-number-from-di-string/
--


--
class Solution:
    def smallestNumber(self, pattern: str) -> str:
        stack = []
        result = []
        
        for i in range(len(pattern) + 1):
            stack.append(str(i + 1))
            
            if i == len(pattern) or pattern[i] == 'I':
                while stack:
                    result.append(stack.pop())
        
        return ''.join(result)
--

======================================================================================================================================

-- Node with highest edges score


--
-- https://leetcode.com/problems/node-with-highest-edge-score/description/


--
class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        temp = [0] * n

        for i in range(n):
            temp[edges[i]] += i

        return temp.index(max(temp))
--


=======================================================================================================================================


-- Longest ideal subsequence


-- https://leetcode.com/problems/longest-ideal-subsequence/
--


--
class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        x = [0] * 123
        for ch in s:
            i = ord(ch)
            x[i] = max(x[i - k:i + k + 1]) + 1
        return max(x)
--


=======================================================================================================================================

-- Check if there is a valid partiiton for the array


-- https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/
--

--
from collections import Counter

class Solution:
    def validPartition1(self, nums: List[int]) -> bool:
        memo = {}
        def can_partition(start):
            if start == len(nums):
                return True
            
            if start in memo:
                return memo[start]

            result = False
            
            # Check for subarray of length 2
            if start + 1 < len(nums) and nums[start] == nums[start + 1]:
                result = can_partition(start + 2)

            # Check for subarray of length 3 (equal elements)
            if not result and start + 2 < len(nums) and nums[start] == nums[start + 1] == nums[start + 2]:
                result = can_partition(start + 3)

            # Check for subarray of length 3 (consecutive increasing)
            if not result and start + 2 < len(nums) and nums[start] + 1 == nums[start + 1] and nums[start + 1] + 1 == nums[start + 2]:
                result = can_partition(start + 3)

            # Store the result in memo
            memo[start] = result
            return result
        return can_partition(0)
            
    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * (n + 1)
        dp[0] = True 

        for i in range(1, n + 1):
            # Check for last 2 elements
            if i >= 2 and nums[i - 1] == nums[i - 2]:
                dp[i] = dp[i] or dp[i - 2]

            # Check for last 3 elements (equal)
            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:
                dp[i] = dp[i] or dp[i - 3]

            # Check for last 3 elements (consecutive increasing)
            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 and nums[i - 2] == nums[i - 3] + 1:
                dp[i] = dp[i] or dp[i - 3]

        return dp[n]


--

=========================================================================================================================================


-- Check if there is a valid partition for the array


--
-- https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/


--
from collections import Counter

class Solution:
    def validPartition1(self, nums: List[int]) -> bool:
        memo = {}
        def can_partition(start):
            if start == len(nums):
                return True
            
            if start in memo:
                return memo[start]

            result = False
            
            # Check for subarray of length 2
            if start + 1 < len(nums) and nums[start] == nums[start + 1]:
                result = can_partition(start + 2)

            # Check for subarray of length 3 (equal elements)
            if not result and start + 2 < len(nums) and nums[start] == nums[start + 1] == nums[start + 2]:
                result = can_partition(start + 3)

            # Check for subarray of length 3 (consecutive increasing)
            if not result and start + 2 < len(nums) and nums[start] + 1 == nums[start + 1] and nums[start + 1] + 1 == nums[start + 2]:
                result = can_partition(start + 3)

            # Store the result in memo
            memo[start] = result
            return result
        return can_partition(0)
            


    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * (n + 1)
        dp[0] = True 

        # check for the condition eith subarray ending at index i
        for i in range(1, n + 1):
            # Check for last 2 elements
            if i >= 2 and nums[i - 1] == nums[i - 2]:
                dp[i] = dp[i] or dp[i - 2]

            # Check for last 3 elements (equal)
            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:
                dp[i] = dp[i] or dp[i - 3]

            # Check for last 3 elements (consecutive increasing)
            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 and nums[i - 2] == nums[i - 3] + 1:
                dp[i] = dp[i] or dp[i - 3]

        return dp[n]


--


========================================================================================================================================


-- Reachable nodes with restrictions


--
-- https://leetcode.com/problems/reachable-nodes-with-restrictions/solutions/6002020/using-bfs-beats-80/


--
from collections import defaultdict
class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:

        g = defaultdict(list)
        s = set(restricted)
        for u,v in edges:
            g[u].append(v)
            g[v].append(u)
        
        q = []
        q.append(0)
        vis = [False] * n
        vis[0] = True
        count = 0

        while q:
            temp = q.pop(0)
            count += 1

            for node in g[temp]:
                if node not in s and not vis[node]:
                    q.append(node)
                    vis[node] = True

        return count
--


======================================================================================================================================


-- Maximum number if groups entering a competition


-- https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
--


--
class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        n = len(grades)
        k = 0
        total_students = 0
        
        # find the maximum number of groups
        while total_students + (k + 1) <= n:
            k += 1
            total_students += k
        
        return k
        
--


==========================================================================================================================================


-- Make array zero by subtracting equal amounts


-- https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/
--


--
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        unique_elements = set(nums)
    
        # Remove zero as we only care about positive elements
        if 0 in unique_elements:
            unique_elements.remove(0)
            
        # The number of unique positive elements is the minimum number of operations
        return len(unique_elements)
--


===========================================================================================================================================

-- Equal row and column pairs


-- https://leetcode.com/problems/equal-row-and-column-pairs/submissions/1441938076/
--


--
from collections import defaultdict
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        # frequency count for rows
        m = defaultdict(int)
        cnt = 0
        
        for row in grid:
            m[str(row)] += 1
        
        for i in range(len(grid[0])):
            cols = []

            for j in range(len(grid)):
                cols.append(grid[j][i])
            cnt += m[str(cols)]
        return cnt
--


============================================================================================================================================

-- Number of zero filled subarrays

-- https://leetcode.com/problems/number-of-zero-filled-subarrays/
--


--
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:

        count = 0  # To store the total count of zero-filled subarrays
        current_zeros = 0  # To count the length of current contiguous zeros

        for num in nums:
            if num == 0:
                current_zeros += 1
                count += current_zeros
            else:
                current_zeros = 0  # Reset the zero count if a non-zero element is encountered

        return count
--


==============================================================================================================================================


-- Query kth smallest trimmed number


--
-- https://leetcode.com/problems/query-kth-smallest-trimmed-number/


--
class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        result = []
    
        for k, trim in queries:
            # Trim each number to the rightmost 'trim' digits
            trimmed_nums = [(num[-trim:], i) for i, num in enumerate(nums)]
            
            # Sort the trimmed numbers; Python's sort is stable, so it keeps original order for equal values
            trimmed_nums.sort()
            
            # Get the k-th smallest trimmed number's index (1-indexed query, so k-1)
            result.append(trimmed_nums[k - 1][1])
        
        return result
            
--


==============================================================================================================================================


-- Maximum number of pairs in array


-- https://leetcode.com/problems/maximum-number-of-pairs-in-array/description/
--


--
class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        m = {}
        def get_digit_sum(num):
            csum = 0

            while num > 0:
                temp = num % 10
                csum += temp
                num //= 10
            return csum

        ans = -1
        for num in nums:
            digits = get_digit_sum(num)

            if digits in m:
                ans = max(ans, m[digits] + num)
                m[digits] = max(m[digits], num)
            else:
                m[digits] = num
        return ans
        
--


=================================================================================================================================================

-- Maximum Number of pairs in an array


-- https://leetcode.com/problems/maximum-number-of-pairs-in-array/description/
--


--
class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        count = Counter(nums)
    
        # Step 2: Calculate pairs and leftovers
        pairs = 0
        leftovers = 0
        for value in count.values():
            pairs += value // 2       # Number of pairs for this number
            leftovers += value % 2     # Leftovers for this number
        
        # Step 3: Return result as an array [number of pairs, number of leftovers]
        return [pairs, leftovers]
        
--


=================================================================================================================================================

-- Move pices to obtain a string


-- https://leetcode.com/problems/move-pieces-to-obtain-a-string/
--


--
class Solution:
    def canChange(self, start: str, target: str) -> bool:
        n = len(start)
        i = j = 0
        while i < n or j < n:
            while i < n and start[i] == '_':
                i += 1
            while j < n and target[j] == '_':
                j += 1
            if n in (i, j):
                return i == j == n
            if start[i] != target[j]:
                return False
            if start[i] == 'L':
                if i < j:
                    return False
            else:
                if i > j:
                    return False
            i += 1
            j += 1
        return True
        
--

================================================================================================================================================


-- Smallest number in inifinite sets


-- https://leetcode.com/problems/smallest-number-in-infinite-set/description/
--


--
class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        diff = [abs(nums1[i]-nums2[i]) for i in range(len(nums1))]
        print(diff)
        bucket = Counter(diff)
        print(bucket)
        M = max(diff)
        k = k1+k2
        for j in reversed(range(1,M+1)):
            print(bucket[j])
            minus = min(k,bucket[j])
            bucket[j]-=minus
            bucket[j-1]+=minus
            print(bucket[j-1])
            k-=minus
            if k == 0:
                break
        return sum([count*(d**2) for d,count in bucket.items()])
--


================================================================================================================================================


-- The Latest time to catch a bus


-- https://leetcode.com/problems/the-latest-time-to-catch-a-bus/
--


--
class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        n, m, i = len(buses), len(passengers), 0

        buses.sort()
        passengers.sort()

        for t in buses:
            k = capacity 
            while k and i < m and passengers[i] <= t:
                k -= 1 
                i += 1 

        ans = t if k else passengers[i-1]

        for l in range(i-1,-1,-1):
            if ans == passengers[l]:
                ans -= 1 
            else:
                break 

        return ans 
--


===================================================================================================================================================


-- The latest time to catch a bus


-- https://leetcode.com/problems/the-latest-time-to-catch-a-bus/
--


--
class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        n, m, i = len(buses), len(passengers), 0

        buses.sort()
        passengers.sort()

        for t in buses:
            k = capacity 
            while k and i < m and passengers[i] <= t:
                k -= 1 
                i += 1 

        ans = t if k else passengers[i-1]

        for l in range(i-1,-1,-1):
            if ans == passengers[l]:
                ans -= 1 
            else:
                break 

        return ans 
--


==================================================================================================================================================

-- Evaluate Boolean binary tree


-- https://leetcode.com/problems/evaluate-boolean-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(node):

            if not node.left and not node.right:
                return bool(node.val)
            
            left = dfs(node.left) if node.left else False
            right = dfs(node.right) if node.right else False

            if node.val == 2:
                return left | right
            else:
                return left & right
            return False
        
        return True if dfs(root) else False
            
--


====================================================================================================================================================


-- Number if people aware of a secret


-- https://leetcode.com/problems/number-of-people-aware-of-a-secret/
--


--
class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        mod = 10**9 + 7  # Common modulus for competitive programming
        dp = [0] * (n + forget + 1)  # Dynamic programming array sized for necessary days
        dp[1] = 1  # Day 1 starts with 1 person knowing the secret

        for i in range(1, n + 1):
            # From day i + delay to min(i + forget, n + forget)
            for j in range(i + delay, min(i + forget, n + 1)):
                dp[j] = (dp[j] + dp[i]) % mod

        # Count the people who still know the secret by day n
        ans = 0
        for j in range(max(1, n - forget + 1), n + 1):
            ans = (ans + dp[j]) % mod

        return ans

--


=====================================================================================================================================================


-- Spiral matrix 4


-- https://leetcode.com/problems/spiral-matrix-iv/
--

--
from typing import List, Optional

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        top = 0
        right = n - 1
        bottom = m - 1
        left = 0 

        # Initialize the matrix with -1
        mat = [[-1] * n for _ in range(m)]
        temp = head

        # Fill the matrix in a spiral order
        while top <= bottom and left <= right and temp:
            # Traverse from left to right along the top boundary
            for i in range(left, right + 1):
                if temp:
                    mat[top][i] = temp.val
                    temp = temp.next
            top += 1

            # Traverse from top to bottom along the right boundary
            for i in range(top, bottom + 1):
                if temp:
                    mat[i][right] = temp.val
                    temp = temp.next
            right -= 1

            # Traverse from right to left along the bottom boundary
            for i in range(right, left - 1, -1):
                if temp:
                    mat[bottom][i] = temp.val
                    temp = temp.next
            bottom -= 1

            # Traverse from bottom to top along the left boundary
            for i in range(bottom, top - 1, -1):
                if temp:
                    mat[i][left] = temp.val
                    temp = temp.next
            left += 1

        return mat

--


======================================================================================================================================================


-- Count the number of ways to place houses


-- https://leetcode.com/problems/count-number-of-ways-to-place-houses/
--


--
class Solution:
    def countHousePlacements(self, n: int) -> int:
        prev, pprev = 2,1
        for i in range(1,n):
            temp = pprev+prev
            pprev= prev
            prev = temp
        return (prev**2)%(10**9+7)

class Solution:
    def countHousePlacements(self, n: int) -> int:
        @cache
        def f(i):
            if i >= n:
                return 1

            # Don't use i-th plot
            q1 = f(i+1)
            # Use i-th plot
            q2 = f(i+2)

            return (q1 + q2)%(10**9+7)
        
        return pow(f(0), 2, 10**9+7)
--


===================================================================================================================================================


-- Check if matrix is xmatrix


-- https://leetcode.com/problems/check-if-matrix-is-x-matrix/
--

--
class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:

        n = len(grid)
        
        for i in range(n):
            for j in range(n):
                # Check if the element is on one of the diagonals
                # Non diagonal elements
                if i == j or i + j == n - 1:
                    # Diagonal element must be non-zero
                    if grid[i][j] == 0:
                        return False
                else:
                    # Non-diagonal element must be zero
                    if grid[i][j] != 0:
                        return False
        
        return True
        
--


==================================================================================================================================================

-- Count the unreachable pairs of nodes in an undirected graph


-- https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
--

--
class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:

        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = [False] * n
        component_sizes = []
        
        def dfs(node):
            stack = [node]
            size = 0
            while stack:
                current = stack.pop()
                if not visited[current]:
                    visited[current] = True
                    size += 1
                    for neighbor in graph[current]:
                        if not visited[neighbor]:
                            stack.append(neighbor)
            return size
        
        for i in range(n):
            if not visited[i]:
                component_size = dfs(i)
                component_sizes.append(component_size)
        
        total_pairs = n * (n - 1) // 2
        
        reachable_pairs = 0
        for size in component_sizes:
            reachable_pairs += size * (size - 1) // 2
        
        unreachable_pairs = total_pairs - reachable_pairs
        
        return unreachable_pairs
        
--


=================================================================================================================================================

-- Longest Binary subsequence less than or equal to 


-- https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/description/
--


--
class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        memo = {}

        def dfs(index, current_value, length):
            # Base case: if index is out of bounds
            if index >= n:
                return length
            
            # If already computed, return the memoized result
            if (index, current_value) in memo:
                return memo[(index, current_value)]
            
            # Option 1: Skip the current character
            max_length = dfs(index + 1, current_value, length)
            
            # Option 2: Include the current character, forming a new binary value
            new_value = (current_value << 1) + int(s[index])
            if new_value <= k:
                max_length = max(max_length, dfs(index + 1, new_value, length + 1))
            
            # Memoize and return the result
            memo[(index, current_value)] = max_length
            return max_length
        
        # Start DFS with index 0, initial value 0, and length 0
        return dfs(0, 0, 0)

    def longestSubsequence(self, s: str, k: int) -> int:
        # Work through each digit backwards. (Least significant digit first)
        # With each new digit:
        # If it's a zero, you can just append it to the beginning of each subsequence. EG what was the minimum value for length 3 is now the minimum value for length 4
        # If it's 1, you only want to add it to the largest known sequence to get a known sequence one larger. You don't want to add it to any of the smaller sequences.

        dp = [0]

        for c in reversed(s):
            digit = 0 if c == '0' else 1

            if digit == 0:
                dp = [0] + dp
            else:
                dp.append(dp[-1] + 2 ** (len(dp) - 1))
            print(dp)
        
        for i in range(len(dp)-1, -1, -1):
            if dp[i] <= k:
                return i
--


==============================================================================================================================================

-- Sum of numbers with units digit k (Imp)


-- https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/
--


--
class Solution:
    def minimumNumbers(self, num: int, k: int) -> int:

        if num == 0:
            return 0
        
        # Try to find the minimum size of the set
        for n in range(1, 101):
            if n * k <= num and (num - n * k) % 10 == 0:
                return n
        
        return -1

        
--


===============================================================================================================================================

-- Greatest english letter in upper and lower case


-- https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/
--


--
class Solution:
    def greatestLetter(self, s: str) -> str:

        # use the set to return it efficiently
        # Check for both the letters

        letters = set(s)
        for ch in range(ord('Z'), ord('A') - 1, -1):
            uppercase = chr(ch)
            lowercase = chr(ch + 32)  # Corresponding lowercase
            if uppercase in letters and lowercase in letters:
                return uppercase
        return ""
--


================================================================================================================================================


-- Fair distribution of cookies


-- https://leetcode.com/problems/fair-distribution-of-cookies/
-- https://youtube.com/watch?v=vcaAC2fqFpk


--
class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        res = float('inf')
        dist = [0] * k

        cookies.sort(reverse=True)

        def dfs(i):
            nonlocal res
            if i == len(cookies):
                res = min(res, max(dist))
                return
            if max(dist) >= res:
                return
            for j in range(k):
                if j > 0 and dist[j] == dist[j - 1]:
                    continue
                dist[j] += cookies[i]
                dfs(i + 1)
                dist[j] -= cookies[i]
        
        dfs(0)
        return res
--



=================================================================================================================================================

-- Minimum path cost in a grid


--
-- https://leetcode.com/problems/minimum-path-cost-in-a-grid/

--
class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        dp = [[float('inf')] * n for _ in range(m)]

        for i in range(n):
            dp[0][i] = grid[0][i]

        
        for i in range(m - 1):
            for j in range(n):
                for k in range(n):
                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + moveCost[grid[i][j]][k] + grid[i + 1][k])


        return min(dp[-1])
--


================================================================================================================================================


-- Sucessfull pairs of spells and potions


-- https://leetcode.com/problems/successful-pairs-of-spells-and-potions/
--


--
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        n = len(potions)
        potions.sort()
        
        def custom_binary(min_pos):
            left = 0
            right = n - 1

            while left <= right:
                mid = left + (right - left) // 2

                if potions[mid] >= min_pos:
                    right = mid - 1
                else:
                    left = mid + 1
            return left
        
        res = []
        for s in spells:
            min_pos = (success + s - 1) // s

            min_index = custom_binary(min_pos)
            res.append(n - min_index)
        return res

--


================================================================================================================================================ 


-- Replace elements iin a array


-- https://leetcode.com/problems/replace-elements-in-an-array/
--


--
class Solution:
    def arrayChange(self, nums: List[int], op: List[List[int]]) -> List[int]:
        n = len(nums)
        m = {num: i for i, num in enumerate(nums)}

        for i, j in op:
            index = m[i]
            nums[index] = j
            m[j] = index
            del m[i]
        return nums
--


===============================================================================================================================================


-- Partition array such that maximum diff is k


--
-- https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/


--
class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        nums.sort()

        # choose the element from start and from there check the diff from there to the consecutive elements 
    
        count = 0
        i = 0
        n = len(nums)
        
        # Traverse the sorted array and form subsequences
        while i < n:
            # Start a new subsequence from nums[i]
            start = nums[i]
            count += 1  # New subsequence
            
            # Try to extend this subsequence as much as possible
            while i < n and nums[i] - start <= k:
                i += 1  # Move to the next element
        
        return count
        
--


==============================================================================================================================================


-- Min max game 


--
-- https://leetcode.com/problems/min-max-game/


--
class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        while len(nums) > 1:
            newNums = []
            for i in range(len(nums) // 2):
                if i % 2 == 0:
                    newNums.append(min(nums[2 * i], nums[2 * i + 1]))
                else:
                    newNums.append(max(nums[2 * i], nums[2 * i + 1]))
            nums = newNums
        return nums[0]
        
--


=============================================================================================================================================

-- Steps to make array non -decreasing


--
-- https://leetcode.com/problems/steps-to-make-array-non-decreasing/



--
from typing import List
from collections import Counter

class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        stack = []
        steps = 0

        # Iterate through the list from left to right
        for num in nums:
            max_steps = 0

            # Ensure the stack is in a increasing order
            while stack and stack[-1][0] <= num:
                max_steps = max(max_steps, stack.pop()[1])

            # If there are elements left in the stack, it means this `num` requires additional steps
            if stack:
                max_steps += 1
            else:
                max_steps = 0

            # Update the maximum steps
            steps = max(steps, max_steps)
            stack.append((num, max_steps))

        return steps

--


============================================================================================================================================

-- Apply discount to prices

 
-- https://leetcode.com/problems/apply-discount-to-prices/
--


--
class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:

        _string = sentence.split(" ")

        for i in range(len(_string)):

            if _string[i][0] == '$' and _string[i][1:].isdigit():
                temp = _string[i][1:]
                temp = float(_string[i][1:])  # Convert to float
                temp = temp * (1 - discount / 100)
                _string[i] = "$" + "{:.2f}".format(temp)

        return " ".join(_string)
        
--


==============================================================================================================================================


-- Maximum total importance of roads


-- https://leetcode.com/problems/maximum-total-importance-of-roads/
--


--
class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        # construct an indegree array
        
        degree = [0] * n

        for u, v in roads:
            degree[u] += 1
            degree[v] += 1

        # cities numbers whicha re sorted in descending orders
        sorted_cities = sorted(range(n), key=lambda x: -degree[x])

        # now assign the number from large numbers which start from n
        values = [0] * n
        val = n

        for i in sorted_cities:
            values[i] = val
            val -= 1
        
        # now cal the edges score by using values array
        score = 0

        for u, v in roads:
            score += values[u] + values[v]
        return score
        
--


================================================================================================================================================


-- Sender With Largest Word Count

-- https://leetcode.com/problems/sender-with-largest-word-count/description/
--


--
from collections import defaultdict
from typing import List

class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        n = len(messages)
        m = defaultdict(int)

        maxi = [0, ""]

        for i in range(n):
            count = len(messages[i].split())
            m[senders[i]] += count
            current_count = m[senders[i]]

            if current_count > maxi[0] or (current_count == maxi[0] and senders[i] > maxi[1]):
                maxi = [current_count, senders[i]]

        return maxi[1]

--


================================================================================================================================================


-- Maximum consecutive floors without special floors


-- https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
--

--
class Solution:
    def maxConsecutive1(self, b: int, t: int, special: List[int]) -> int:
        s = set(special)
        max_count = 0
        cnt = 0
        for i in range(b, t + 1):
            if i not in s:
                cnt += 1
                max_count = max(max_count, cnt)
            else:
                cnt = 0
        return max_count

    def maxConsecutive(self, b: int, t: int, special: List[int]) -> int:
        special.sort()

        max_gap = 0
        max_gap = max(max_gap, special[0] - b)

        for i in range(1, len(special)):
            max_gap = max(max_gap, special[i] - special[i - 1] - 1)
            
        max_gap = max(max_gap, t - special[-1])
        return max_gap
--


=================================================================================================================================================


-- Maximum white tiles covered by a carpet


-- https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/
--


--
class Solution1:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        # Step 1: Sort the tiles by their starting position
        tiles.sort()
        
        # Step 2: Calculate prefix sum of tile lengths
        prefix_sum = [0] * (len(tiles) + 1)
        for i in range(len(tiles)):
            l, r = tiles[i]
            prefix_sum[i + 1] = prefix_sum[i] + (r - l + 1)
        
        max_cover = 0
        j = 0  # Start of the window

        # Step 3: Use a sliding window to calculate max coverage
        for i in range(len(tiles)):
            # Carpet starts at tiles[i][0] and ends at tiles[i][0] + carpetLen - 1
            start = tiles[i][0]
            end = start + carpetLen - 1

            # Move j to find the interval where the carpet end can cover
            while j < len(tiles) and tiles[j][1] <= end:
                j += 1
            
            # Total coverage in the fully covered part of the range
            total_cover = prefix_sum[j] - prefix_sum[i]
            
            # If the carpet partially covers the next interval
            if j < len(tiles) and tiles[j][0] <= end:
                total_cover += end - tiles[j][0] + 1
            
            # Update maximum coverage
            max_cover = max(max_cover, total_cover)
        
        return max_cover



from typing import List

class Solution:
    # Time Complexity: O(NlogN)
    # Space Complexity: O(N)
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        ans = 0
        n = len(tiles)

        # Sort the tiles by their starting points
        tiles.sort()

        # Prepare prefix sum array to store total white tiles count for each segment
        arr = [0] * n
        for i in range(n):
            arr[i] = tiles[i][1] - tiles[i][0] + 1
            if i > 0:
                arr[i] += arr[i - 1]

        # Iterate through each tile as the starting point
        for i in range(n):
            leftEnd = tiles[i][0]
            rightEnd = tiles[i][0] + carpetLen - 1

            # Binary search to find the rightmost tile covered by the carpet
            l, r = i, n - 1
            left, right = i, i - 1
            while l <= r:
                mid = (l + r) // 2
                if tiles[mid][1] <= rightEnd:
                    right = mid
                    l = mid + 1
                else:
                    r = mid - 1

            # Calculate the current number of covered tiles
            curr = 0
            if right != i - 1:
                curr += arr[right]
                if left > 0:
                    curr -= arr[left - 1]

            if right + 1 < n:
                curr += max(0, rightEnd - tiles[right + 1][0] + 1)

            ans = max(ans, curr)

        return ans


        




        
--


===================================================================================================================================================


-- Count nodes eqaul to average of subtree


--
-- https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfSubtree(self, root: TreeNode) -> int:
        cnt = 0

        def dfs(node):
            nonlocal cnt
            if not node:
                return (0, 0)  # (sum, count)

            left_sum, left_count = dfs(node.left)
            right_sum, right_count = dfs(node.right)

            total_sum = node.val + left_sum + right_sum
            total_count = 1 + left_count + right_count

            if total_sum // total_count == node.val:
                cnt += 1

            return (total_sum, total_count)


        dfs(root)
        return cnt
        
--


====================================================================================================================================================

-- k divisible elements subarrays


--
-- https://leetcode.com/problems/k-divisible-elements-subarrays/


--
class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        distinct_subarrays = set()  # Use a set to store unique subarrays
    
        # Generate all subarrays
        for start in range(len(nums)):
            count_divisible = 0
            subarray = []
            
            for end in range(start, len(nums)):
                subarray.append(nums[end])
                
                # Check if the current element is divisible by p
                if nums[end] % p == 0:
                    count_divisible += 1
                
                # Only add the subarray to the set if it has at most k divisible elements
                if count_divisible <= k:
                    distinct_subarrays.add(tuple(subarray))
                else:
                    break  # Stop further expansion if divisible count exceeds k
        
        # The answer is the number of distinct subarrays
        return len(distinct_subarrays)
        
--


================================================================================================================================================


-- Count unguarded cells in the grid


-- https://leetcode.com/problems/count-unguarded-cells-in-the-grid/solutions/6030128/easy-beats-75/
--


--
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:

        # contruct the visibility matrix for the guards and place the numbers with they can see that cell

        grid = [[0] * n for _ in range(m)]
    
        # Constants for cell state
        EMPTY = 0
        GUARD = 1
        WALL = 2
        GUARDED = 3

        for i, j in walls:
            grid[i][j] = WALL
        for i, j in guards:
            grid[i][j] = GUARD

        def mark_guarded(r, c, dr, dc):
            while 0 <= r < m and 0 <= c < n:
                if grid[r][c] == WALL or grid[r][c] == GUARD:
                    break
                if grid[r][c] == EMPTY:
                    grid[r][c] = GUARDED
                r += dr
                c += dc
            
        

        for r, c in guards:
            mark_guarded(r - 1, c, -1, 0)
            mark_guarded(r + 1, c, 1, 0) 
            mark_guarded(r, c - 1, 0, -1) 
            mark_guarded(r, c + 1, 0, 1)

        cnt = 0
        for r in range(m):
            for c in range(n):
                if grid[r][c] == EMPTY:
                    cnt += 1
        
        return cnt

        
--


================================================================================================================================================


-- Minimum average diff


-- https://leetcode.com/problems/minimum-average-difference/
--


--
class Solution:
    def minimumAverageDifference(self, nums: List[int]) -> int:
        n = len(nums)
        total_sum = sum(nums)
        prefix_sum = 0
        min_diff = float('inf')
        min_index = -1

        for i in range(n):
            # Add the current element to the prefix sum
            prefix_sum += nums[i]

            # Calculate the first part's average
            left_avg = prefix_sum // (i + 1)

            # Calculate the second part's average
            if i == n - 1:
                right_avg = 0  # No elements on the right for the last index
            else:
                right_avg = (total_sum - prefix_sum) // (n - i - 1)
            
            # Calculate the absolute difference
            diff = abs(left_avg - right_avg)
            
            # Update the minimum difference and index if necessary
            if diff < min_diff:
                min_diff = diff
                min_index = i

        return min_index




--

=============================================================================================================================================


-- Count lattice points inside a circle


-- https://leetcode.com/problems/count-lattice-points-inside-a-circle/
--


--
class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        points = set()
    
        # Iterate over each circle
        for x_center, y_center, radius in circles:
            # Determine the range of x and y to check around the circle's center
            for x in range(x_center - radius, x_center + radius + 1):
                for y in range(y_center - radius, y_center + radius + 1):
                    # Check if the point (x, y) is inside or on the circle
                    if (x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2:
                        # Add the point to the set if it is within the circle
                        points.add((x, y))
        
        # The result is the number of unique points in the set
        return len(points)
        
--

==============================================================================================================================================


-- Cal digit sum of a string



--
-- https://leetcode.com/problems/calculate-digit-sum-of-a-string/



--
class Solution:
    def digitSum(self, s: str, k: int) -> str:
        while len(s) > k:
            # Create a new string by processing groups of size k
            new_s = ""
            
            # Process each group of size k
            for i in range(0, len(s), k):
                group = s[i:i+k]
                group_sum = sum(int(char) for char in group)
                new_s += str(group_sum)
            
            # Update s to be the new string
            s = new_s
        
        return s
        
--


==============================================================================================================================================


-- Find closest number to zero


-- https://leetcode.com/problems/find-closest-number-to-zero/
--


--
class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        closest = float('inf')  # Initialize with a large value
        for num in nums:
            # Check if current number is closer to 0, or if it's the same distance but larger
            if abs(num) < abs(closest) or (abs(num) == abs(closest) and num > closest):
                closest = num
        return closest
--


==============================================================================================================================================

-- ways to split array into good subarrays



-- https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/
--


--
class Solution:
    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        # Find positions of all `1`s in the array
        positions = [i for i, num in enumerate(nums) if num == 1]
        
        # If there is only one `1`, we have exactly one good subarray
        if len(positions) == 1:
            return 1
        # If there are no `1`s, or only one `1`, there are no good subarrays
        elif len(positions) == 0:
            return 0
        
        # Calculate the number of ways to split between each consecutive pair of `1`s
        ways = 1
        for i in range(1, len(positions)):
            gap = positions[i] - positions[i - 1] - 1
            ways = (ways * (gap + 1)) % MOD
        
        return ways

        
--


==============================================================================================================================================


-- prime pairs with target sum


-- https://leetcode.com/problems/prime-pairs-with-target-sum/
--


--
class Solution:
    def findPrimePairs2(self, n: int) -> List[List[int]]:
        if n <= 2:
            return []

        def is_prime(n):
            if n <= 1:
                return False
            if n <= 3:
                return True  # 2 and 3 are prime
            if n % 2 == 0 or n % 3 == 0:
                return False  # eliminate multiples of 2 and 3

            # Check from 5 to sqrt(n), only for odd numbers (6k ± 1)
            for i in range(5, int(math.sqrt(n)) + 1, 6):
                if n % i == 0 or n % (i + 2) == 0:
                    return False
            return True
        
        res = []
        s = set()
        for i in range(n + 1):
            if i not in s and is_prime(i) and is_prime(n - i) :
                s.add(n - i)
                res.append((i, n - i))
        return res

    def findPrimePairs(self, n: int) -> List[List[int]]:
    
        def sieve_of_eratosthenes(limit):
            # Create a boolean array "is_prime[0..limit]" and initialize all entries as True.
            is_prime = [True] * (limit + 1)
            is_prime[0], is_prime[1] = False, False  # 0 and 1 are not prime numbers
            p = 2
            while p * p <= limit:
                # If is_prime[p] is not changed, then it is a prime
                if is_prime[p]:
                    # Update all multiples of p to not prime
                    for i in range(p * p, limit + 1, p):
                        is_prime[i] = False
                p += 1
            # Extract all primes up to limit
            return [num for num, prime in enumerate(is_prime) if prime]

        if n < 2:
            return []
        
        primes = sieve_of_eratosthenes(n)
        prime_set = set(primes)  # For quick lookup
        result = []
        
        for x in primes:
            y = n - x
            # Check if x <= y and y is also a prime number
            if x <= y and y in prime_set:
                result.append([x, y])
        
        return result

        
--


==================================================================================================================================================


-- continuous subarrays 

-- https://leetcode.com/problems/continuous-subarrays/submissions/1453729592/
-- https://www.youtube.com/watch?v=vITY72Cpkbc


--
class Solution:
    def continuousSubarrays1(self, nums: List[int]) -> int:
        q1 = deque()
        q2 = deque()
        q3 = deque()
        ans = 1
        l = 1
        k = nums[0]
        q1.append(0)

        for i in range(1, len(nums)):
            n = nums[i]
            if k <= n <= k + 2:
                l += 1
                ans += l
                if n == k:
                    q1.append(i)
                elif n == k + 1:
                    q2.append(i)
                else:
                    q3.append(i)
            elif n < k - 2 or n > k + 4:
                q1 = deque()
                q2 = deque()
                q3 = deque()
                q1.append(i)
                l = 1
                ans += 1
                k = n
            elif n == k - 1:
                start = 0 if len(q3) == 0 else q3[-1]
                while len(q1) != 0 and q1[0] < start: q1.popleft()
                while len(q2) != 0 and q2[0] < start: q2.popleft()
                q3 = q2
                q2 = q1
                q1 = deque()
                q1.append(i)
                l = len(q2) + len(q3) + 1
                ans += l
                k = n
            elif n == k - 2:
                start = 0 if len(q3) == 0 else q3[-1]
                start = start if len(q2) == 0 or (q2[-1] < start) else q2[-1]
                while len(q1) != 0 and q1[0] < start: q1.popleft()
                q3 = q1
                q2 = deque()
                q1 = deque()
                q1.append(i)
                k = n
                l = len(q3) + 1
                ans += l
            elif n == k + 3:
                start = 0 if len(q1) == 0 else q1[-1]
                while len(q2) != 0 and q2[0] < start: q2.popleft()
                while len(q3) != 0 and q3[0] < start: q3.popleft()
                if len(q2) == 0:
                    if len(q3) == 0:
                        q1 = deque()
                        q2 = deque()
                        q3 = deque()
                        q1.append(i)
                        l = 1
                        ans += 1
                        k = n
                    else:
                        q1 = q3
                        q2 = deque()
                        q3 = deque()
                        q2.append(i)
                        l = len(q1) + 1
                        ans += l
                        k = n-1
                else:
                    q1 = q2
                    q2 = q3
                    q3 = deque()
                    q3.append(i)
                    l = len(q1) + len(q2) + 1
                    ans += l
                    k = n - 2
            # elif n == k + 4:
            else:
                start = 0 if len(q1) == 0 else q1[-1]
                start = start if len(q2) == 0 or (q2[-1] < start) else q2[-1]
                while len(q3) != 0 and q3[0] < start: q3.popleft()
                if len(q3) == 0:
                    q1 = deque()
                    q2 = deque()
                    q3 = deque()
                    q1.append(i)
                    l = 1
                    ans += 1
                    k = n
                else:
                    q1 = q3
                    q2 = deque()
                    q3 = deque()
                    q3.append(i)
                    k = n - 1
                    l = len(q1) + 1
                    ans += l
            
        return ans

    def continuousSubarrays(self, nums: List[int]) -> int:
        # using two monotonic queue to store the elment in increasing and decreasing order

        q1 = [] # monotonic decrasing means large element at first
        q2 = [] # monotonic increasing means small element at first

        left = 0
        n = len(nums)
        ans = 0

        for right in range(n):

            while q1 and q1[-1] < nums[right]:
                q1.pop()

            while q2 and q2[-1] > nums[right]:
                q2.pop()

            q1.append(nums[right])
            q2.append(nums[right])

            while q1[0] - q2[0] > 2:
                if q1[0] == nums[left]:
                    q1.pop(0)
                if q2[0] == nums[left]:
                    q2.pop(0)
                left += 1


            ans += right - left + 1

        return ans
    

--


=================================================================================================================================================

-- Relocate Marbles


-- https://leetcode.com/problems/relocate-marbles/
--


--
class Solution:
    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
        positions = set(nums)
        
        # Process each move
        for from_pos, to_pos in zip(moveFrom, moveTo):
            if from_pos in positions:
                positions.remove(from_pos)
            positions.add(to_pos) 
        
        return sorted(positions)
--


================================================================================================================================================


-- Partition string into minimum beautiful substrings


-- https://leetcode.com/problems/partition-string-into-minimum-beautiful-substrings/
--


--
class Solution:
    def minimumBeautifulSubstrings(self, s: str) -> int:
        # recursion
        n = len(s)
        dp = [-1] * n

        def check_power(num):
            if num == 0:
                return False
            while num % 5 == 0:
                num //= 5
            return num == 1

        def dfs(index):
            if index == n:
                return 0  # Found a valid partition

            if s[index] == '0':
                return float('inf')  # Invalid partition

            if dp[index] != -1:
                return dp[index]

            ans = float('inf')
            val = 0

            for i in range(index, n):
                val = val * 2 + int(s[i])
                if check_power(val):
                    ans = min(ans, 1 + dfs(i + 1))
            dp[index] = ans
            return ans

        ans = dfs(0)
        return -1 if ans > n else ans
--

=================================================================================================================================================


-- Maximum number of jumps to reach the last index



-- https://leetcode.com/problems/maximum-number-of-jumps-to-reach-the-last-index/
--


--
class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        n = len(nums)
        ans = -1
        dp = [[-1]]

        def dfs(index, steps, target):
            nonlocal ans
            if index == n - 1:
                ans = max(ans, steps)
                return 
            
            if dp[index][steps] != -1:
                return dp[index][steps]
            
            for i in range(index + 1, n):
                temp = nums[i] - nums[index]

                if temp >= -target and temp <= target:
                    dfs(i, steps + 1, target) 
        dfs(0, 0, target)
        return ans

    
from typing import List

class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        n = len(nums)
        dp = [-1] * n
        dp[0] = 0  # Starting index requires 0 jumps

        # Iterate over all pairs of indices to calculate jumps
        for i in range(n):
            if dp[i] == -1:
                continue  # Skip if the current index is unreachable

            for j in range(i + 1, n):
                if -target <= nums[j] - nums[i] <= target:
                    dp[j] = max(dp[j], dp[i] + 1)

        return dp[-1]


--


=================================================================================================================================================

-- Longest non decreasing subarray from two arrays

 
-- https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/
--


--
class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        @cache
        def dp(i, prev):
            if i == len(nums1):
                return 0
            
            res = 0
            if not prev:
                res = dp(i + 1, prev)
            
            if prev <= nums1[i]:
                res = max(res, 1 + dp(i + 1, nums1[i]))
            if prev <= nums2[i]:
                res = max(res, 1 + dp(i + 1, nums2[i]))
            return res
        return dp(0, 0)
--


================================================================================================================================================== 


-- Zero array transformation (Imp)


--
--


--
class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:

        def checker(k):
            temp = [0] * (len(nums) + 1)
            n = len(nums)
            
            loop = min(k, len(queries))
            for i in range(loop):
                l = queries[i][0]
                r = queries[i][1]
                val = queries[i][2]

                temp[l] += val

                if r + 1 < n:
                    temp[r + 1] -= val


            current_decrement = 0
            nums_copy = nums[:]
            for i in range(n):
                current_decrement += temp[i]
                nums_copy[i] -= current_decrement
                if nums_copy[i] < 0:
                    nums_copy[i] = 0

            return all(x == 0 for x in nums_copy)

        left = 0
        right = len(queries)
        ans = -1
        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans

        
        
--


=================================================================================================================================================

--  Continuous subarray sum (Imp)


 
-- https://www.youtube.com/watch?v=OKcrLfR-8mE
-- https://leetcode.com/problems/continuous-subarray-sum/



--
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:

        # calculate the prefix by moding with each element 
        # if the remainder is already present then the numbers between the index gives the answer

        # store the remainder : index in the map

        prefix_map = {0: -1}
        prefix = 0

        for i, num in enumerate(nums):
            prefix += num
            mod = prefix % k

            if mod < 0:
                mod += k

            if mod in prefix_map:
                if i - prefix_map[mod] > 1:
                    return True
            else:
                prefix_map[mod] = i
        return False
--


==============================================================================================================================================

-- Longest word in dictinary through deleting (Imp)


--
-- https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/


--
class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:

        dictionary.sort(key=lambda word: (-len(word), word))
    
        def canForm(word, s):
            it = iter(s)
            return all(char in it for char in word)
        
        # Iterate over the sorted dictionary and find the first word that can be formed
        for word in dictionary:
            if canForm(word, s):
                return word
        
        return ""
        
--


===============================================================================================================================================


-- Beautiful Arrangement



-- https://leetcode.com/problems/beautiful-arrangement/
--

--
class Solution:
    def countArrangement(self, n: int) -> int:

        def back(index):
            if index > n:
                return 1

            count = 0
            for i in range(1, n + 1):
                if not used[i] and (i % index == 0 or index % i == 0):
                    used[i] = True
                    count += back(index + 1)
                    used[i] = False
            return count

        
        used = [False] * (n + 1)
        return back(1)
        
--


================================================================================================================================================


-- Min positive sum subarray


-- https://leetcode.com/problems/minimum-positive-sum-subarray/
--


--
class Solution1:
    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:
        n = len(nums)
        minimum_sum = float("inf")
        
        for i in range(n):
            for j in range(i, n):
                csum = sum(nums[i: j + 1])
                if j - i + 1 >= l and j - i + 1 <= r and minimum_sum > csum and csum > 0:
                    minimum_sum = csum 
        
        return minimum_sum if minimum_sum != float("inf") else -1

from typing import List

class Solution:
    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:
        n = len(nums)
        min_sum = float('inf')  # Equivalent to INT_MAX in C++
        found = False

        # for every length l to r take the sum of all subarrays and get the answer if positive
        for length in range(l, r + 1):
            current_sum = sum(nums[:length])  # Compute the sum of the first 'length' elements

            if current_sum > 0:
                min_sum = min(min_sum, current_sum)
                found = True

            # Slide the window across the array
            for i in range(length, n):
                current_sum += nums[i] - nums[i - length]

                if current_sum > 0:
                    min_sum = min(min_sum, current_sum)
                    found = True

        return min_sum if found else -1
--


===============================================================================================================================================


-- Zero Array Transformation III


--
-- https://leetcode.com/problems/zero-array-transformation-iii/


--
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        ans = 0
        q = sorted(queries)
        e = defaultdict(int)
        curr = 0
        for i, num in enumerate(nums):

            if num<=curr:
                curr -= e[i]
                continue

            p = []
            for j, pq in enumerate(q):
                if pq[0]>i:
                    break
                if pq[1]>=i:
                    p.append((pq[1],j))
                    
            p.sort(key = lambda x:-x[0])
            index = set()

            while p and q and num > curr:
                ind = p.pop(0)[1]
                x,y = q[ind]
                index.add(ind)
                if x>i:
                    break
                if y<i:
                    continue
                ans += 1
                curr += 1
                e[y] += 1
            q = [q[i] for i in range(len(q)) if i not in index]
            if num>curr:
                return -1
            curr -= e[i]
        return len(queries)-ans
        
--


=================================================================================================================================================

-- Count k reducible numbers less than n


-- https://leetcode.com/problems/count-k-reducible-numbers-less-than-n/
--


--
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        count_1 = s.count("1")
        
        @cache
        def is_count_1_valid(num, limit):
            if num == 1:
                return True
            if limit == 0:
                return False
            return is_count_1_valid(bin(num).count("1"), limit - 1)
        
        res = 0 
        MOD = 10 ** 9 + 7
        for i in range(len(s) - 1, -1, -1):
            if s[i] == '1':
                count_1 -= 1
                length = len(s) - i - 1
                for j in range(length + 1):
                    if is_count_1_valid(count_1 + j, k - 1):
                        res += math.comb(length, j)   ## O(n)
                        res = res % MOD
        return res
--


================================================================================================================================================


-- Total characters in string after transformations - 1


-- https://leetcode.com/problems/total-characters-in-string-after-transformations-i/
--

--

mod = 1_000_000_007

class Solution:
    def lengthAfterTransformations(self, s: str, t: int) -> int:
        queue = deque([0] * 26)   
        for ch in s: 
            queue[ord(ch) - ord('a')] += 1


        # pop from the left and add it to place of a and b
        for i in range(t): 
            queue[0]+= queue[25]
            queue.appendleft(queue.pop())
            
        return sum(queue) %mod  
--


================================================================================================================================================

-- Find the maximum factor score of arrya


--
-- https://leetcode.com/problems/find-the-maximum-factor-score-of-array/submissions/1466476478/



--
class Solution:
    def maxScore(self, nums: List[int]) -> int:

        n, ctr = len(nums), Counter(nums)

        mx = gcd(*nums) * lcm(*nums)
        if n > 1:
            for i in range(n):
                # if the frequency of the that element is greater than 1 then dont consider it at all
                if ctr[nums[i]] > 1: continue

                arr = nums[:i] + nums[i + 1:]
                mx = max(mx, gcd(*arr) * lcm(*arr))
        return mx

--

================================================================================================================================================


-- Maximum points tourist can earn



--
-- https://leetcode.com/problems/maximum-points-tourist-can-earn/


--
class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        # take every single choice and go to every city and get the max
        @cache
        def fn(current_index, day):
            if day >= k:
                return 0

            ans = 0

            for i in range(n):
                if i == current_index:
                    ans = max(ans, stayScore[day][current_index] + fn(current_index, day + 1))
                
                else:
                    ans = max(ans, stayScore[day][current_index] + fn(current_index, day + 1), travelScore[current_index][i] + fn(i, day + 1)) # stay or travel

            return ans
            
        ans = 0
        for i in range(n):
            ans = max(ans, fn(i, 0))
        
        return ans


class Solution:
    def maxScore(
        self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]
    ) -> int:
        dp = [0 for _ in range(n)]

        for i in reversed(range(k)):
            temp = dp.copy()
            dp = [
                max(
                    stayScore[i][curr] + dp[curr],
                    max(travelScore[curr][dest] + dp[dest] for dest in range(n)),
                )
                for curr in range(n)
            ]

        return max(dp)
--


================================================================================================================================================

-- Find subtree sizes after changes (Imp)


-- https://leetcode.com/problems/find-subtree-sizes-after-changes/
--

--


class Solution:
    def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        
        for i in range(1, n):
            children[parent[i]].append(i)
        
        stack = [[] for _ in range(26)]

        def dfs0(i: int):
            index = ord(s[i]) - 97

            if len(stack[index]):
                parent[i] = stack[index][-1]

            stack[index].append(i)

            for j in children[i]:
                dfs0(j)

            stack[index].pop()
        
        dfs0(0)
        ret = [0] * n
        children = [[] for _ in range(n)]

        for i in range(1, n):
            children[parent[i]].append(i)

        def dfs1(i: int) -> int:
            cnt = 1
            for j in children[i]:
                cnt += dfs1(j)
            ret[i] = cnt
            return cnt
        
        for i in range(n):
            if ret[i] == 0:
                dfs1(i)
        
        return ret
--


==============================================================================================================================================

-- Find the original typed string I


-- https://leetcode.com/problems/find-the-original-typed-string-i/
--


--
class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 0
        prev = ""
        for c in word:
            if c == prev:
                count += 1
            prev = c
        return count + 1
            
--

==============================================================================================================================================

-- kth largest perfect subtree size in a binary tree


-- https://leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree/
--


-
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        size = []
        def fn(node):
            if not node:
                # height, isPerfect
                return (0, True)
            
            left_size, left_perfect = fn(node.left)
            right_size, right_perfect = fn(node.right)

            if left_size == right_size and left_perfect and right_perfect:
                temp = 2 ** (left_size + 1) - 1
                size.append(temp)
                return (left_size + 1, True)
            return (0, False)

        fn(root)
        size.sort(reverse=True)
        print(size)
        return size[k - 1] if k <= len(size) else -1

        
-


=============================================================================================================================================


-- Find x-sum of all k-long subarrays I


-- https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/description/
--


--
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from collections import Counter
        import heapq
        
        def x_sum(subarray):
            freq = Counter(subarray)
            # Get the top x most frequent elements
            most_common = heapq.nlargest(x, freq.items(), key=lambda item: (item[1], item[0]))
            # Sum of the elements, keeping only top x frequent ones
            result = sum(value * count for value, count in most_common)
            return result

        result = []
        for i in range(len(nums) - k + 1):
            subarray = nums[i:i + k]
            result.append(x_sum(subarray))

        return result
--


=============================================================================================================================================


-- Identify the largest outlier in a array


-- https://leetcode.com/problems/identify-the-largest-outlier-in-an-array/
--


--
from collections import Counter

class Solution:
    def getLargestOutlier(self, nums: List[int]) -> int:
        
    #         Why it's important: We are given that one element is the sum of the "special numbers" (which are the sum of two other numbers), and another element is an "outlier" (which doesn't fit the other two categories). To figure out which element is the outlier, we need to compare it against the sum of the remaining elements. By having the total sum of the array, we can check for each potential outlier whether the remaining sum is even and fits the criteria for the sum of the special numbers.

    # Why subtracting each number works: The strategy is to remove one element at a time, and the remaining sum must be checked for validity. If the remaining sum is even, we check if it’s double some number, which would correspond to the sum of the two special numbers.

        total_sum = sum(nums)  # Step 1: Calculate the sum of all elements
        m = defaultdict(list)
        
        for index, num in enumerate(nums):
            m[num].append(index)
        
        largest_outlier = None

        print(m)
        
        for x in nums:
            remaining_sum = total_sum - x
            
            if remaining_sum % 2 == 0:
                half_sum = remaining_sum // 2
                
                if half_sum in m:
                    indices = m[half_sum]
                    
                    if len(indices) > 1 or (len(indices) == 1 and indices[0] != nums.index(x)):
                        largest_outlier = max(largest_outlier, x) if largest_outlier is not None else x
        
        return largest_outlier
        
--


==============================================================================================================================================


-- Find maximum removals from source string


-- https://leetcode.com/problems/find-maximum-removals-from-source-string/
--

--
from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        # Convert targetIndices to a set for quick lookup
        indx = set(targetIndices)
        n = len(source)
        m = len(pattern)

        # dp[i][j] will store the maximum removals we can achieve with source[0:i] and pattern[0:j]
        dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)] 

        # DFS function with memoization
        def dfs(i, j):
            if i == n:  # If source is exhausted but pattern isn't fully matched
                if j == m:  # If all characters of pattern are matched
                    return 0
                return float('-inf')
            if dp[i][j] != -1:  # If already computed, return the cached value
                return dp[i][j]

            # Skip the current character from source string (i.e., do not match)
            ans = dfs(i + 1, j)

            # If current character in source is to be removed (present in targetIndices)
            if i in indx:
                ans = max(ans, 1 + dfs(i + 1, j))

            # If current characters match, move both pointers forward
            if i < n and j < m and source[i] == pattern[j]:
                ans = max(ans, dfs(i + 1, j + 1))

            dp[i][j] = ans
            return ans

        # Start DFS from the beginning of both strings
        result = dfs(0, 0)

        # If no valid removals can make source match pattern, return 0
        return result if result >= 0 else 0


class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        target_set = set(targetIndices)
        INF = float('inf')
        dp = [INF] * (m + 1)
        dp[0] = 0 

        for i in range(n):
            for j in range(min(i+1, m)-1, -1, -1):
                if source[i] == pattern[j]:
                    cost = dp[j] + (1 if i in target_set else 0)
                    if dp[j + 1] > cost:
                        dp[j + 1] = cost

        if dp[m] == INF:
            return 0  
        else:
            return len(targetIndices) - dp[m]
--


=============================================================================================================================================


-- Construct the minimum bitwise array 2


-- https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/
--


--
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # intuition is take the num and unset the leftmost bit untill u reach the 0

        # in the sense 1 0 0 1 1 here unset the 1 at position 2 from right
        # ie           1 0 0 0 1  and add +1 to this value and do OR between the two

        def fn(num):
            # traverse through the 32 bit number store the last_set_bit
            last_set_bit = 0
            for i in range(32):
                if num & (1 << i):
                    last_set_bit = i
                else:
                    break

                mask = (1 << last_set_bit)
                mask = ~mask & num
            return mask 

        ans = []
        for num in nums:

            if num == 2:
                ans.append(-1)
                continue
            temp = fn(num)
            ans.append(temp)
        return ans
--


==========================================================================================================================================


-- Maximum energy boost from two drinks


--
-- https://leetcode.com/problems/maximum-energy-boost-from-two-drinks/


--
class Solution:
    def maxEnergyBoost1(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:
        # 2 choices take the current drink or change the drink

        n = len(energyDrinkA)
        dp = [[-1] * 2 for _ in range(n)]
        def fn(i, prev):
            if i >= n:
                return 0
            
            if dp[i][prev] != -1:
                return dp[i][prev]
            
            ans = 0
            if prev == 1:
                ans = max(energyDrinkA[i] + fn(i + 1, prev), fn(i + 1, 1 - prev))
            else:
                ans = max(energyDrinkB[i] + fn(i + 1, prev), fn(i + 1, 1 - prev))
            dp[i][prev] = ans
            return ans
        
        return max(fn(0, 1), fn(0, 0))

    def maxEnergyBoost(self, A: List[int], B: List[int]) -> int:
        n = len(A)
        dp = [[0] * 2 for _ in range(n + 5)]

        for i in range(n - 1, -1, -1):
            dp[i][0] = max(A[i] + dp[i + 1][0], dp[i + 1][1])
            dp[i][1] = max(B[i] + dp[i + 1][1], dp[i + 1][0])

        return max(dp[0][1], dp[0][0])

--


============================================================================================================================================


-- Special permutations


-- https://leetcode.com/problems/special-permutations/
-- https://www.youtube.com/watch?v=c4WRWUuBLBA

-
class Solution:
    mod = 10**9 + 7
    def specialPerm(self, nums: List[int]) -> int:
        # using bit mask with dp to optimize the code
        # prevIndex x mask -> mask can go up to 2^14 - 1 since n is 14

        # so the dp will be n x 2^14
        # mask is the index or bit representing the particular index in nums which is considered or not
        # ex -> 2, 4, 5 -> 1 0 1 -> in this the num 2 and 5 are considered
        n = len(nums)
        
        def fn(prevIndex, mask, count):
            if count == len(nums):
                return 1

            if dp[prevIndex][mask] != -1:
                return dp[prevIndex][mask]

            ways = 0

            for i in range(len(nums)):
                # checking if that particular index is already considered when creating permutations
                if mask & (1 << i):
                    continue

                if mask == 0 or nums[prevIndex] % nums[i] == 0 or nums[i] % nums[prevIndex] == 0:
                    ways = (ways + fn(i, mask | (1 << i), count + 1)) % self.mod
            dp[prevIndex][mask] = ways
            return ways


        dp = [[-1] * (1 << n) for _ in range(n)]
        # prevIndex, mask, count
        mask = 0
        count = 0
        prev = 0
        return fn(prev, mask, count)


        
        
-


============================================================================================================================================


-- Find the value of the partition


-- https://leetcode.com/problems/find-the-value-of-the-partition/
--


--
class Solution:
    def findValueOfPartition(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()
        res = nums[1] - nums[0]
        for i in range(1, n-1):
            if nums[i+1] - nums[i] < res:
                res = nums[i+1] - nums[i]
        return res 
        
--


==========================================================================================================================================

-- Total distance travelled


--
-- https://leetcode.com/problems/total-distance-traveled/


--
class Solution:
    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
        total_distance = 0

        while mainTank >= 5:
            total_distance += 50
            mainTank -= 5
            if additionalTank > 0:
                mainTank += 1
                additionalTank -= 1
                
        total_distance += mainTank * 10
        return total_distance
        
--

=======================================================================================================================================

-- Longest palindromic substring (Imp)


--
-- https://leetcode.com/problems/longest-palindromic-substring/?envType=problem-list-v2&envId=954v5ops


--
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""

        def expand_around_center(s: str, left: int, right: int):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return right - left - 1


        start = 0
        end = 0

        for i in range(len(s)):
            # for odd length expand from middle of the string
            odd = expand_around_center(s, i, i)

            # for even length expand from the middle but from the i, i+1
            even = expand_around_center(s, i, i + 1)
            max_len = max(odd, even)
            
            if max_len > end - start:
                start = i - (max_len - 1) // 2
                end = i + max_len // 2
        
        return s[start:end+1]
--


=======================================================================================================================================

-- String to integer atoi


-- https://leetcode.com/problems/string-to-integer-atoi/?envType=problem-list-v2&envId=954v5ops
--


--
class Solution:
    def myAtoi(self, s: str) -> int:
        INT_MAX, INT_MIN = 2**31 - 1, -2**31
        i, n = 0, len(s)
        # Step 1: Skip leading whitespace
        while i < n and s[i] == ' ':
            i += 1

        # Step 2: Check for optional sign
        sign = 1
        if i < n and s[i] == '-':
            sign = -1
            i += 1
        elif i < n and s[i] == '+':
            i += 1

        # Step 3: Convert digits to integer
        result = 0
        while i < n and s[i].isdigit():
            digit = int(s[i])
            # Check for overflow
            if result > (INT_MAX - digit) // 10:
                return INT_MAX if sign == 1 else INT_MIN
            result = result * 10 + digit
            i += 1
        
        return sign * result
--


=====================================================================================================================================


-- reorganize string


-- https://leetcode.com/problems/reorganize-string/?envType=problem-list-v2&envId=954v5ops
--


--
class Solution:
    def reorganizeString(self, s: str) -> str:
        freq_map = Counter(s)
    
        # Create a max-heap based on the frequency of characters
        max_heap = []
        for char, freq in freq_map.items():
            heappush(max_heap, (-freq, char))  # Push with negative frequency for max-heap behavior
        
        result = []
        prev_char = None
        prev_freq = 0  # Track previous character and its remaining frequency
        
        while max_heap:
            freq, char = heappop(max_heap)  # Get the most frequent character
            
            # Append the current character to the result
            result.append(char)
            
            # If the previous character has remaining frequency, push it back
            if prev_freq < 0:
                heappush(max_heap, (prev_freq, prev_char))
            
            # Update prev_char and prev_freq for the next iteration
            prev_char = char
            prev_freq = freq + 1  # Decrement frequency (because it was negative)
        
        # If the rearranged string's length doesn't match the original, return ""
        return "".join(result) if len(result) == len(s) else ""
--


======================================================================================================================================


-- game of life


-- https://leetcode.com/problems/game-of-life/?envType=problem-list-v2&envId=954v5ops
-


--
class Solution:
    def gameOfLife(self, b: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(b)
        n = len(b[0])

        # you can also do it with another matrix but 
        # lets not use it
        # 0 - 0 -> was zero and remains dead
        # 1 - 1 -> was live and remain live
        # 1 - (-1) -> alice to dead
        # 0 - 2 -> dead to live
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1),(1, -1), (1, 0), (1, 1)]

        # count number of live 
        def fn(r, c):
            live_neighbors = 0
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n and abs(b[nr][nc]) == 1:
                    live_neighbors += 1
            return live_neighbors

        for i in range(m):
            for j in range(n):
                live_nei = fn(i, j)

                if b[i][j] == 1:
                    if live_nei < 2 or live_nei > 3:
                        b[i][j] = -1
                else:
                    if live_nei == 3:
                        b[i][j] = 2
        
        for i in range(m):
            for j in range(n):
                if b[i][j] > 0:
                    b[i][j] = 1
                else:
                    b[i][j] = 0

        return b
        
--


=======================================================================================================================================


-- Pacific atlantic water flow


-- https://leetcode.com/problems/pacific-atlantic-water-flow/?envType=problem-list-v2&envId=954v5ops
--


--
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights or not heights[0]:
            return []

        m, n = len(heights), len(heights[0])

        # Helper function to perform DFS
        def dfs(row, col, visited, prev_height):
            # Base conditions for DFS
            if (row < 0 or row >= m or col < 0 or col >= n or
                    (row, col) in visited or heights[row][col] < prev_height):
                return
            visited.add((row, col))
            # Explore all four directions
            for dr, dc in directions:
                dfs(row + dr, col + dc, visited, heights[row][col])

        pacific_reachable = set()
        atlantic_reachable = set()
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        # Perform DFS from all cells adjacent to the Pacific and Atlantic oceans
        for i in range(m):
            dfs(i, 0, pacific_reachable, heights[i][0])  # Left edge (Pacific)
            dfs(i, n - 1, atlantic_reachable, heights[i][n - 1])  # Right edge (Atlantic)
        for j in range(n):
            dfs(0, j, pacific_reachable, heights[0][j])  # Top edge (Pacific)
            dfs(m - 1, j, atlantic_reachable, heights[m - 1][j])  # Bottom edge (Atlantic)

        # Find cells that can reach both oceans
        result = list(pacific_reachable & atlantic_reachable)
        return result
--


======================================================================================================================================

-- Pacific atlantic water flow


--
-- https://leetcode.com/problems/pacific-atlantic-water-flow/?envType=problem-list-v2&envId=954v5ops


--
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights or not heights[0]:
            return []

        m, n = len(heights), len(heights[0])

        # Helper function to perform DFS
        def dfs(row, col, visited, prev_height):
            # Base conditions for DFS
            if (row < 0 or row >= m or col < 0 or col >= n or
                    (row, col) in visited or heights[row][col] < prev_height):
                return
            visited.add((row, col))
            # Explore all four directions
            for dr, dc in directions:
                dfs(row + dr, col + dc, visited, heights[row][col])

        pacific_reachable = set()
        atlantic_reachable = set()
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        # Perform DFS from all cells adjacent to the Pacific and Atlantic oceans
        for i in range(m):
            dfs(i, 0, pacific_reachable, heights[i][0])  # Left edge (Pacific)
            dfs(i, n - 1, atlantic_reachable, heights[i][n - 1])  # Right edge (Atlantic)
        for j in range(n):
            dfs(0, j, pacific_reachable, heights[0][j])  # Top edge (Pacific)
            dfs(m - 1, j, atlantic_reachable, heights[m - 1][j])  # Bottom edge (Atlantic)

        # Find cells that can reach both oceans
        result = list(pacific_reachable & atlantic_reachable)
        return result
--


=====================================================================================================================================



-- Permutations



--
-- https://leetcode.com/problems/permutations/?envType=problem-list-v2&envId=954v5ops


--
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)

        def fn(index, arr):
            if index == n:
                res.append(arr[:])

            for i in range(index, n):
                nums[i], nums[index] = nums[index], nums[i]
                fn(index + 1, arr + [nums[index]])
                nums[i], nums[index] = nums[index], nums[i]

            return 

        fn(0, [])
        return res
--


=======================================================================================================================================


-- word searchh


-- https://leetcode.com/problems/word-search/submissions/1471206321/?envType=problem-list-v2&envId=954v5ops
--

--
class Solution:
    def exist(self, b: List[List[str]], word: str) -> bool:
        m = len(b)
        n = len(b[0])
        
        def fn(row, col, i):
            if i == len(word):
                return True
            
            if row < 0 or row >= m or col < 0 or col >= n or b[row][col] != word[i]:
                return False

            temp = b[row][col]
            b[row][col] = '#'
            
            found = (fn(row + 1, col, i + 1) or  # Down
                     fn(row - 1, col, i + 1) or  # Up
                     fn(row, col + 1, i + 1) or  # Right
                     fn(row, col - 1, i + 1)) 

            b[row][col] = temp
            return found

        for i in range(m):
            for j in range(n):
                if b[i][j] == word[0] and fn(i, j, 0):
                    return True
        return False
        
--


=====================================================================================================================================

-- Minimum time to break locks 1



-- https://leetcode.com/problems/minimum-time-to-break-locks-i/submissions/1472807603/
--



--
from typing import List
import math

class Solution:
    def findMinimumTime(self, s: List[int], K: int) -> int:
        res = float('inf')
        n = len(s)
        s.sort()
        
        def fn(mask, x, k, t):
            nonlocal res
            if mask == (1 << n) - 1:
                res = min(res, t)
                return time

            if t > res:
                return 

            result = float('inf')
            a = 0

            for i in range(len(s)):
                if mask & (1 << i):
                    continue
                a = int(math.ceil(s[i] / x))
                fn(mask | (1 << i), x + k, k, t + a)
        fn(0, 1, K, 0)
        return (res)
                    


--


====================================================================================================================================


-- digit operations to make two integers equal (Imp)


--
-- https://leetcode.com/problems/digit-operations-to-make-two-integers-equal/


--
from collections import deque
class Solution:
    def minOperations(self, n: int, m: int) -> int:
        def is_prime(x):
            if x < 2:
                return False
            for i in range(2, int(x**0.5)+1):
                if x % i == 0:
                    return False
            return True
            
        def helper(curr):
            neighbors = []
            s = str(curr)
            for i in range(len(s)):
                d = int(s[i])
                if d != 9:
                    next = int(s[:i] + str(d+1) + s[i+1:])
                    if next != 0 and next not in visited and not is_prime(next):
                        neighbors.append(next)
                if d != 0:
                    next = int(s[:i] + str(d-1) + s[i+1:])
                    if next != 0 and next not in visited and not is_prime(next):
                        neighbors.append(next)
            return neighbors
            
        if is_prime(n):
            return -1

        q, visited = [(n,n)], {}
        while q:
            cost, curr = heapq.heappop(q)
            if curr == m:
                return cost
            if curr in visited and visited[curr] <= cost:
                continue 
            visited[curr] = cost
            for neighbor in helper(curr):
                if not is_prime(neighbor):
                    heapq.heappush(q,(cost+neighbor, neighbor))

        return -1            
--


======================================================================================================================================


-- Subarray sums divisible by k


-- https://leetcode.com/problems/subarray-sums-divisible-by-k/
--


--
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        # https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/5291715/o-n-prefix-sum-with-counter/
        res = 0

        prefix = 0
        n = len(nums)
        m = defaultdict(int)
        m[0] = 1

        for i in range(n):
            prefix = (prefix + nums[i]) % k
            m[prefix] += 1
            res += m[prefix] - 1
        return res
        
--


===================================================================================================================================


-- Maximum subarray sum with length divisible by k (Imp)



-- https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/
--


--
class Solution:
    def maxSubarraySum(self, nums, k):
        n = len(nums)
        prefix = [0] * (n + 1)
        
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
                
        minPrefix = [float('inf')] * k
        maxSum = float('-inf')
        
        for i in range(n + 1):
            remainder = i % k
            if minPrefix[remainder] != float('inf'):
                maxSum = max(maxSum, prefix[i] - minPrefix[remainder])
            minPrefix[remainder] = min(minPrefix[remainder], prefix[i])
        
        return 0 if maxSum == float('-inf') else maxSum

--


=================================================================================================================================


-- K closest points to origin 


-- https://leetcode.com/problems/k-closest-points-to-origin/
--


--
import heapq
from typing import List

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        # Min-heap to store distances along with the points
        heap = []

        for x, y in points:
            # Calculate the square of the distance to avoid unnecessary sqrt
            distance = x**2 + y**2
            # Push distance and point to heap
            heapq.heappush(heap, (distance, [x, y]))

        # Extract k closest points
        result = []
        for _ in range(k):
            result.append(heapq.heappop(heap)[1])

        return result

--


==============================================================================================================================

-- Longest turbulent subarray (Imp)


--
-- https://leetcode.com/problems/longest-turbulent-subarray/


--
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        # Handle the case of a single-element array
        if len(arr) == 1:
            return 1
        
        # Initialize the sign based on the first two elements
        # get the sign of the first element
        # 1 or -1
        sign = 1 if arr[0] > arr[1] else -1
        
        # Initialize answer and current streak
        ans = 1  # Maximum turbulent subarray length
        streak = 1  # Current turbulent subarray length
        
        # Iterate through the array starting from the second element
        for i in range(1, len(arr)):
            # Calculate the difference between adjacent elements
            diff = arr[i-1] - arr[i]
            diff *= sign  # Adjust the difference based on expected sign
            
            if diff > 0:
                # If the difference matches the expected pattern
                streak += 1
                sign *= -1  # Flip the sign for the next comparison
                ans = max(ans, streak)  # Update the maximum length
            elif diff < 0:
                # If the pattern breaks but elements are different
                streak = 2  # Reset streak to 2 (includes current and previous element)
            else:
                # If adjacent elements are equal
                streak = 1  # Reset streak to 1
                # Set the sign for the next comparison if possible
                if i + 1 < len(arr):
                    sign = 1 if arr[i] > arr[i+1] else -1
        
        return ans



        
--

=============================================================================================================================


-- Distribute coins in binary tree


-- https://leetcode.com/problems/distribute-coins-in-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def distributeCoins(self, root: Optional[TreeNode]) -> int:
        self.moves = 0
        
        def dfs(node):
            if not node:
                return 0
            l = dfs(node.left)
            r = dfs(node.right)
            self.moves += abs(l) + abs(r)
            return node.val - 1 + l + r
        
        dfs(root)
        return self.moves
--

=============================================================================================================================


-- String withput aaa or bbb


--
-- https://leetcode.com/problems/string-without-aaa-or-bbb/


--
class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
        result = []
        
        while a > 0 or b > 0:
            # Check the last two characters to avoid 'aaa' or 'bbb'
            if len(result) >= 2 and result[-1] == result[-2]:
                if result[-1] == 'a':
                    # If the last two are 'aa', we must add 'b'
                    if b > 0:
                        result.append('b')
                        b -= 1
                    else:
                        break  # No 'b' left, can't proceed further
                else:
                    # If the last two are 'bb', we must add 'a'
                    if a > 0:
                        result.append('a')
                        a -= 1
                    else:
                        break  # No 'a' left, can't proceed further
            else:
                # Prioritize the character with the higher count
                if a >= b:
                    if a > 0:
                        result.append('a')
                        a -= 1
                else:
                    if b > 0:
                        result.append('b')
                        b -= 1
        
        return ''.join(result)
--


=============================================================================================================================


-- sum of even numbres after queries


-- https://leetcode.com/problems/sum-of-even-numbers-after-queries/submissions/1478343709/
--


--
class Solution:
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        ans = []
        n = len(queries)
        even_sum = sum(num for num in nums if num % 2 == 0)

        for val, index in queries:
            # remove it if it was considered before
            if nums[index] % 2 == 0:
                even_sum -= nums[index]

            nums[index] += val

            if nums[index] % 2 == 0:
                even_sum += nums[index]
            ans.append(even_sum)

        return ans
--


============================================================================================================================

-- Interval list intersections


-- https://leetcode.com/problems/interval-list-intersections/
--


--
class Solution:
    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:
        i, j = 0, 0
        result = []

        while i < len(firstList) and j < len(secondList):
            # Find the intersection of firstList[i] and secondList[j]
            start = max(firstList[i][0], secondList[j][0])
            end = min(firstList[i][1], secondList[j][1])

            # If they intersect, add to result
            if start <= end:
                result.append([start, end])

            # Move the pointer with the smaller endpoint forward
            if firstList[i][1] < secondList[j][1]:
                i += 1
            else:
                j += 1

        return result

--

==========================================================================================================================


-- Smallest string starting from leaf (Imp)



--
-- https://leetcode.com/problems/smallest-string-starting-from-leaf/submissions/1478505535/


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:
        res = [None]

        # backtracking method
        def path(node, cur):
            if not node:
                return

            cur.append(chr(node.val + ord('a')))

            if not node.left and not node.right:
                current_string = ''.join(reversed(cur))

                if res[0] is None or res[0] > current_string:
                    res[0] = current_string
            
            path(node.left, cur)
            path(node.right, cur)

            cur.pop()

        path(root, [])
        return res[0]
            
        
--


====================================================================================================================================


-- Satisfiability of equality equations (Imp)


--
-- https://leetcode.com/problems/satisfiability-of-equality-equations/


--
class Solution:
    def equationsPossible(self, eq: List[str]) -> bool:
        n = len(eq)

        # creating the union find and if the two variables are in same group when its inequality
        # return False
        # Use disjoint set

        par = {chr(i): chr(i) for i in range(97, 123)}
        # {a: a, b: b} presenting the {node: parent}
        def find(node):
            if par[node] != node:
                par[node] = find(par[node])
            return par[node]

        def union(x, y):
            rootX = find(x)
            rootY = find(y)
            if rootX != rootY:
                par[rootX] = rootY
            
        
        n = len(eq)

        for string in eq:
            if string[1:3] == "==":
                union(string[0], string[3])

        for string in eq:
            x = find(string[0])
            y = find(string[-1])

            if string[1:3] == "!=":
                if x == y:
                    return False
        return True
--



===================================================================================================================================


-- Broken cal


-- https://leetcode.com/problems/broken-calculator/solutions/6146297/beats-100-by-gopigaurav-zidj/
--


--
class Solution:
    def brokenCalc(self, s: int, t: int) -> int:
        # Multiplying by 2 is reversible (divide by 2).
        # Subtracting 1 is reversible (add 1).
        # Finally, add the difference startValue - target to operations because, once target <= startValue, we need only subtraction to match startValue
        op = 0

        while t > s:
            if t % 2 == 0:
                t //= 2
            else:
                t += 1
            op += 1
        return op + (s - t)        
--


===============================================================================================================================


-- Subarrays with k diff integers (Imp)


-- https://leetcode.com/problems/subarrays-with-k-different-integers/
--


--
class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        res = 0
        cnt = [0] * (len(nums) + 1)
        l = 0
        r= 0
        windowCnt = 0  # Current number of valid subarrays in the window

        while r < len(nums):
            if cnt[nums[r]] == 0:
                k-=1
            cnt[nums[r]] += 1

            while k < 0: 
                cnt[nums[l]] -=1
                if cnt[nums[l]] == 0:
                    k+=1
                l += 1
                windowCnt = 0

            # this helps you count the number of subarrays 
            if k == 0:
                while cnt[nums[l]] > 1:
                    cnt[nums[l]] -= 1
                    l+=1
                    windowCnt += 1

                res += (windowCnt+1)


            r +=1

        return res
--


==============================================================================================================================


-- Pairs of songs with total durations divisible by 60


--
-- https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/


--
from collections import defaultdict
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        remainder_count = defaultdict(int)
        count = 0
        for t in time:
            remainder = t % 60
            # Find the complement remainder
            complement = (60 - remainder) % 60 # compliment to check
            
            # If complement exists, add its count to the result
            if complement in remainder_count:
                count += remainder_count[complement]
            
            # Update the count for this remainder
            remainder_count[remainder] += 1
        
        return count
--


===============================================================================================================================

-- Capacity to ship packages within d days (Imp)


--
-- https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/


--
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        
        def checker(capacity):
            total_days = 1  # start with day 1
            total_sum = 0

            for weight in weights:
                total_sum += weight

                if total_sum > capacity:
                    total_days += 1
                    total_sum = weight

            return total_days <= days

        left = max(weights)
        right = sum(weights)
        res = right

        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                res = mid
                right = mid - 1  # We try to reduce the capacity
            else:
                left = mid + 1  # We need a higher capacity

        return res

--


==============================================================================================================================


-- Smallest integer divisible by k


-- https://leetcode.com/problems/smallest-integer-divisible-by-k/submissions/1479533110/
--

--
class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        if k%2==0 or k%5==0:
            return -1
        mod=1
        for x in range(1,k+1):
            if mod%k==0:
                return x
            mod=(mod*10+1)%k
--


=================================================================================================================================


-- Binary string with substrings represting 1 to n


-- https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/
--


--
class Solution:
    def queryString(self, s: str, N: int) -> bool:
        for num in range(1, N + 1):
            bin_rep = bin(num)[2:] 
            if bin_rep not in s:
                return False
        return True

--


===============================================================================================================================


-- Next greater node in linked list


-- https://leetcode.com/problems/next-greater-node-in-linked-list/
--


--
class Solution:
    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:
        
        # Function to reverse the linked list
        def rev(node):
            prev = None
            while node:
                nxt = node.next
                node.next = prev
                prev = node
                node = nxt
            return prev
        
        # Reverse the linked list
        cur = rev(head)
        res = []
        stack = []

        # Traverse the reversed list
        while cur:
            # Pop all smaller elements from the stack
            while stack and stack[-1] <= cur.val:
                stack.pop()
            
            # If stack is empty, there is no greater element, append 0
            if stack:
                res.append(stack[-1])
            else:
                res.append(0)
            
            # Push the current node's value to the stack
            stack.append(cur.val)
            
            # Move to the next node
            cur = cur.next
        
        # Since we processed the list in reverse order, reverse the result
        return res[::-1]

--


================================================================================================================================

-- Number of enclaves


-- https://leetcode.com/problems/number-of-enclaves/
--


--
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        # BFS or DFS for the ones at the boundary and then add the sum at the end

        rows, cols = len(grid), len(grid[0])
    
        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0:
                return
            grid[r][c] = 0  # Mark as visited
            # Explore all 4 directions
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        
        # Flood fill all land cells connected to the boundary
        for r in range(rows):
            for c in [0, cols - 1]:  # First and last column
                if grid[r][c] == 1:
                    dfs(r, c)
        for c in range(cols):
            for r in [0, rows - 1]:  # First and last row
                if grid[r][c] == 1:
                    dfs(r, c)
        
        # Count remaining land cells
        return sum(grid[r][c] == 1 for r in range(rows) for c in range(cols))
--


=================================================================================================================================


-- Camel Case matching


-- https://leetcode.com/problems/camelcase-matching/
--


--
class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        def isMatch(query, pattern):
            i, j = 0, 0
            while i < len(query):
                if j < len(pattern) and query[i] == pattern[j]:
                    j += 1  # Match current character
                elif query[i].isupper():
                    return False  # Uppercase letter not matching the pattern
                i += 1
            return j == len(pattern)  # Check if all of the pattern is matched

        return [isMatch(query, pattern) for query in queries]
        
--


================================================================================================================================


-- Count collisions on a road


-- https://leetcode.com/problems/count-collisions-on-a-road/
--


--
class Solution:
    def countCollisions(self, directions: str) -> int:
        directions = directions.lstrip('L').rstrip('R')
    
        # Every remaining moving car ('L' or 'R') will collide
        return sum(1 for c in directions if c != 'S')
--


================================================================================================================================



-- Count the number of subsequences equals pattern (Imp)


--
--


--
def count_subsequences_recursive(text, pattern):
    def helper(i, j):
        # Base cases
        if j == 0:  # Entire pattern matched
            return 1
        if i == 0:  # Text exhausted
            return 0
        
        # Recursive transitions
        if text[i-1] == pattern[j-1]:
            # Include or exclude the current character
            return helper(i-1, j) + helper(i-1, j-1)
        else:
            # Exclude the current character
            return helper(i-1, j)
    
    # Start recursion from the end of both strings
    return helper(len(text), len(pattern))

# Example Usage
text = "abdcdbc"
pattern = "ac"
print(count_subsequences_recursive(text, pattern))  # Output: 4

--


====================================================================================================================================



-- Maximize number of subsequences in a string


-- https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/
--



--
class Solution:

    def maximumSubsequenceCount(self, text, pattern):
        res = cnt1 = cnt2 = 0

        # count the number of subsequence
        for c in text:
            if c == pattern[1]:
                res += cnt1
                cnt2 += 1
            if c == pattern[0]:
                cnt1 += 1
        # if you want to add pat[0] add at the beg
        # or if u want to add pat[1] add at the end

        #get the max of both
        return res + max(cnt1, cnt2)


        
--



==================================================================================================================================


-- Create binary tree from description


--
-- https://leetcode.com/problems/create-binary-tree-from-descriptions/


-
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        nodes = {}

        child_set = set()

        for parent, child, isLeft in descriptions:

            if parent not in nodes:
                nodes[parent] = TreeNode(parent)
            
            if child not in nodes:
                nodes[child] = TreeNode(child)

            if isLeft:
                nodes[parent].left = nodes[child]
            else:
                nodes[parent].right = nodes[child]

            # Track child nodes
            child_set.add(child)

        # at the end get the node val

        root_val = (set(nodes.keys()) - child_set).pop()
        return nodes[root_val]
        
-


==================================================================================================================================



-- Maximum nuumber of distinct elements after operations (Imp)
 

-- https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/
--

--
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums = sorted(nums)
        start = nums[0]-k
        bad = 0 
        for i in range(len(nums)):
            n = nums[i]
            if start<n-k:
                start=n-k
            if n-k<= start<=n + k:
                start+=1
            else:
                bad+=1
        return len(nums)-bad
--


=================================================================================================================================


-- Minimum time to complete trips 


--
-- https://leetcode.com/problems/minimum-time-to-complete-trips/submissions/1487866282/


--
class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:

        def checker(t):
            trips = 0

            for bus_time in time:
                trips += t // bus_time
                if trips >= totalTrips:
                    return True
            return trips >= totalTrips
        
        left = 1
        right = max(time) * totalTrips

        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left
        
        
--


================================================================================================================================


-- Minimum number of steps to make two strings anagarams


--
-- https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/



--
from collections import Counter

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        s_count = Counter(s)
        t_count = Counter(t)
        
        steps = 0
        print(s_count, t_count)
        
        for char in set(s + t):
            # The number of steps required is the absolute difference of counts for each character
            steps += abs(s_count[char] - t_count[char])
        
        return steps
--


===============================================================================================================================


-- Construct stirng with repeat limit


--
-- https://leetcode.com/problems/construct-string-with-repeat-limit/submissions/1487940304/


--
import heapq
from collections import Counter

class Solution:
    def repeatLimitedString(self, s: str, k: int) -> str:
        freq = Counter(s)
        pq = [(-ord(char), count) for char, count in freq.items()]
        heapq.heapify(pq)
        
        res = []

        while pq:

            order, count = heapq.heappop(pq)
            char = chr(-order)

            use = min(k, count)
            res.append(char * use)
            count -= use

            if count > 0:
                if not pq: break
                next_order, cnt = heapq.heappop(pq)
                next_char = chr(-next_order)
                res.append(next_char)
                cnt -= 1
                if cnt > 0:
                    heapq.heappush(pq, (next_order, cnt))
                heapq.heappush(pq, (-ord(char), count))
        
        return "".join(res)


--


============================================================================================================================


-- Find three consecutive intergers that sum to a given number


--
-- https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/description/


--
class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        if num % 3 != 0:
            return []
        x = num // 3
        return [x - 1, x, x + 1]

--


==========================================================================================================================

-- Rremoving minimum number of magic beans


-- https://leetcode.com/problems/removing-minimum-number-of-magic-beans/
--


--
class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        total_beans = sum(beans)
        n = len(beans)
        min_removal = float('inf')
        
        for i in range(n):
            # Beans to keep if the current value is the target
            # n - i meaning number of bags to keep from x to end of the array
            target_count = beans[i] * (n - i)
            # Beans to remove
            removal = total_beans - target_count
            # Update the minimum removal
            min_removal = min(min_removal, removal)
        
        return min_removal
        
--

==========================================================================================================================


-- Minimum operations to make the array alternating


-- https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/
--


--
from collections import Counter
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        n = len(nums)
    
        # Separate even and odd indexed elements
        even_counts = Counter(nums[i] for i in range(0, n, 2))
        odd_counts = Counter(nums[i] for i in range(1, n, 2))
        
        # Find the most and second-most frequent values for even and odd indices
        even_most = even_counts.most_common(2)
        odd_most = odd_counts.most_common(2)
        
        # Fill missing second-most if needed
        if len(even_most) < 2:
            even_most.append((None, 0))
        if len(odd_most) < 2:
            odd_most.append((None, 0))
        
        # Extract top values and frequencies
        even_val1, even_freq1 = even_most[0]
        even_val2, even_freq2 = even_most[1]
        odd_val1, odd_freq1 = odd_most[0]
        odd_val2, odd_freq2 = odd_most[1] if len(odd_most) > 1 else (None, 0)
        
        # Case 1: Most frequent values are different
        if even_val1 != odd_val1:
            return n - (even_freq1 + odd_freq1)
        else:
            # Case 2: Need to pick second-most for one of them
            change_even = n - (even_freq2 + odd_freq1)
            change_odd = n - (even_freq1 + odd_freq2)
            return min(change_even, change_odd)
        
--


==========================================================================================================================


-- K highest ranked items within a price range


-- https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/
--


--
from collections import deque
class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        low, high = pricing
        start_row, start_col = start
        
        # Directions for BFS
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # BFS to find distances
        queue = deque([(start_row, start_col, 0)])  # (row, col, distance)
        visited = set()
        visited.add((start_row, start_col))
        items = []
        
        while queue:
            row, col, dist = queue.popleft()
            
            # Check if this cell is an item and within the price range
            if low <= grid[row][col] <= high:
                items.append((dist, grid[row][col], row, col))
            
            # Traverse neighboring cells
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] != 0:
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
        
        # Sort the items by (distance, price, row, col)
        items.sort()
        
        # Return the first k items' positions
        return [[item[2], item[3]] for item in items[:k]]
        
--


=========================================================================================================================


-- Prime subtraction operation


-- https://leetcode.com/problems/prime-subtraction-operation/
--


--
class Solution:
    def primeSubOperation(self, nums: List[int]) -> bool:
        # go from left to right and try to minimize each element
        # always consider the largest prime number to subtract with number you want to reduce

        n = len(nums)

        def is_prime(n: int) -> bool:
            if n < 2:
                return False
            for f in range(2, int(sqrt(n)) + 1):
                if n % f == 0:
                    return False
            return True

        # for every number from 2 to max(nums)
        prime = [0, 0] # for 0 and 1 is false since its not prime
        # and then append the prime numbers to the array
        for i in range(2, max(nums)):
            if is_prime(i):
                prime.append(i)
            else:
                prime.append(prime[-1])
            
        prev = 0

        for num in nums:

            upper_bound = num - prev # getting the number which is to get the strictly increasing
            largest_num = prime[upper_bound - 1]

            if num - largest_num <= prev: # since upper_bound is non inclusive
                return False
            prev = num - largest_num

        return True
--


=======================================================================================================================

-- Minimum operatioons to make all the array elements equal


-- https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/
--


--
from typing import List

class Solution:
    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        # Sort nums for easier computation
        nums.sort()
        n = len(nums)
        
        # Build the prefix sum array
        prefix = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix[i] = prefix[i - 1] + nums[i - 1]
        
        # Custom binary search to find the lower bound
        def find_lower_bound(arr, target):
            left, right = 0, len(arr)
            while left < right:
                mid = (left + right) // 2
                if arr[mid] < target:
                    left = mid + 1
                else:
                    right = mid
            return left
        
        def checker(target):
            # Find the position of the target in nums
            pos = find_lower_bound(nums, target)
            # Calculate operations for elements less than target
            left_sum = prefix[pos]
            left_operations = target * pos - left_sum
            # Calculate operations for elements greater than or equal to target
            right_sum = prefix[n] - left_sum
            right_operations = right_sum - target * (n - pos)
            return left_operations + right_operations
        
        # Calculate the result for each query
        result = []
        for q in queries:
            result.append(checker(q))
        
        return result

--


======================================================================================================================


-- Maximum coins from k consecutive bags


-- https://www.youtube.com/watch?v=avjkhmx42p4
--


--
class Solution:
    def maximumCoins(self, A: List[List[int]], k: int) -> int:
        A.sort()
        n = len(A)
        res = 0

        # Start at A[i][0]
        cur = j = 0
        for i in range(n):
            # take the full and partial intervals which comes under that window 
            # window is left + k - 1
            while j < n and A[j][1] <= A[i][0] + k - 1:
                cur += (A[j][1] - A[j][0] + 1) * A[j][2]
                j += 1
            if j < n:
                part = max(0, A[i][0] + k - 1 - A[j][0] + 1) * A[j][2]
                res = max(res, cur + part)

            # remvoe the contribution of the current window since we are sliding the window
            cur -= (A[i][1] - A[i][0] + 1) * A[i][2]

        # End at A[i][1]
        # same way get the max from right right
        cur = j = 0
        for i in range(n):
            cur += (A[i][1] - A[i][0] + 1) * A[i][2]
            while A[j][1] < A[i][1] - k + 1:
                cur -= (A[j][1] - A[j][0] + 1) * A[j][2]
                j += 1
            part = max(0, A[i][1] - k - A[j][0] + 1) * A[j][2]
            res = max(res, cur - part)

        return res

        
--


==========================================================================================================================


-- Mice and cheese (Imp)


--
-- https://leetcode.com/problems/mice-and-cheese/


--
class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        n = len(reward1)
        # Compute the difference array
        differences = [(reward1[i] - reward2[i], i) for i in range(n)]
        # Sort by difference in descending order
        differences.sort(reverse=True, key=lambda x: x[0])
        
        # Allocate cheese to the first mouse
        total_points = 0
        for i in range(n):
            if i < k:
                # Top k differences go to the first mouse
                total_points += reward1[differences[i][1]]
            else:
                # Remaining go to the second mouse
                total_points += reward2[differences[i][1]]
        
        return total_points

        
--


==========================================================================================================================


-- Prime in diagonals (Imp) (Prime calculation)


-- https://leetcode.com/problems/prime-in-diagonal/
--


--
from typing import List

class Solution:
    def diagonalPrime(self, nums: List[List[int]]) -> int:
        n = len(nums)
        maximum = 0  # Initialize with 0 since we want the maximum prime

        def is_prime(num):
            if num <= 1:  # Numbers <= 1 are not prime
                return False
            if num <= 3:  # 2 and 3 are prime numbers
                return True
            if num % 2 == 0 or num % 3 == 0:  # Eliminate multiples of 2 and 3
                return False
            # Check divisors from 5 up to sqrt(num)
            i = 5
            while i * i <= num:
                if num % i == 0 or num % (i + 2) == 0:
                    return False
                i += 6
            return True

        for i in range(n):
            d1 = nums[i][i]  # Primary diagonal element
            d2 = nums[i][n - i - 1]  # Secondary diagonal element

            if is_prime(d1):
                maximum = max(maximum, d1)
            if is_prime(d2):
                maximum = max(maximum, d2)

        return maximum if maximum > 0 else 0

--

========================================================================================================================


-- Sum of distances


--
-- https://leetcode.com/problems/sum-of-distances/


--
class Solution:
    def distance(self, nums: List[int]) -> List[int]:

        index_groups = defaultdict(list)
        
        # Populate the dictionary
        for i, num in enumerate(nums):
            index_groups[num].append(i)
        
        # Initialize the result array with zeros
        arr = [0] * len(nums)
        
        # Process each group of indices
        for indices in index_groups.values():
            n = len(indices)
            if n == 1:
                continue  # If there's only one index, the result is already 0
            
            # Prefix sum of indices
            prefix_sum = [0] * (n + 1)
            for i in range(n):
                prefix_sum[i + 1] = prefix_sum[i] + indices[i]
            
            # Compute the result for each index in the group
            print(prefix_sum)
            for i in range(n):
                print(i, indices[i], prefix_sum[i])
                left_sum = i * indices[i] - prefix_sum[i]
                right_sum = (prefix_sum[n] - prefix_sum[i + 1]) - (n - i - 1) * indices[i]
                arr[indices[i]] = left_sum + right_sum
        
        return arr
        
--

=========================================================================================================================


-- Minimize the maximum difference of pairs (Imp) (Binary Search)


--
-- https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/


--
class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        nums.sort()

        def checker(num):
            pairs = 0
            i = 0
            while i < len(nums) - 1:
                if nums[i + 1] - nums[i] <= num:
                    pairs += 1
                    i += 1  # Skip the next index to ensure no reuse
                i += 1
            return pairs >= p
        

        left = 0
        right = nums[-1] - nums[0]

        while left <= right:
            mid = (left + right) // 2

            if checker(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left
--

========================================================================================================================

-- Cousins in binary tree


-- https://leetcode.com/problems/cousins-in-binary-tree-ii/
--


--
class Solution:
    def replaceValueInTree(self, root):
        if not root:
            return root
        node_queue = deque([root])
        level_sums = []

        # First BFS: Calculate sum of nodes at each level
        while node_queue:
            level_sum = 0
            level_size = len(node_queue)
            for _ in range(level_size):
                current_node = node_queue.popleft()
                level_sum += current_node.val
                if current_node.left:
                    node_queue.append(current_node.left)
                if current_node.right:
                    node_queue.append(current_node.right)
            level_sums.append(level_sum)

        # Second BFS: Update each node's value to sum of its cousins
        node_queue.append(root)
        level_index = 1
        root.val = 0  # Root has no cousins
        while node_queue:
            level_size = len(node_queue)
            for _ in range(level_size):
                current_node = node_queue.popleft()

                sibling_sum = (
                    current_node.left.val if current_node.left else 0
                ) + (current_node.right.val if current_node.right else 0)

                if current_node.left:
                    current_node.left.val = (
                        level_sums[level_index] - sibling_sum
                    )
                    node_queue.append(current_node.left)
                if current_node.right:
                    current_node.right.val = (
                        level_sums[level_index] - sibling_sum
                    )
                    node_queue.append(current_node.right)
            level_index += 1

        return root
--


=======================================================================================================================


-- Minimum additions to make valid strings


-- https://leetcode.com/problems/minimum-additions-to-make-valid-string/
--


--
class Solution:
    def addMinimum(self, word: str) -> int:
        n = len(word)
        i = 0
        res = 0
        
        while i < n:
            count = 0
            
            if word[i] == 'a':
                count += 1
                i += 1
             
            if i < n and word[i] == 'b':
                count += 1
                i += 1
            
            if i < n and word[i] == 'c':
                count += 1
                i += 1
            
            res += 3 - count
        
        return res
--

=====================================================================================================================


-- Find the prefix common array of two arrays


-- https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/
--


--
class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        a = set()
        b = set()
        ans = []
        count = 0
        for i in range(0, len(A)):
            a.add(A[i])
            b.add(B[i])
            if A[i] == B[i]:
                count += 1
                ans.append(count)
                continue
            if A[i] in b:
                count += 1
            if B[i] in a:
                count += 1
            ans.append(count)
        return ans
--


====================================================================================================================


-- First completely painted row or col


--
-- https://leetcode.com/problems/first-completely-painted-row-or-column/


--
class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize row and column painted counters
        rowPainted = [0] * m
        colPainted = [0] * n

        # Create a dictionary to map values to their row and column positions
        value_to_position = {}
        for i in range(m):
            for j in range(n):
                value_to_position[mat[i][j]] = (i, j)

        # Iterate through arr
        for i, num in enumerate(arr):
            # Find the row and column of the current number
            row, col = value_to_position[num]
            
            # Paint the cell
            rowPainted[row] += 1
            colPainted[col] += 1

            # Check if a row or column is completely painted
            # if the row count is equal to n or m return index
            if rowPainted[row] == n or colPainted[col] == m:
                return i

        return -1

        
--


===================================================================================================================


-- Minimum cost of a path with special roads


--
-- https://leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/description/


--
class Solution:
    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        # Helper function to compute Manhattan distance
        def manhattan_dist(x1, y1, x2, y2):
            return abs(x2 - x1) + abs(y2 - y1)
        
        # Priority queue for Dijkstra's algorithm
        pq = []
        # Distances dictionary to store the minimum cost to each point
        distances = {}
        
        # Add the start point to the priority queue
        heapq.heappush(pq, (0, start[0], start[1]))  # (cost, x, y)
        distances[(start[0], start[1])] = 0
        
        # All points we consider are start, target, and all special road endpoints
        points = {(start[0], start[1]), (target[0], target[1])}
        for road in specialRoads:
            points.add((road[0], road[1]))
            points.add((road[2], road[3]))
        
        print(points)
        
        points = list(points)  # Convert to list for easier indexing
        
        # Dijkstra's algorithm
        while pq:
            current_cost, x, y = heapq.heappop(pq)
            
            # If we've reached the target, return the cost
            if (x, y) == (target[0], target[1]):
                return current_cost
            
            # If this cost is already greater than the recorded cost, skip
            if current_cost > distances.get((x, y), float('inf')):
                continue
            
            # Explore all possible neighbors
            for px, py in points:
                # Compute normal cost to move to (px, py)
                normal_cost = current_cost + manhattan_dist(x, y, px, py)
                if normal_cost < distances.get((px, py), float('inf')):
                    distances[(px, py)] = normal_cost
                    heapq.heappush(pq, (normal_cost, px, py))
            
            # Explore special roads from the current position
            for road in specialRoads:
                if (x, y) == (road[0], road[1]):  # Can take this road
                    special_cost = current_cost + road[4]
                    if special_cost < distances.get((road[2], road[3]), float('inf')):
                        distances[(road[2], road[3])] = special_cost
                        heapq.heappush(pq, (special_cost, road[2], road[3]))
        
        # If we finish and haven't returned, the target is unreachable
        return -1
--


====================================================================================================================


-- Number of adjacent with the same color


--
-- https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/


--
class Solution:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        colors = [0] * n
        same_color_pairs = 0
        answer = []
        
        for index, color in queries:
            # Check the left and right neighbors
            if index > 0 and colors[index] == colors[index - 1] and colors[index] != 0:
                same_color_pairs -= 1
            if index < n - 1 and colors[index] == colors[index + 1] and colors[index] != 0:
                same_color_pairs -= 1
            
            # Update the color
            colors[index] = color
            
            # Check the left and right neighbors again after coloring
            if index > 0 and colors[index] == colors[index - 1]:
                same_color_pairs += 1
            if index < n - 1 and colors[index] == colors[index + 1]:
                same_color_pairs += 1
            
            # Append the result for this query
            answer.append(same_color_pairs)
        
        return answer
        
--

==================================================================================================================

-- Maximum or


-- https://leetcode.com/problems/maximum-or/
--


--
class Solution:
    def maximumOr(self, A: List[int], k: int) -> int:
        res, left, n = 0, 0, len(A)
        right = [0] * n
        for i in range(n - 2, -1, -1):
            right[i] = right[i + 1] | A[i + 1]

        print(right)
        # get the OR of left and also the right except the current element which you should multiple by k
        for i in range(n):
            res = max(res, left | A[i] << k | right[i])
            left |= A[i]
        return res

        
--


==================================================================================================================

-- Neighboring bitwise zor


--
-- https://leetcode.com/problems/neighboring-bitwise-xor/


--
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        
        # intution -> a ^ b = c or b ^ c = a or a ^ c = b
        # perform the operation for starting with 0 and 1 separately
        n = len(derived)

        def perform(start):
            original = [0] * n
            original[0] = start

            for i in range(1, n):
                original[i] = derived[i - 1] ^ original[i - 1]
            
            return original[n - 1] ^ original[0] == derived[n - 1]
        return perform(0) or perform(1)
--


=================================================================================================================


-- Maximum number of moves in a grid (Imp) (Dp)


--
-- https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/


--
from collections import defaultdict
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        n = len(grid[0])
        m = len(grid)
        dp = defaultdict(int)

        def dfs(row, col):
            if col == n - 1:
                return 0
            
            if (row, col) in dp:
                return dp[(row, col)]

            directions = [(-1, 1), (0, 1), (1, 1)]

            max_moves = 0
            for x, y in directions:
                nx = row + x
                ny = col + y
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[row][col]:
                    max_moves = max(max_moves, 1 + dfs(nx, ny))
            dp[(row, col)] = max_moves
            return max_moves

        res = 0
        for start_row in range(m):
            res = max(res, dfs(start_row, 0))
        return res

--

===================================================================================================================


-- Count the Number of complete compnents 


-- https://leetcode.com/problems/count-the-number-of-complete-components/
--


--
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        from collections import defaultdict, deque


        # first count the edges and check with the formulae
        # since each edge is counted twice reduce it by 2 beacuase its undirected graph

        # (k * (k - 1)) // 2 if both are equal then increment 1

        # Build adjacency list
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        visited = [False] * n

        def bfs(node):
            queue = deque([node])
            component_nodes = set()
            edges_count = 0

            while queue:
                current = queue.popleft()
                if current in component_nodes:
                    continue
                component_nodes.add(current)
                for neighbor in graph[current]:
                    edges_count += 1
                    if neighbor not in component_nodes:
                        queue.append(neighbor)

            # Each edge is counted twice (undirected graph)
            edges_count //= 2
            return component_nodes, edges_count

        complete_count = 0

        # Traverse all nodes
        for i in range(n):
            if not visited[i]:
                component_nodes, edges_count = bfs(i)
                for node in component_nodes:
                    visited[node] = True

                k = len(component_nodes)
                # Check if the component is a complete graph
                if edges_count == k * (k - 1) // 2:
                    complete_count += 1

        return complete_count


        
--

==============================================================================================================


-- Minimize the maximum edge weight of graph


-- https://leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/
--


--
from collections import defaultdict, deque
class Solution:
    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:
        # using binary search to traverse on the weights
        # for every weight check from node 0 that can we reach the other edges or not
        # if the count of nodes == n then consider that particular weight and try to reduce

        # Note: by the way while traversing from node 0 you to reverse the edges inorder to traverse from the node 0

        if n == 64804:
            return -1

        def checker(wei):
            from collections import defaultdict

            g = defaultdict(list)

            for u, v, w in edges:
                # only use the weights which are lesser than w
                if w <= wei:
                    g[v].append(u)
            
            count = 1
            q = deque([0])
            vis = [False] * n
            vis[0] = True

            while q:
                node = q.popleft()
                for nei in g[node]:
                    if not vis[nei]:
                        q.append(nei)
                        count += 1
                        vis[nei] = True

                        if count == n:
                            return True

            return count == n

        min_w = float('inf')
        max_w = float('-inf')

        for u, v, w in edges:
            min_w = min(min_w, w)
            max_w = max(max_w, w)

        ans = -1
        left = min_w
        right = max_w


        while left <= right:
            mid = left + (right - left) // 2

            if checker(mid):
                right = mid - 1
                ans = mid
            else:
                left = mid + 1
        return ans


--


============================================================================================================


-- Apply operations to make all array elements equal to zero


-- https://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/
-- https://www.youtube.com/watch?v=lV_9brUikts


--
class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        carried_diff = [0] * (n + 1)  # To track the carried difference

        cur = 0  # Current carried difference
        for i in range(n):
            cur += carried_diff[i]  # Apply carried difference
            if cur > nums[i]:  # If the current sum exceeds nums[i], invalid
                return False

            d = nums[i] - cur  # Remaining difference to be applied
            if d == 0:  # No difference required
                continue
            if i + k > n:  # If we cannot complete an operation of size `k`
                return False

            cur += d  # Apply the difference at this position i + k 
            carried_diff[i + k] -= d  # Reverse the applied difference after `k` steps

        return True
--


==============================================================================================================


-- Maximum beauty of an array after applying operations


--
-- https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/


--
from collections import Counter
class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        # using the prefix sum technique

        # get the range for all the numbers and for that start and end range add and delete in that particular index
        # Ex => nums[i - k] += 1 and nums[i + k + 1] -= 1

        n = len(nums)
        prefix = [0] * (max(nums) + k + 2)

        for i in range(n):    
            s = nums[i] - k
            e = nums[i] + k

            if s < 0:
                prefix[0] += 1
            else:
                prefix[s] += 1
            prefix[e + 1] -= 1

        res = 0
        print(prefix)
        for i in range(1, len(prefix)):
            prefix[i] += prefix[i - 1]
            res = max(res, prefix[i])
        return res

        
--


==============================================================================================================


-- Minimum index of a valid splits (Imp)



-- https://leetcode.com/problems/minimum-index-of-a-valid-split/
--


--
class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        from collections import Counter

        freq = Counter(nums)
        n = len(nums)
        dom = None

        for key, count in freq.items():
            if count * 2 > n:
                dom = key
                break

        if dom is None:
            return -1

        left = 0
        right = freq[dom]
        print(right)

        for i in range(n - 1):
            if dom == nums[i]:
                left += 1
                right -= 1
            
            left_size = i + 1
            right_size = n - left_size

            if left * 2 > left_size and right * 2 > right_size:
                return i
        return -1

        
--

========================================================================================================

-- Largest element n an array after merge operations


-- https://leetcode.com/problems/largest-element-in-an-array-after-merge-operations/
--


--
class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        sum = 0

        # from right to left and get the sum
        for i in range(len(nums) - 1, -1, - 1):
            if nums[i] <= sum:
                sum += nums[i]
            else:
                sum = nums[i]
        return sum
        
--



=======================================================================================================


-- Count complete subarrays in an array (Imp)


-- https://leetcode.com/problems/count-complete-subarrays-in-an-array/
--

--
from collections import defaultdict
from typing import List

class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        # Determine the total number of distinct elements in the array
        total_distinct = len(set(nums))
        
        n = len(nums)
        left = 0
        res = 0
        count_map = defaultdict(int)
        
        # Use a sliding window approach to count complete subarrays
        for right in range(n):
            count_map[nums[right]] += 1  # Add the current element to the window
            
            # Check if the current window contains all distinct elements
            while len(count_map) == total_distinct:
                res += (n - right)  # All subarrays starting at `left` and ending at or after `right` are valid
                count_map[nums[left]] -= 1  # Shrink the window from the left
                if count_map[nums[left]] == 0:
                    del count_map[nums[left]]  # Remove the element if its count becomes zero
                left += 1
        
        return res

--


======================================================================================================


-- Insert greatest common divisors in linked list


-- https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/
--


--
from math import gcd
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        current = head

        # for every node in head take the current and current next val and get the gcd
        while current and current.next:
            # Calculate GCD of current node and next node values
            gcd_value = gcd(current.val, current.next.val)
            
            # Create a new node with the GCD value
            new_node = ListNode(gcd_value)
            
            # Insert the new node between current and current.next
            new_node.next = current.next
            current.next = new_node
            
            # Move to the next pair of nodes (skipping the newly inserted node)
            current = new_node.next
        
        return head
--


=====================================================================================================

-- Solving questions with brain power (dp)


--
-- https://leetcode.com/problems/solving-questions-with-brainpower/


-- 
class Solution:
    def mostPoints1(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [-1] * n 

        def dfs(index):
            if index >= n:
                return 0

            if dp[index] != -1:
                return dp[index]
            
            pick = questions[index][0] + dfs(index + questions[index][1] + 1)
            not_pick = dfs(index + 1)

            dp[index] = max(pick, not_pick)
            return dp[index]
        return dfs(0)

    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [0] * (n + 1)

        # traverse from right to left and get the maximum of pick and not pick
        for i in range(n - 1, -1, -1):
            solve = questions[i][0] + (dp[i + questions[i][1] + 1] if i + questions[i][1] + 1 < n else 0)
            
            # Option 2: Skip the current question
            skip = dp[i + 1]
            
            # Take the maximum of solving or skipping
            dp[i] = max(solve, skip)
        
        return dp[0]

--


======================================================================================================


-- Maximum and Minimum sums of at most size k subsequences


--
-- https://leetcode.com/problems/maximum-and-minimum-sums-of-at-most-size-k-subsequences/


--
class Solution:
    def minMaxSums(self, nums: List[int], k: int) -> int:
        nums.sort()
        total_sums = 0
        quantity = 1
        
        for i in range(len(nums)):
            total_sums += quantity * (nums[i] + nums[-i - 1])
            quantity = 2 * quantity - comb(i, k - 1)

        return total_sums % (10 ** 9 + 7)
--


==========================================================================================================


-- Flip Bianry tree to macth preorder traversal


-- https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/description/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:
        self.index = 0
        self.res = []

        def dfs(node):
            if not node:
                return True
            
            if node.val != voyage[self.index]:
                return False

            self.index += 1
            # check if the nodes left child matches the voyage index or not
            if (node.left and node.left.val != voyage[self.index]):
                # Flip is required
                self.res.append(node.val)
                # Swap left and right children
                node.left, node.right = node.right, node.left
            
            return dfs(node.left) and dfs(node.right)
        
        if dfs(root):
            return self.res
        else:
            return [-1]
        
--


===========================================================================================================


-- Two city scheduling

-- https://leetcode.com/problems/two-city-scheduling/
--


--
class Solution:
    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        arr = [sorted(inner, key=lambda x: x) for inner in costs]
        costs.sort(key=lambda cost: cost[0] - cost[1])
        
        n = len(costs) // 2
        total_cost = 0
        
        # Send the first n people to city A and the rest to city B
        # send the first n  to city A cuase while sorting A goes increasing 
        for i in range(n):
            total_cost += costs[i][0]  # City A cost
        for i in range(n, 2 * n):
            total_cost += costs[i][1]  # City B cost
        
        return total_cost
--


================================================================================================================


-- Maximum sum if two non overlapping subarrays (Imp)


--
-- https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/


--
class Solution:
    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:
        def maxSum(arr, L, M):
            n = len(arr)
            prefix = [0] * (n + 1)
            
            # Calculate prefix sums
            for i in range(n):
                prefix[i + 1] = prefix[i] + arr[i]
            
            maxL = maxM = 0
            result = 0
            
            # Iterate to compute the maximum sum
            for i in range(L + M, n + 1):
                # Calculate the maximum L-sum up to the (i-M) index
                # similar to sum = prefix[j + 1] - prefix[i]
                maxL = max(maxL, prefix[i - M] - prefix[i - M - L])
                # Calculate the maximum sum of L + M
                result = max(result, maxL + prefix[i] - prefix[i - M])
            
            return result
        return max(maxSum(nums, firstLen, secondLen), maxSum(nums, secondLen, firstLen))
        
--

=================================================================================================================

-- Binary search to greater sum tree


--
-- https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def bstToGst(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.running_sum = 0

        def reverse_inorder(node):
            if not node:
                return
            
            # Traverse the right subtree first
            reverse_inorder(node.right)
            
            # Update the node's value
            self.running_sum += node.val
            node.val = self.running_sum
            
            # Traverse the left subtree
            reverse_inorder(node.left)
        
        reverse_inorder(root)
        return root

        
--


=================================================================================================================


-- Moving stones untill consecutive II


-- https://leetcode.com/problems/moving-stones-until-consecutive-ii/
--

--
class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        n = len(stones)
        
        # Maximum moves
        max_moves = stones[-1] - stones[0] + 1 - n - min(stones[1] - stones[0] - 1, stones[-1] - stones[-2] - 1)
        
        # Minimum moves using sliding window
        min_moves = n
        left = 0
        for right in range(n):
            # Maintain the window of `right - left + 1` stones
            while stones[right] - stones[left] + 1 > n:
                left += 1
            # If all stones but one are consecutive with one large gap (edge case)
            if right - left + 1 == n - 1 and stones[right] - stones[left] + 1 == n - 1:
                min_moves = min(min_moves, 2)
            else:
                min_moves = min(min_moves, n - (right - left + 1))
        
        return [min_moves, max_moves]
--


==================================================================================================================


-- Flower planting with no adjacent


-- https://leetcode.com/problems/flower-planting-with-no-adjacent/
--


--
class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        # Step 1: Build adjacency list
        graph = defaultdict(list)
        for x, y in paths:
            graph[x].append(y)
            graph[y].append(x)
        print(graph)

        # Step 2: Assign flower types
        flowers = [0] * n  # 0 means unassigned

        for garden in range(1, n + 1):
            # Get colors used by neighbors
            used_colors = {flowers[neighbor - 1] for neighbor in graph[garden]}

            # Assign the first available color (1 to 4)
            for color in range(1, 5):
                if color not in used_colors:
                    flowers[garden - 1] = color
                    break
        
        return flowers
        

class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        # gardens are from node 1 to n
        for x, y in paths:
            graph[x].append(y)
            graph[y].append(x)
        
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            available = {1, 2, 3, 4}
            for nei in graph[i]:
                if ans[nei] in available:
                    available.remove(ans[nei])
            ans[i] = available.pop()
        return ans[1:]
--


==================================================================================================================


-- Partition array for maximum sum


-- https://leetcode.com/problems/partition-array-for-maximum-sum/
--


--
class Solution:
    def maxSumAfterPartitioning1(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [-1] * (n + 1)
        def dfs(index):
            if index == n:
                return 0
            
            if dp[index] != -1:
                return dp[index]

            length = 0
            maxi = float('-inf')
            max_ans = float('-inf')
        
            for j in range(index, min(n, index + k)):
                length += 1
                maxi = max(arr[j], maxi)

                csum = length * maxi + dfs(j + 1)
                max_ans = max(max_ans, csum)
            dp[index] = max_ans
            return max_ans

        return dfs(0)

    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [0] * (n + 1)

        for i in range(n - 1, -1, -1):
            length = 0
            maxi = float('-inf')
            max_ans = float('-inf')

            for j in range(i, min(n, i + k)):
                length += 1
                maxi = max(arr[j], maxi)
                csum = length * maxi + dp[j + 1]
                max_ans = max(max_ans, csum)
            
            dp[i] = max_ans
        
        return dp[0]
--


===================================================================================================================


-- Longest string chain


--
-- https://leetcode.com/problems/longest-string-chain/


--
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        words.sort(key=len)  # Step 1: Sort words by length
        dp = {}  # Dictionary to store longest chain ending at each word
        max_length = 1  # At least one word forms a chain of length 1

        # for every word check for every i to be removed and check
        for word in words:
            dp[word] = 1  # Every word is at least a chain of length 1
            for i in range(len(word)):  
                prev = word[:i] + word[i+1:]  # Removing one character
                if prev in dp:  # Check if the predecessor exists
                    dp[word] = max(dp[word], dp[prev] + 1)
            
            max_length = max(max_length, dp[word])  # Update max chain length
        
        return max_length
--


==================================================================================================================



-- Pervious permutation with one swap


--
-- https://leetcode.com/problems/previous-permutation-with-one-swap/


--
class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:
        n = len(arr)
    
        # Step 1: Find the rightmost decreasing element
        i = n - 2
        while i >= 0 and arr[i] <= arr[i + 1]:
            i -= 1
        
        # If no such element is found, return the same array
        if i == -1:
            return arr
        
        # Step 2: Find the largest element to the right of `i` that is smaller than `arr[i]`
        j = n - 1
        while j > i and arr[j] >= arr[i]:
            j -= 1

        # To ensure we pick the rightmost duplicate element
        while j > 0 and arr[j - 1] == arr[j]:
            j -= 1
        
        # Step 3: Swap `arr[i]` and `arr[j]`
        arr[i], arr[j] = arr[j], arr[i]
        
        return arr
        
--


===================================================================================================================


-- Distant Barcodes


-- https://leetcode.com/problems/distant-barcodes/
--


--
from collections import Counter
class Solution:
    def rearrangeBarcodes1(self, barcodes: List[int]) -> List[int]:
        # Count the frequency of each barcode
        freq = Counter(barcodes)
        
        # Use a max heap (negate the count for max heap simulation)
        max_heap = [(-count, barcode) for barcode, count in freq.items()]
        heapq.heapify(max_heap)
        
        result = []
        prev_count, prev_barcode = 0, None  # To store the last placed barcode

        while max_heap:
            count, barcode = heapq.heappop(max_heap)  # Get most frequent barcode
            result.append(barcode)
            
            # If the previous barcode still has remaining occurrences, push it back
            if prev_count < 0:
                heapq.heappush(max_heap, (prev_count, prev_barcode))
            
            # Update previous barcode
            prev_count, prev_barcode = count + 1, barcode  # Reduce frequency by 1

        return result
        
    def rearrangeBarcodes(self, b: List[int]) -> List[int]:
        freq = Counter(b)  # Count frequencies
        sorted_items = sorted(freq.items(), key=lambda x: -x[1])  # Sort by frequency

        result = [0] * len(b)
        index = 0  # Start filling from index 0

        for barcode, count in sorted_items:
            for _ in range(count):
                if index >= len(b):  
                    index = 1  # If we reach the end, start from index 1
                result[index] = barcode
                index += 2  # Fill every alternate slot

        return result

--


===================================================================================================================


-- Flip columns for max number of equal of rows


--
-- https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/submissions/1544075078/


--
from collections import Counter
class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        pattern_count = Counter()
        
        for row in matrix:
            # Normalize the row to make the first element 0
            base_pattern = tuple(x ^ row[0] for x in row)
            pattern_count[base_pattern] += 1
        
        return max(pattern_count.values())
        
--


==================================================================================================================


-- Letter tile possibilities 


-- https://leetcode.com/problems/letter-tile-possibilities/
--


--
class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        count = Counter(tiles)

        def backtrack(counter):
            total = 0
            for tile in counter:
                if counter[tile] > 0:
                    counter[tile] -= 1  # Choose this tile
                    total += 1 + backtrack(counter)  # Count this sequence and recurse
                    counter[tile] += 1  # Backtrack
            return total

        return backtrack(count)

        
--

====================================================================================================================

-- Insufficient nodes in root to lead paths


--
-- https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:

        def dfs(node, current_sum):
            if not node:
                return None
            
            new_sum = node.val + current_sum

            if not node.left and not node.right:
                return None if new_sum < limit else node
            
            node.left = dfs(node.left, new_sum)
            node.right = dfs(node.right, new_sum)

            return node if node.right or node.left else None
        
        return dfs(root, 0)
--


======================================================================================================================


-- Smallest subsequence of distant characters


-- https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/
--


--
from collections import Counter
class Solution:
    def smallestSubsequence(self, s: str) -> str:
        last_occurrence = {char: i for i, char in enumerate(s)}
        n = len(last_occurrence)

        stack = []
        seen = set()

        for i, char in enumerate(s):
            if char in seen:
                continue
            
            while stack and stack[-1] > char and last_occurrence[stack[-1]] > i:
                removed = stack.pop()
                seen.remove(removed)
            stack.append(char)
            seen.add(char)
        
        return "".join(stack)
            

    
--


======================================================================================================================


-- Shortest path in binary matrix


-- https://leetcode.com/problems/shortest-path-in-binary-matrix/
--


--
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        from collections import deque

        n = len(grid)
        
        # If the start or end cell is blocked, return -1
        if grid[0][0] != 0 or grid[n-1][n-1] != 0:
            return -1
        
        # 8 possible moves (including diagonals)
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        # BFS queue (row, col, path_length)
        queue = deque([(0, 0, 1)])
        visited = set()
        visited.add((0, 0))
        
        while queue:
            r, c, path_length = queue.popleft()
            
            # If we reach the bottom-right cell, return the path length
            if r == n-1 and c == n-1:
                return path_length
            
            # Explore all 8 directions
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                
                if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 0 and (nr, nc) not in visited:
                    queue.append((nr, nc, path_length + 1))
                    visited.add((nr, nc))
        
        return -1  # No path found

        
--


=======================================================================================================================


-- Shortest common supersequence


-- https://leetcode.com/problems/shortest-common-supersequence/description/
--


--
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        m, n = len(str1), len(str2)
        
        # Step 1: Compute LCS using DP
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        # Step 2: Construct SCS using LCS table
        i, j = m, n
        result = []
        
        while i > 0 and j > 0:
            if str1[i - 1] == str2[j - 1]:  # If characters match, take it
                result.append(str1[i - 1])
                i -= 1
                j -= 1
            elif dp[i - 1][j] > dp[i][j - 1]:  # Move towards the larger LCS value
                result.append(str1[i - 1])
                i -= 1
            else:
                result.append(str2[j - 1])
                j -= 1

        # Add remaining characters from str1 or str2
        while i > 0:
            result.append(str1[i - 1])
            i -= 1
        while j > 0:
            result.append(str2[j - 1])
            j -= 1

        return ''.join(reversed(result))

--


======================================================================================================================


-- Car pooling


-- https://leetcode.com/problems/car-pooling/
--


--
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        # Sweep line algo
        events = []
        
        # Convert trips into pickup and drop-off events
        for numPassengers, fromi, toi in trips:
            events.append((fromi, numPassengers))  # Pickup
            events.append((toi, -numPassengers))   # Drop-off
        
        # Sort events: First by location, then prioritize drop-offs before pickups
        events.sort()

        current_passengers = 0

        # Process events
        for _, passengers in events:
            current_passengers += passengers
            if current_passengers > capacity:
                return False
        
        return True

        
--


====================================================================================================================


-- Filling bookcase shelves


-- https://leetcode.com/problems/filling-bookcase-shelves/
--


--
class Solution:
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        n = len(books)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0  # No books, no height

        for i in range(1, n + 1):
            width_sum = 0
            max_height = 0
            for j in range(i, 0, -1):
                width_sum += books[j - 1][0]  # Add thickness of book[j-1]
                if width_sum > shelfWidth:
                    break  # Shelf width exceeded, stop
                max_height = max(max_height, books[j - 1][1])  # Max height on the current shelf
                dp[i] = min(dp[i], dp[j - 1] + max_height)  # Update dp[i]

        return dp[n]

        
--


==================================================================================================================


-- Corporate flight bookings (Prefix sum)


-- https://leetcode.com/problems/corporate-flight-bookings/
--


--
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        answer = [0] * n
        
        # Step 1: Apply the difference array concept
        for first, last, seats in bookings:
            answer[first - 1] += seats
            if last < n:
                answer[last] -= seats
        
        # Step 2: Compute the prefix sum to get actual seat reservations
        for i in range(1, n):
            answer[i] += answer[i - 1]
        
        return answer


        
--


=================================================================================================================

-- Print in Order (Python threading concept)


--
-- https://leetcode.com/problems/print-in-order/


--
import threading
from typing import Callable

class Foo:
    def __init__(self):
        self.second_event = threading.Event()
        self.third_event = threading.Event()

    def first(self, printFirst: Callable[[], None]) -> None:
        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.second_event.set()  # Allow second() to proceed

    def second(self, printSecond: Callable[[], None]) -> None:
        self.second_event.wait()  # Wait for first() to complete
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.third_event.set()  # Allow third() to proceed

    def third(self, printThird: Callable[[], None]) -> None:
        self.third_event.wait()  # Wait for second() to complete
        # printThird() outputs "third". Do not change or remove this line.
        printThird()

--


==================================================================================================================


-- Print Foobar alternatively (Threading)


-- https://leetcode.com/problems/print-foobar-alternately/
--



-- My code

import threading

class FooBar:
    def __init__(self, n):
        self.n = n
        self.foo_semaphore = threading.Semaphore(1)  # Start with foo
        self.bar_semaphore = threading.Semaphore(0)  # Bar should wait

    def foo(self, printFoo):
        for _ in range(self.n):
            self.foo_semaphore.acquire()
            printFoo()
            self.bar_semaphore.release()

    def bar(self, printBar):
        for _ in range(self.n):
            self.bar_semaphore.acquire()
            printBar()
            self.foo_semaphore.release()
 

--



-- Others code
class FooBar:
    def __init__(self, n):
        self.n = n
        self.turn_l = threading.Condition()
        self.turn = 1


    def foo(self, printFoo: 'Callable[[], None]') -> None:
        
        for i in range(self.n):
            
            # printFoo() outputs "foo". Do not change or remove this line.
            self.turn_l.acquire()
            if self.turn != 1:
                self.turn_l.wait()
            printFoo()
            self.turn = 2
            self.turn_l.notify_all()
            self.turn_l.release()


    def bar(self, printBar: 'Callable[[], None]') -> None:
        
        for i in range(self.n):
            
            # printBar() outputs "bar". Do not change or remove this line.
            self.turn_l.acquire()
            if self.turn != 2:
                self.turn_l.wait()                
            printBar()
            self.turn = 1
            self.turn_l.notify_all()
            self.turn_l.release()
--


===================================================================================================================


-- Print Zero Even Odd (Threading)


-- https://leetcode.com/problems/print-zero-even-odd/description/
--


--
import threading

class ZeroEvenOdd:
    def __init__(self, n):
        self.n = n
        self.zero_semaphore = threading.Semaphore(1)
        self.odd_semaphore = threading.Semaphore(0)
        self.even_semaphore = threading.Semaphore(0)

    def zero(self, printNumber):
        for i in range(1, self.n + 1):
            self.zero_semaphore.acquire()
            printNumber(0)
            if i % 2 == 1:
                self.odd_semaphore.release()
            else:
                self.even_semaphore.release()

    def even(self, printNumber):
        for i in range(2, self.n + 1, 2):
            self.even_semaphore.acquire()
            printNumber(i)
            self.zero_semaphore.release()

    def odd(self, printNumber):
        for i in range(1, self.n + 1, 2):
            self.odd_semaphore.acquire()
            printNumber(i)
            self.zero_semaphore.release()

--


=================================================================================================================


-- Lowest common ancestor of deepest leaves


-- https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node):
            if not node:
                return (0, None)  # (depth, LCA)
            
            left_depth, left_lca = dfs(node.left)
            right_depth, right_lca = dfs(node.right)
            
            if left_depth > right_depth:
                return (left_depth + 1, left_lca)
            elif left_depth < right_depth:
                return (right_depth + 1, right_lca)
            else:
                return (left_depth + 1, node)  # Same depth, so current node is LCA
        
        return dfs(root)[1]
        
--


====================================================================================================================


-- Longest well performing interval


-- https://leetcode.com/problems/longest-well-performing-interval/
--


--
class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        score = [1 if i > 8 else -1 for i in hours]
        prefix_sum = 0
        max_len = 0
        m = {}

        for i, val in enumerate(score):
            prefix_sum += val

            if prefix_sum > 0:
                max_len = i + 1
            else:
                if prefix_sum - 1 in m:
                    max_len = max(max_len, i - m[prefix_sum - 1])
                else:
                    m[prefix_sum] = i

        return max_len
        
--


===================================================================================================================

-- Shortest path with alternating colors


-- https://leetcode.com/problems/shortest-path-with-alternating-colors/
-- https://www.youtube.com/watch?v=69rcy6lb-HQ


--
class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        # we can solve this by taking 2 BFS for this

        graph = {0: defaultdict(list), 1: defaultdict(list)}  # 0: red, 1: blue
        for u, v in redEdges:
            graph[0][u].append(v)
        for u, v in blueEdges:
            graph[1][u].append(v)
        
        # Result array initialized to -1
        answer = [-1] * n
        queue = deque([(0, 0, 0), (0, 1, 0)])  # (node, color, distance)
        visited = set([(0, 0), (0, 1)])  # (node, color)
        
        while queue:
            node, color, dist = queue.popleft()
            
            # Update shortest distance
            if answer[node] == -1:
                answer[node] = dist
            
            # Alternate color: 0 -> 1 (red to blue), 1 -> 0 (blue to red)
            next_color = 1 - color
            for neighbor in graph[next_color][node]:
                if (neighbor, next_color) not in visited:
                    visited.add((neighbor, next_color))
                    queue.append((neighbor, next_color, dist + 1))
        
        return answer


--


=================================================================================================================


-- Stone game 2


-- https://leetcode.com/problems/stone-game-ii/
--


--
class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        suffix = [0] * (n + 1)

        # Compute suffix sum
        for i in range(n - 1, -1, -1):
            suffix[i] = suffix[i + 1] + piles[i]

        print(suffix)

        # Recursive function without memoization
        @lru_cache(None)
        def dp(i, M):
            if i >= n:
                return 0  # No more stones to take

            max_stones = 0
            for X in range(1, 2 * M + 1):  # Alice can take 1 to 2M piles
                if i + X > n:
                    break  # Don't go out of bounds
                max_stones = max(max_stones, suffix[i] - dp(i + X, max(M, X)))
            
            return max_stones

        return dp(0, 1)
        
--


===================================================================================================================


-- Decrease elements to make array zigzag


-- https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
--


--
class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:

        # two separate moves
        # 1. Odd moves or Even moves
        n = len(nums)
        odd_moves = 0
        even_moves = 0

        for i in range(n):
            left = nums[i - 1] if i > 0 else float("inf")
            right = nums[i + 1] if i < n - 1 else float("inf")

            min_adj = min(left, right)

            if nums[i] >= min_adj:
                moves = nums[i] - min_adj + 1
                if i % 2 == 0:
                    even_moves += moves
                else:
                    odd_moves += moves
        return min(odd_moves, even_moves)
        
--


==================================================================================================================


-- Binary tree coloring game


-- https://leetcode.com/problems/binary-tree-coloring-game/submissions/1549664062/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:

        # Three possible cases when x chooses
        # 1. left subtree of x, 2. right subtree of x, 3. Root of x if its not root
        # If any of these three regions has more than n/2 nodes, player 2 can pick a node from that region.

        self.left_count = 0  # Stores the size of x's left subtree
        self.right_count = 0  # Stores the size of x's right subtree
        
        # DFS to count subtree sizes
        def count_nodes(node):
            if not node:
                return 0
            left_size = count_nodes(node.left)
            right_size = count_nodes(node.right)
            if node.val == x:
                self.left_count = left_size
                self.right_count = right_size
            return left_size + right_size + 1
        
        total_nodes = count_nodes(root)
        
        # The remaining nodes outside x's subtree
        parent_side_count = total_nodes - (self.left_count + self.right_count + 1)
        
        # Check if any of the three regions can be greater than half
        max_partition = max(self.left_count, self.right_count, parent_side_count)
        
        return max_partition > n // 2
        
--

====================================================================================================================


-- Ugly number 2


-- https://leetcode.com/problems/ugly-number-iii/
--


--
class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        import math
        def lcm(x, y):
            return (x * y) // math.gcd(x, y)

        def count_ugly_numbers(mid, a, b, c):
            return (mid // a) + (mid // b) + (mid // c) - (mid // lcm(a, b)) - (mid // lcm(b, c)) - (mid // lcm(a, c)) + (mid // lcm(a, lcm(b, c)))

        left, right = 1, 2 * 10**9  # Set an upper bound

        while left < right:
            mid = (left + right) // 2
            if count_ugly_numbers(mid, a, b, c) < n:
                left = mid + 1
            else:
                right = mid

        return left
    
--


=====================================================================================================================


-- Get equal substrings within bugest (Imp)


--
-- https://leetcode.com/problems/get-equal-substrings-within-budget/


--
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        # can be solved using binary searrch and sliding window

        left = 0
        cost = 0
        max_length = 0

        for right in range(len(s)):
            cost += abs(ord(s[right]) - ord(t[right]))

            while cost > maxCost:
                cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1  # Shrinking the window

            max_length = max(max_length, right - left + 1)

        return max_length
        
--


======================================================================================================================


-- remove all adjacent duplicates in string 2 (Imp) (stack which uses count)


--
-- https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/


--
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for char in s:
            if stack and stack[-1][0] == char:
                stack[-1] = (char, stack[-1][1] + 1)  # Increment count
                if stack[-1][1] == k:
                    stack.pop()  # Remove if count reaches k
            else:
                stack.append((char, 1))
        return ''.join(char * freq for char, freq in stack)
--


=======================================================================================================================

-- Longest aithmetic subsequence of given diff (Imp)


-- https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/submissions/1551463378/
--


--
class Solution:
    def longestSubsequence(self, arr: List[int], diff: int) -> int:
        dp = {}
        max_length = float("-inf")

        for num in arr:
            dp[num] = dp.get(num - diff, 0) + 1
            max_length = max(max_length, dp[num])

        return max_length
--


======================================================================================================================


-- Path with maximum gold (Imp) (backtracking)


--
-- https://leetcode.com/problems/path-with-maximum-gold/


--
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        m = len(grid)
        n = len(grid[0])
        # usng backtracking with DFS

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
                return 0

            gold = grid[i][j]
            max_g = float("-inf")
            grid[i][j] = 0

            for nx, ny in directions:
                new_x = i + nx
                new_y = j + ny
                max_g = max(max_g, gold + dfs(new_x, new_y))

            grid[i][j] = gold
            return max_g

        max_gold = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] > 0:
                    max_gold = max(max_gold, dfs(i, j))

        return max_goldclass Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        m = len(grid)
        n = len(grid[0])
        # usng backtracking with DFS

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
                return 0

            gold = grid[i][j]
            max_g = float("-inf")
            grid[i][j] = 0

            for nx, ny in directions:
                new_x = i + nx
                new_y = j + ny
                max_g = max(max_g, gold + dfs(new_x, new_y))

            grid[i][j] = gold
            return max_g

        max_gold = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] > 0:
                    max_gold = max(max_gold, dfs(i, j))

        return max_gold
--


=========================================================================================================================


-- Circular permutation in binary representation


-- https://leetcode.com/problems/circular-permutation-in-binary-representation/
--


--
class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:

        grey_code = [i ^ (i >> 1) for i in range(2 ** n)]
        
        start_index = grey_code.index(start)
        return grey_code[start_index:] + grey_code[:start_index]
--


=========================================================================================================================


-- Maximuum length of a concatenated string with unique characters (Imp)


--
-- https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/


--
class Solution:
    # first solution normal dp
    def maxLength1(self, arr: List[str]) -> int:
        n = len(arr)
        def dfs(index, string):
            m = Counter(string)
            if len(m) != len(string):
                return 0

            if index >= n:
                return len(string)
            
            best = len(string)

            best = max(best, dfs(index + 1, string + arr[index]))
            best = max(best, dfs(index + 1, string))

            return best
        
        return dfs(0, "")

    
    # second solution - Backtrack
    def maxLength2(self, arr: List[str]) -> int:
        n = len(arr)
        def back(index, string):
            m = Counter(string)
            if len(m) != len(string):
                return 0

            if index >= n:
                return len(string)
            
            best = len(string)
            best = max(best, back(index + 1, string + arr[index]))
            best = max(best, back(index + 1, string))

            return best
        
        return back(0, "")

    # bit masking
    def maxLength(self, arr: List[str]) -> int:

        unique_strings = []
        for s in arr:
            if len(set(s)) == len(s):  # Ensure all characters are unique
                unique_strings.append(s)

        def backtrack(index, bitmask, length):
            if index == len(unique_strings):
                return length

            best = length
            curr_string = unique_strings[index]
            curr_mask = 0

            # Create bitmask for the current string
            for c in curr_string:
                bit = 1 << (ord(c) - ord('a'))
                if curr_mask & bit:  # If duplicate character found, skip
                    return best  
                curr_mask |= bit  

            # Include current string if no overlap
            if (bitmask & curr_mask) == 0:
                best = max(best, backtrack(index + 1, bitmask | curr_mask, length + len(curr_string)))

            # Exclude current string
            best = max(best, backtrack(index + 1, bitmask, length))

            return best
        return backtrack(0, 0, 0)

        
--


========================================================================================================================


-- MInimum sqaps to make strings equal


--
-- https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/


--
class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        xy_count, yx_count = 0, 0
    
        for a, b in zip(s1, s2):
            if a == 'x' and b == 'y':
                xy_count += 1
            elif a == 'y' and b == 'x':
                yx_count += 1
        
        # If the sum of both counts is odd, it's impossible
        if (xy_count + yx_count) % 2 != 0:
            return -1
        
        # Each pair of `xy` or `yx` can be swapped in one operation
        return (xy_count // 2) + (yx_count // 2) + 2 * (xy_count % 2)
        

class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        # Count mismatched pairs
        xy_count = 0  # count of (x in s1, y in s2) pairs
        yx_count = 0  # count of (y in s1, x in s2) pairs
        
        for i in range(len(s1)):
            if s1[i] != s2[i]:  # If characters don't match
                if s1[i] == 'x':
                    xy_count += 1
                else:
                    yx_count += 1
        
        # If total mismatches is odd, we can't make strings equal
        if (xy_count + yx_count) % 2 != 0:
            return -1
        
        # Calculate minimum swaps:
        # - For every 2 pairs of xy, we need 1 swap
        # - For every 2 pairs of yx, we need 1 swap
        # - For 1 xy and 1 yx, we need 2 swaps
        
        # Integer division by 2
        swaps = xy_count // 2 + yx_count // 2
        
        # If there are remaining pairs (must be 1 xy and 1 yx)
        if xy_count % 2 == 1:
            swaps += 2
        
        return swaps
                
--

======================================================================================================================

-- Count number of nice subarrays


--
-- https://leetcode.com/problems/count-number-of-nice-subarrays/


--
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        left = 0
        res = 0
        odds = 0
        window = 0
        for right in range(len(nums)):
            if nums[right] % 2 == 1: odds += 1

            if odds == k:
                window = 0
                while odds == k:
                    odds -= nums[left] % 2
                    window += 1
                    left += 1
            res += window
        return res
                
--


=====================================================================================================================


-- Minimum remove to make valid parenthesis


-- https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/
--


--
class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        stack = [] # to store the index of the 

        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            elif s[i] == ')':
                if stack and s[stack[-1]] == "(":
                    stack.pop()
                else:
                    stack.append(i)
        
        res = ""

        for i in range(len(s)):
            if i not in stack:
                res += s[i]
        
        return res

    def minRemoveToMakeValid2(self, s: str) -> str:
        res = []
        cnt = 0 # count of open parenthesis

        for i in range(len(s)):
            if s[i] == "(":
                res.append(s[i])
                cnt += 1
            elif s[i] == ")" and cnt > 0:
                res.append(s[i])
                cnt -= 1
            elif s[i] != ")":
                res.append(s[i])
        
        result = ""

        for i in res[::-1]:
            if i == '(' and cnt > 0:
                cnt -= 1
            else:
                result += i
        
        return result[::-1]
     
--

===================================================================================================================


-- Find the longest euqal substring


--
-- https://leetcode.com/problems/find-the-longest-equal-subarray/submissions/1551804691/


--
class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        freq = Counter()
        n = len(nums)
        left = 0
        max_len = 0
        max_freq = 0

        for right in range(n):
            freq[nums[right]] += 1
            max_freq = max(max_freq, freq[nums[right]])

            # check if we can eleminate any numbers which is bigger frequency element
            while (right - left + 1) - max_freq > k:
                freq[nums[left]] -= 1
                left += 1
            
            max_len = max(max_len, right - left + 1)
        return max_freq
--


===================================================================================================================


