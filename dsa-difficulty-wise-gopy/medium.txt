
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================