
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================


-- Accounts merge


-- https://leetcode.com/problems/accounts-merge/submissions/1400878057/
--

--
from collections import defaultdict

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        g = defaultdict(list)

        for i, account in enumerate(accounts):
            for j in range(1, len(account)):

                email = account[j]
                g[email].append(i) # storing the index for the email 


        vis = [False] * len(accounts)


        def dfs(index, emails):
            if vis[index] == True:
                return
            vis[index] = True
            
            for j in range(1, len(accounts[index])):
                email = accounts[index][j]
                emails.add(email)
                for neighbor in g[email]:
                    if not vis[neighbor]:
                        dfs(neighbor, emails)



        res = []
        for i, account in enumerate(accounts):
            if not vis[i]:
                name = account[0]
                emails = set()
                dfs(i, emails)
                res.append([name] + sorted(emails))
        
        return res

        
--


===============================================================================================================


--  Remove comments


--
--


--
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:

        res = []
        n = len(source)
        block_comment = False

        new_line = ""
        
        for char_arr in source:
            i = 0

            if not block_comment:
                new_line = ""

            while i < len(char_arr):

                if not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '*':
                    block_comment = True
                    i = i + 2
                
                elif block_comment and i + 1 < len(char_arr) and char_arr[i] == '*' and char_arr[i + 1] == '/':
                    block_comment = False
                    i = i + 2

                elif not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '/':
                    break
                
                elif not block_comment:
                    new_line += char_arr[i]
                    i = i + 1

                # if the block_comment is True
                else:
                    i += 1
                
            if not block_comment and new_line:
                res.append(new_line)
            
        
        return res
        return "".join(res)            
--


===================================================================================================================

-- Split Linked list in Parts


--
-- https://leetcode.com/problems/split-linked-list-in-parts/


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        total_nodes = 0
        current = head
        while current:
            total_nodes += 1
            current = current.next
        
        # Step 2: Calculate the base size of each part and the extra nodes
        base_size = total_nodes // k
        extra_nodes = total_nodes % k
        
        # Step 3: Split the list
        parts = []
        current = head
        for i in range(k):
            part_size = base_size + (1 if i < extra_nodes else 0)  # Calculate the size of the current part
            if part_size == 0:
                parts.append(None)  # If the part size is 0, append None
            else:
                part_head = current
                for j in range(part_size - 1):
                    if current:
                        current = current.next
                next_part = None
                if current:
                    next_part = current.next
                    current.next = None  # Break the list

                parts.append(part_head) # important code which is used to get the list in linked lists to array
                current = next_part  # Move to the next part
        
        return parts
--


==============================================================================================================================


-- My Calender I


--
-- https://leetcode.com/problems/my-calendar-i/


--
class MyCalendar:
    def __init__(self):
        # Initialize an empty list to store the events
        self.events = []

    def book(self, start: int, end: int) -> bool:
        # Iterate over the list of events
        for event_start, event_end in self.events:
            # Check if the new event overlaps with an existing event
            if not (end <= event_start or start >= event_end):
                # If there is an overlap, return False (booking fails)
                return False
        # If no overlap is found, add the event to the calendar
        self.events.append((start, end))
        # Return True indicating successful booking
        return True

--


===================================================================================================================


-- NUMBER OF BURGERS with no waste of ingrediants


-- https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/solutions/4840518/easy-beginner-friendly-solution-in-cpp-0ms-beats-100-0-1-solution/
--


--class Solution:
    def numOfBurgers(self, to: int, ch: int) -> List[int]:

        if ch > to:
            return []
        else:
            if (to > ch * 4) and (to < ch * 2):
                return []
            else:
                if to % 2 == 0:
                    x = to - (2 * ch)
                    y = x // 2
                    z = ch - y
                    return [y, z]
                
                else:
                    return []
--


=======================================================================================================================


-- Count the servers that communicate


-- https://leetcode.com/problems/count-servers-that-communicate/
--


--
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        row = [0] * m
        col = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row[i] += 1
                    col[j] += 1
        
        res = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] and (row[i] > 1 or col[j] > 1):
                    res += 1
        
        return res
        
--

==============================================================================================================================


-- Search Suggestions


-- https://leetcode.com/problems/search-suggestions-system/
--

--class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()

        prefix = ""
        res = []

        for i in searchWord:
            prefix += i
            suggestions = []

            for j in range(len(products)):
                if products[j].startswith(prefix):
                    suggestions.append(products[j])
                    if len(suggestions) == 3:
                        break
            
            res.append(suggestions)
        
        return res
--

====================================================================================================================


-- Count squares submatrices with all ones


-- https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/
--

-
class Solution:
    def countSquares(self, mp: List[List[int]]) -> int:
        m = len(mp)
        n = len(mp[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        total_squares = 0

        for i in range(m):
            for j in range(n):

                if mp[i][j] == 1:
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                total_squares += dp[i][j]
        
        return total_squares
-


=============================================================================================================================


-- Group the people given the group size


-- https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
--


--
from collections import defaultdict

class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        m = defaultdict(list)

        for i, num in enumerate(gs):
            m[num].append(i)

        res = []
        for group_size, people in m.items():
            for i in range(0, len(people), group_size):
                res.append(people[i: i + group_size])

        return res

--


==========================================================================================================================

-- Find the smallest divisor given a threshold


-- https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
--

--
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left = 1  # Smallest divisor should start from 1
        right = max(nums)  # Largest possible divisor can be the maximum element in the array

        def check(num):
            csum = 0
            for i in nums:
                csum += ceil(i / num)  # Use ceil to simulate rounding up the division result
            return csum

        ans = float("inf")
        while left <= right:
            mid = (left + right) // 2

            if check(mid) > threshold:
                left = mid + 1
            else:
                ans = min(ans, mid)
                right = mid - 1
        
        return ans
--


============================================================================================================================

-- Remove covered intervals


-- https://leetcode.com/problems/remove-covered-intervals/
--


--
class Solution:
    def removeCoveredIntervals(self, inter: List[List[int]]) -> int:
        cnt = 0
        inter.sort(key=lambda x:(x[0], -x[1]))

        ending_time = 0

        for i in range(len(inter)):
            if ending_time < inter[i][1]:
                cnt += 1
                ending_time = inter[i][1]

        return cnt
--


==========================================================================================================================


-- Sequential digits


-- https://leetcode.com/problems/sequential-digits/
--



--
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:

        num = "123456789"
        res = []

        for length in range(2, 10):
            for start in range(0, 10 - length): # the range is from 0 to 10 - length because the we will be adding length
                number = int(num[start: start + length])

                if low <= number <= high:
                    res.append(number)
        return sorted(res)
--

=======================================================================================================================


-- Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-- https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/1404694299/
--


--
from typing import List

class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize prefix sum matrix
        prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        # Build prefix sum matrix
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # This function gets the sum of the square from (i, j) to (i + k - 1, j + k - 1)
        def get_sum(i, j, k):
            return prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]

        left = 0
        right = min(m, n)
        ans = 0

        # Binary search for the maximum possible square length
        while left <= right:
            mid = (left + right) // 2
            found = False

            # Check for any valid square of side length 'mid'
            for i in range(m - mid + 1):
                for j in range(n - mid + 1):
                    if get_sum(i, j, mid) <= threshold:
                        found = True
                        break
                if found:
                    break

            if found:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1

        return ans

--

=============================================================================================================================

-- Divide Array in Sets of K consecutive numbers

  
-- https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/submissions/1404733179/
--


--
from collections import defaultdict

class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        nums.sort()
        m = defaultdict(int)

        for i in nums:
            m[i] += 1

        for num in nums:
            if m[num] > 0:
                for j in range(num, num + k):
                    if m[j] == 0:
                        return False
                    m[j] -= 1

        return True
--


=================================================================================================================================

-- Maximum Number of Occurances of a substring


-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/
-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/1404853330/


--
from collections import defaultdict
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        string_count = defaultdict(int)
        ans = 0
        for i in range(len(s) - minSize + 1):
            string = s[i : i + minSize]
            unique_string = set(string)
            
            # since the length is used you can use length to get the maximum unique letters
            if len(unique_string) <= maxLetters:
                string_count[string] += 1
                ans = max(ans, string_count[string])

        return ans
--



===============================================================================================================================

-- Sum of Mutated Array Closest to Target


-
- https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/description/

--
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:        
        
        arr.sort()

        prefix_sum = [0]
        for num in arr:
            prefix_sum.append(prefix_sum[-1] + num)

        def helper(arr, value):
            left, right = 0, len(arr) - 1

            while left <= right:
                mid = (left + right)// 2

                if arr[mid] > value:
                    right = mid - 1
                else:
                    left = mid + 1
                
            return left


        left = 0
        right = max(arr)
        closest_sum_diff = float('inf')
        best_value = right

        while left <= right:
            mid = (left + right) // 2

            index = helper(arr, mid)

            # get the total sum after replacing the number with the mid
            curr_sum = prefix_sum[index] + (len(arr) - index) * mid
            diff = abs(curr_sum - target)

            if diff < closest_sum_diff or (diff == closest_sum_diff and mid < best_value):
                best_value = mid
                closest_sum_diff = diff
            
            if curr_sum < target:
                left = mid + 1
            else:
                right = mid - 1

        
        return best_value
--

===============================================================================================================================

-- Deepest leaves sum


-- https://leetcode.com/problems/deepest-leaves-sum/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:

        # returning the array with depth and the node
        def dfs(node, depth):
            if not node:
                return (0, 0)

            if not node.left and not node.right:
                return (node.val, depth)
            
            left = dfs(node.left, depth + 1)
            right = dfs(node.right, depth + 1)

            if left[1] > right[1]:
                return left
            elif right[1] > left[1]:
                return right
            else:
                return (left[0] + right[0], left[1])
        
        return dfs(root, 0)[0]
--


=============================================================================================================================


-- all elements in two binary search trees


-- https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def dfs(node, arr):
            if not node:
                return None

            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)

            return arr
        
        arr1, arr2 = [], []
        arr1 = dfs(root1, arr1) if root1 else []
        arr2 = dfs(root2, arr2) if root2 else []

        i = 0
        j = 0
        ans = []
        n = len(arr1)
        m = len(arr2)

        while i < n and j < m:
            if arr1[i] <= arr2[j]:
                ans.append(arr1[i])
                i += 1
            else:
                ans.append(arr2[j])
                j += 1
        
        ans.extend(arr1[i:])
        ans.extend(arr2[j:])
        
        return ans
        
            
        
--


==========================================================================================================================

-- Jump game 3


-- https://leetcode.com/problems/jump-game-iii/submissions/1405149002/
--


--
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        # Using queue and BFS to get the solution since you can jump to i - arr[i] or i - arr[i]


        q = []
        q.append(start)
        vis = [0] * len(arr)
        n = len(arr)

        while q:

            index = q.pop(0)

            vis[index] = 1
 
            if arr[index] == 0:
                return True

            left = index - arr[index]

            if left >= 0 and not vis[left]:
                q.append(left)
            
            right = index + arr[index]
            if right < n and not vis[right]:
                q.append(right)
        
        return False
--


==============================================================================================================================


-- Xor queries of a subarrya


-- https://leetcode.com/problems/xor-queries-of-a-subarray/
--

--
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        prefix = [0] * (len(arr) + 1)

        for i in range(1, len(arr) + 1):
            prefix[i] = prefix[i - 1] ^ arr[i - 1]

        result = []
        for left, right in queries:
            result.append(prefix[left] ^ prefix[right + 1])
        
        return result
        
--


============================================================================================================================

-- Subarray with given sum


-- https://www.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1?page=1&sortBy=submissions
--


-
class Solution:
    def subArraySum(self,arr, n, s): 
       #Write your code 
       
        left = 0
       
        for right in range(n):
           
            cur_sum += arr[right]
           
            if cur_sum == s:
                return [left + 1, right + 1]
           
            while cur_sum > s and left <= right:
                cur_sum -= arr[left]
                left += 1
            
            if cur_sum == s and s != 0:
                return [left + 1, right + 1]
        
        return [-1]
-


======================================================================================================================

-- Get watched by your friends


-- https://leetcode.com/problems/get-watched-videos-by-your-friends/
--

--
class Solution:
    def watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, level: int) -> List[str]:

        q = []

        # node and the depth
        q.append((id, 0))
        vis = [0] * len(w)
        vis[id] = 1
        res = []

        while q:
            node, cur_level = q.pop(0)

            if cur_level == level:
                res.append(node)
            elif cur_level < level:
                for i in f[node]:
                    if not vis[i]:
                        vis[i] = 1
                        q.append((i, cur_level + 1))
        
        m = {}
        
        # Count the frequency of videos watched by friends at the target level
        for index in res:
            for v in w[index]:
                if v in m:
                    m[v] += 1
                else:
                    m[v] = 1

        return sorted(m.keys(), key=lambda x: (m[x], x))

            

        
--

========================================================================================================================


-- Matrix block sum


-- https://leetcode.com/problems/matrix-block-sum/
--


--
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        # Step 1: Build prefix sum array with extra row and column
        prefix = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # Step 2: Calculate the block sum using the prefix sum
        def get_sum(r1, c1, r2, c2):
            r1, c1 = max(0, r1), max(0, c1)  # handle boundaries
            r2, c2 = min(m, r2), min(n, c2)  # handle boundaries
            return prefix[r2][c2] - prefix[r1][c2] - prefix[r2][c1] + prefix[r1][c1]

        result = [[0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                r1, c1 = i - k, j - k
                r2, c2 = i + k + 1, j + k + 1
                result[i][j] = get_sum(r1, c1, r2, c2)

        return result

--

============================================================================================================================


-- Sum of nodes with even values grandparent


-- https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
--


--
    def sumEvenGrandparent(self, root: TreeNode) -> int:

        def dfs(node, par, grand_par):
            if not node:
                return 0

            sum_of_nodes = 0

            if grand_par and grand_par % 2 == 0:
                sum_of_nodes += node.val
            
            sum_of_nodes += dfs(node.left, node.val, par)
            sum_of_nodes += dfs(node.right, node.val, par)

            return sum_of_nodes
        
        return dfs(root, None, None)
--

===========================================================================================================================


-- Minimum flips to make a or b equal to c


-- https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/submissions/1405746911/
--


--
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        flips = 0

        for i in range(32):
            bit_a = (a >> i) & 1
            bit_b = (b >> i) & 1
            bit_c = (c >> i) & 1

            if bit_c == 1:
                if bit_a == 0 and bit_b == 0:
                    flips += 1 
            else:
                if bit_a == 1:
                    flips += 1
                if bit_b == 1:
                    flips += 1

        return flips

--


========================================================================================================================

-- Print words vertically


-- https://leetcode.com/problems/print-words-vertically/
--

--
class Solution:
    def printVertically(self, s: str) -> List[str]:
        split_arr = s.split()
        max_str_len = max(len(word) for word in split_arr)


        res = []

        i = 0
        while i < max_str_len:
            string_len = ""

            for word in split_arr:
                if i < len(word):
                    string_len += word[i]
                else:
                    string_len += " "
            res.append(string_len.rstrip())
            i += 1

        return res     
--


============================================================================================================================

-- Delete leaves with a given value


-- https://leetcode.com/problems/delete-leaves-with-a-given-value/
--


--
class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        temp = root

        def dfs(node, target):

            if not node:
                return None

            node.left = dfs(node.left, target)
            node.right = dfs(node.right, target)

            if not node.left and not node.right and node.val == target:
                return None
            return node
        
        return dfs(root, target)
--

===========================================================================================================================

-- break a Palindrome (Important)


-- https://leetcode.com/problems/break-a-palindrome/description/
--


--
class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n <= 1:
            return ""

        # Traverse the string untill the half length 
        # if the character is "a" is not found at that position, replace and return
        # else if all the characters are "a" then replace the last element with next character "b"

        res = list(palindrome)

        for i in range(len(res) // 2):
            if palindrome[i] != 'a':
                res[i] = 'a'
                return "".join(res)
        
        res[-1] = 'b'
        return "".join(res)
--


=====================================================================================================================


-- Sort the matrix diagonally


-- https://leetcode.com/problems/sort-the-matrix-diagonally/
--


--
from collections import defaultdict

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:

        diagonals = defaultdict(list)
        
        m, n = len(mat), len(mat[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i - j has the same slope for diagonal elements
        for i in range(m):
            for j in range(n):
                heapq.heappush(diagonals[i - j], mat[i][j])
        
        # Step 2: Replace matrix elements with the sorted diagonal elements from the heap
        for i in range(m):
            for j in range(n):
                mat[i][j] = heapq.heappop(diagonals[i - j])
        
        return mat
--


===============================================================================================================================


-- Filter restaurents by vegan friendly price and distance


-- https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/submissions/1405999741/
--


--
class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        n = len(restaurants)
        res = []
        for i in range(n):
            if (veganFriendly == 0 or restaurants[i][2] == veganFriendly) and restaurants[i][3] <= maxPrice and restaurants[i][4] <= maxDistance:
                res.append((restaurants[i][1], restaurants[i][0]))

        res.sort(reverse=True,key=lambda x:(x[0], x[1]))

        return [v for u, v in res]
--


===========================================================================================================================

-- Reduce array size to the half


-- https://leetcode.com/problems/reduce-array-size-to-the-half/
--


--
from heapq import heappop, heappush
from collections import defaultdict
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        m = defaultdict(int)

        n = len(arr)

        for i in range(n):
            m[arr[i]] += 1
        
        # m now has the freqeuncy array
        m = sorted(m.values(), reverse=True)
        cnt = 0
        removed_el = 0

        # iterate through the frequency array reduce that frequency amount and increment the count
        for i in m:
            removed_el += i
            cnt += 1

            if removed_el >= n // 2:
                break

        return cnt
            
--


==================================================================================================================================

-- Maximum prodcut of splitted binary tree


-- https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7  # To return the result modulo 10^9 + 7
        total_sum = 0  # To store the total sum of the tree
        max_product = 0  # To store the maximum product

        # First, get the total sum of the entire tree
        def get_total_sum(node):
            if not node:
                return 0
            return node.val + get_total_sum(node.left) + get_total_sum(node.right)

        # Second, calculate the max product by finding each subtree's sum
        def get_subtree_sum(node):
            nonlocal max_product
            if not node:
                return 0

            # Get the sum of the current subtree
            left_sum = get_subtree_sum(node.left)
            right_sum = get_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # Calculate product of splitting the tree at this subtree
            max_product = max(max_product, (total_sum - subtree_sum) * subtree_sum)

            return subtree_sum

        # Step 1: Calculate the total sum of the tree
        total_sum = get_total_sum(root)

        # Step 2: Traverse again to calculate the max product
        get_subtree_sum(root)

        # Return the maximum product modulo 10^9 + 7
        return max_product % MOD
--


===================================================================================================================================


-- Number of subarrys of size k and average greater than or equal to threshold


-- https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
--


--
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        n = len(arr)
        left = 0
        right = 0
        cur_sum = 0
        cnt = 0

        while right < n:
            cur_sum += arr[right]

            if right - left + 1 < k:
                right += 1
                continue
            else:
                if (cur_sum // k)  >= threshold:
                    cnt += 1
                
                cur_sum -= arr[left]
                
                right += 1
                left += 1 
        
        return cnt
            
        
--

===========================================================================================================================

-- Angle between hands of a clock


-- https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/submissions/1406105855/
--


--
from collections import defaultdict

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        map_s = defaultdict(int)
        map_t = defaultdict(int)
        n = len(s)
        m = len(t)
        i = 0
        j = 0

        while i < n or j < m:
            if i < n:
                map_s[s[i]] += 1
            if j < n:
                map_t[t[i]] += 1
            i += 1
            j += 1
        

        cnt = 0

        for char in map_s:
            if map_s[char] > map_t[char]:
                cnt += map_s[char] - map_t[char]

        return cnt       

        
--


====================================================================================================================


-- Tweet Counts per Frequency

-- https://leetcode.com/problems/tweet-counts-per-frequency/description/


--
--

============================================================================================================================


-- Maximum number of events that can be attended


-- https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
--


--
from heapq import heappush, heappop

class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        
        events.sort()
        n = len(events)

        current_day = 0
        event_count = 0
        i = 0

        heap = []

        while i < n or heap:
            
            # is not heap move the next available date of start date
            if not heap:
                current_day = events[i][0]
            
            # add all the events which is on the current day
            while i < n and events[i][0] <= current_day:
                heappush(heap, events[i][1])
                i += 1
            
            # Remove events from the heap that have already ended
            while heap and heap[0] < current_day:
                heappop(heap)

            if heap:
                heappop(heap)
                event_count += 1
        
            current_day += 1

        return event_count

            

        
--


=============================================================================================================================