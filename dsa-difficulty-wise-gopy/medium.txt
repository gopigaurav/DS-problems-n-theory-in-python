
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================


-- Accounts merge


-- https://leetcode.com/problems/accounts-merge/submissions/1400878057/
--

--
from collections import defaultdict

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        g = defaultdict(list)

        for i, account in enumerate(accounts):
            for j in range(1, len(account)):

                email = account[j]
                g[email].append(i) # storing the index for the email 


        vis = [False] * len(accounts)


        def dfs(index, emails):
            if vis[index] == True:
                return
            vis[index] = True
            
            for j in range(1, len(accounts[index])):
                email = accounts[index][j]
                emails.add(email)
                for neighbor in g[email]:
                    if not vis[neighbor]:
                        dfs(neighbor, emails)



        res = []
        for i, account in enumerate(accounts):
            if not vis[i]:
                name = account[0]
                emails = set()
                dfs(i, emails)
                res.append([name] + sorted(emails))
        
        return res

        
--


===============================================================================================================


--  Remove comments


--
--


--
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:

        res = []
        n = len(source)
        block_comment = False

        new_line = ""
        
        for char_arr in source:
            i = 0

            if not block_comment:
                new_line = ""

            while i < len(char_arr):

                if not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '*':
                    block_comment = True
                    i = i + 2
                
                elif block_comment and i + 1 < len(char_arr) and char_arr[i] == '*' and char_arr[i + 1] == '/':
                    block_comment = False
                    i = i + 2

                elif not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '/':
                    break
                
                elif not block_comment:
                    new_line += char_arr[i]
                    i = i + 1

                # if the block_comment is True
                else:
                    i += 1
                
            if not block_comment and new_line:
                res.append(new_line)
            
        
        return res
        return "".join(res)            
--


===================================================================================================================

-- Split Linked list in Parts


--
-- https://leetcode.com/problems/split-linked-list-in-parts/


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        total_nodes = 0
        current = head
        while current:
            total_nodes += 1
            current = current.next
        
        # Step 2: Calculate the base size of each part and the extra nodes
        base_size = total_nodes // k
        extra_nodes = total_nodes % k
        
        # Step 3: Split the list
        parts = []
        current = head
        for i in range(k):
            part_size = base_size + (1 if i < extra_nodes else 0)  # Calculate the size of the current part
            if part_size == 0:
                parts.append(None)  # If the part size is 0, append None
            else:
                part_head = current
                for j in range(part_size - 1):
                    if current:
                        current = current.next
                next_part = None
                if current:
                    next_part = current.next
                    current.next = None  # Break the list

                parts.append(part_head) # important code which is used to get the list in linked lists to array
                current = next_part  # Move to the next part
        
        return parts
--


==============================================================================================================================


-- My Calender I


--
-- https://leetcode.com/problems/my-calendar-i/


--
class MyCalendar:
    def __init__(self):
        # Initialize an empty list to store the events
        self.events = []

    def book(self, start: int, end: int) -> bool:
        # Iterate over the list of events
        for event_start, event_end in self.events:
            # Check if the new event overlaps with an existing event
            if not (end <= event_start or start >= event_end):
                # If there is an overlap, return False (booking fails)
                return False
        # If no overlap is found, add the event to the calendar
        self.events.append((start, end))
        # Return True indicating successful booking
        return True

--


===================================================================================================================


-- NUMBER OF BURGERS with no waste of ingrediants


-- https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/solutions/4840518/easy-beginner-friendly-solution-in-cpp-0ms-beats-100-0-1-solution/
--


--class Solution:
    def numOfBurgers(self, to: int, ch: int) -> List[int]:

        if ch > to:
            return []
        else:
            if (to > ch * 4) and (to < ch * 2):
                return []
            else:
                if to % 2 == 0:
                    x = to - (2 * ch)
                    y = x // 2
                    z = ch - y
                    return [y, z]
                
                else:
                    return []
--


=======================================================================================================================


-- Count the servers that communicate


-- https://leetcode.com/problems/count-servers-that-communicate/
--


--
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        row = [0] * m
        col = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row[i] += 1
                    col[j] += 1
        
        res = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] and (row[i] > 1 or col[j] > 1):
                    res += 1
        
        return res
        
--

==============================================================================================================================


-- Search Suggestions


-- https://leetcode.com/problems/search-suggestions-system/
--

--class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()

        prefix = ""
        res = []

        for i in searchWord:
            prefix += i
            suggestions = []

            for j in range(len(products)):
                if products[j].startswith(prefix):
                    suggestions.append(products[j])
                    if len(suggestions) == 3:
                        break
            
            res.append(suggestions)
        
        return res
--

====================================================================================================================


-- Count squares submatrices with all ones


-- https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/
--

-
class Solution:
    def countSquares(self, mp: List[List[int]]) -> int:
        m = len(mp)
        n = len(mp[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        total_squares = 0

        for i in range(m):
            for j in range(n):

                if mp[i][j] == 1:
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                total_squares += dp[i][j]
        
        return total_squares
-


=============================================================================================================================


-- Group the people given the group size


-- https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
--


--
from collections import defaultdict

class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        m = defaultdict(list)

        for i, num in enumerate(gs):
            m[num].append(i)

        res = []
        for group_size, people in m.items():
            for i in range(0, len(people), group_size):
                res.append(people[i: i + group_size])

        return res

--


==========================================================================================================================

-- Find the smallest divisor given a threshold


-- https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
--

--
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left = 1  # Smallest divisor should start from 1
        right = max(nums)  # Largest possible divisor can be the maximum element in the array

        def check(num):
            csum = 0
            for i in nums:
                csum += ceil(i / num)  # Use ceil to simulate rounding up the division result
            return csum

        ans = float("inf")
        while left <= right:
            mid = (left + right) // 2

            if check(mid) > threshold:
                left = mid + 1
            else:
                ans = min(ans, mid)
                right = mid - 1
        
        return ans
--


============================================================================================================================

-- Remove covered intervals


-- https://leetcode.com/problems/remove-covered-intervals/
--


--
class Solution:
    def removeCoveredIntervals(self, inter: List[List[int]]) -> int:
        cnt = 0
        inter.sort(key=lambda x:(x[0], -x[1]))

        ending_time = 0

        for i in range(len(inter)):
            if ending_time < inter[i][1]:
                cnt += 1
                ending_time = inter[i][1]

        return cnt
--


==========================================================================================================================


-- Sequential digits


-- https://leetcode.com/problems/sequential-digits/
--



--
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:

        num = "123456789"
        res = []

        for length in range(2, 10):
            for start in range(0, 10 - length): # the range is from 0 to 10 - length because the we will be adding length
                number = int(num[start: start + length])

                if low <= number <= high:
                    res.append(number)
        return sorted(res)
--

=======================================================================================================================


-- Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-- https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/1404694299/
--


--
from typing import List

class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize prefix sum matrix
        prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        # Build prefix sum matrix
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # This function gets the sum of the square from (i, j) to (i + k - 1, j + k - 1)
        def get_sum(i, j, k):
            return prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]

        left = 0
        right = min(m, n)
        ans = 0

        # Binary search for the maximum possible square length
        while left <= right:
            mid = (left + right) // 2
            found = False

            # Check for any valid square of side length 'mid'
            for i in range(m - mid + 1):
                for j in range(n - mid + 1):
                    if get_sum(i, j, mid) <= threshold:
                        found = True
                        break
                if found:
                    break

            if found:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1

        return ans

--

=============================================================================================================================

-- Divide Array in Sets of K consecutive numbers

  
-- https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/submissions/1404733179/
--


--
from collections import defaultdict

class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        nums.sort()
        m = defaultdict(int)

        for i in nums:
            m[i] += 1

        for num in nums:
            if m[num] > 0:
                for j in range(num, num + k):
                    if m[j] == 0:
                        return False
                    m[j] -= 1

        return True
--


=================================================================================================================================

-- Maximum Number of Occurances of a substring


-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/
-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/1404853330/


--
from collections import defaultdict
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        string_count = defaultdict(int)
        ans = 0
        for i in range(len(s) - minSize + 1):
            string = s[i : i + minSize]
            unique_string = set(string)
            
            # since the length is used you can use length to get the maximum unique letters
            if len(unique_string) <= maxLetters:
                string_count[string] += 1
                ans = max(ans, string_count[string])

        return ans
--



===============================================================================================================================

-- Sum of Mutated Array Closest to Target


-
- https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/description/

--
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:        
        
        arr.sort()

        prefix_sum = [0]
        for num in arr:
            prefix_sum.append(prefix_sum[-1] + num)

        def helper(arr, value):
            left, right = 0, len(arr) - 1

            while left <= right:
                mid = (left + right)// 2

                if arr[mid] > value:
                    right = mid - 1
                else:
                    left = mid + 1
                
            return left


        left = 0
        right = max(arr)
        closest_sum_diff = float('inf')
        best_value = right

        while left <= right:
            mid = (left + right) // 2

            index = helper(arr, mid)

            # get the total sum after replacing the number with the mid
            curr_sum = prefix_sum[index] + (len(arr) - index) * mid
            diff = abs(curr_sum - target)

            if diff < closest_sum_diff or (diff == closest_sum_diff and mid < best_value):
                best_value = mid
                closest_sum_diff = diff
            
            if curr_sum < target:
                left = mid + 1
            else:
                right = mid - 1

        
        return best_value
--

===============================================================================================================================

-- Deepest leaves sum


-- https://leetcode.com/problems/deepest-leaves-sum/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:

        # returning the array with depth and the node
        def dfs(node, depth):
            if not node:
                return (0, 0)

            if not node.left and not node.right:
                return (node.val, depth)
            
            left = dfs(node.left, depth + 1)
            right = dfs(node.right, depth + 1)

            if left[1] > right[1]:
                return left
            elif right[1] > left[1]:
                return right
            else:
                return (left[0] + right[0], left[1])
        
        return dfs(root, 0)[0]
--


=============================================================================================================================


-- all elements in two binary search trees


-- https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def dfs(node, arr):
            if not node:
                return None

            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)

            return arr
        
        arr1, arr2 = [], []
        arr1 = dfs(root1, arr1) if root1 else []
        arr2 = dfs(root2, arr2) if root2 else []

        i = 0
        j = 0
        ans = []
        n = len(arr1)
        m = len(arr2)

        while i < n and j < m:
            if arr1[i] <= arr2[j]:
                ans.append(arr1[i])
                i += 1
            else:
                ans.append(arr2[j])
                j += 1
        
        ans.extend(arr1[i:])
        ans.extend(arr2[j:])
        
        return ans
        
            
        
--


==========================================================================================================================

-- Jump game 3


-- https://leetcode.com/problems/jump-game-iii/submissions/1405149002/
--


--
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        # Using queue and BFS to get the solution since you can jump to i - arr[i] or i - arr[i]


        q = []
        q.append(start)
        vis = [0] * len(arr)
        n = len(arr)

        while q:

            index = q.pop(0)

            vis[index] = 1
 
            if arr[index] == 0:
                return True

            left = index - arr[index]

            if left >= 0 and not vis[left]:
                q.append(left)
            
            right = index + arr[index]
            if right < n and not vis[right]:
                q.append(right)
        
        return False
--


==============================================================================================================================


-- Xor queries of a subarrya


-- https://leetcode.com/problems/xor-queries-of-a-subarray/
--

--
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        prefix = [0] * (len(arr) + 1)

        for i in range(1, len(arr) + 1):
            prefix[i] = prefix[i - 1] ^ arr[i - 1]

        result = []
        for left, right in queries:
            result.append(prefix[left] ^ prefix[right + 1])
        
        return result
        
--


============================================================================================================================

-- Subarray with given sum


-- https://www.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1?page=1&sortBy=submissions
--


-
class Solution:
    def subArraySum(self,arr, n, s): 
       #Write your code 
       
        left = 0
       
        for right in range(n):
           
            cur_sum += arr[right]
           
            if cur_sum == s:
                return [left + 1, right + 1]
           
            while cur_sum > s and left <= right:
                cur_sum -= arr[left]
                left += 1
            
            if cur_sum == s and s != 0:
                return [left + 1, right + 1]
        
        return [-1]
-


======================================================================================================================

-- Get watched by your friends


-- https://leetcode.com/problems/get-watched-videos-by-your-friends/
--

--
class Solution:
    def watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, level: int) -> List[str]:

        q = []

        # node and the depth
        q.append((id, 0))
        vis = [0] * len(w)
        vis[id] = 1
        res = []

        while q:
            node, cur_level = q.pop(0)

            if cur_level == level:
                res.append(node)
            elif cur_level < level:
                for i in f[node]:
                    if not vis[i]:
                        vis[i] = 1
                        q.append((i, cur_level + 1))
        
        m = {}
        
        # Count the frequency of videos watched by friends at the target level
        for index in res:
            for v in w[index]:
                if v in m:
                    m[v] += 1
                else:
                    m[v] = 1

        return sorted(m.keys(), key=lambda x: (m[x], x))

            

        
--

========================================================================================================================


-- Matrix block sum


-- https://leetcode.com/problems/matrix-block-sum/
--


--
from typing import List

class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        # Step 1: Build prefix sum array with extra row and column
        prefix = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # Step 2: Calculate the block sum using the prefix sum
        def get_sum(r1, c1, r2, c2):
            r1, c1 = max(0, r1), max(0, c1)  # handle boundaries
            r2, c2 = min(m, r2), min(n, c2)  # handle boundaries
            return prefix[r2][c2] - prefix[r1][c2] - prefix[r2][c1] + prefix[r1][c1]

        result = [[0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                r1, c1 = i - k, j - k
                r2, c2 = i + k + 1, j + k + 1
                result[i][j] = get_sum(r1, c1, r2, c2)

        return result

--

============================================================================================================================


-- Sum of nodes with even values grandparent


-- https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
--


--
    def sumEvenGrandparent(self, root: TreeNode) -> int:

        def dfs(node, par, grand_par):
            if not node:
                return 0

            sum_of_nodes = 0

            if grand_par and grand_par % 2 == 0:
                sum_of_nodes += node.val
            
            sum_of_nodes += dfs(node.left, node.val, par)
            sum_of_nodes += dfs(node.right, node.val, par)

            return sum_of_nodes
        
        return dfs(root, None, None)
--

===========================================================================================================================


-- Minimum flips to make a or b equal to c


-- https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/submissions/1405746911/
--


--
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        flips = 0

        for i in range(32):
            bit_a = (a >> i) & 1
            bit_b = (b >> i) & 1
            bit_c = (c >> i) & 1

            if bit_c == 1:
                if bit_a == 0 and bit_b == 0:
                    flips += 1 
            else:
                if bit_a == 1:
                    flips += 1
                if bit_b == 1:
                    flips += 1

        return flips

--


========================================================================================================================

-- Print words vertically


-- https://leetcode.com/problems/print-words-vertically/
--

--
class Solution:
    def printVertically(self, s: str) -> List[str]:
        split_arr = s.split()
        max_str_len = max(len(word) for word in split_arr)


        res = []

        i = 0
        while i < max_str_len:
            string_len = ""

            for word in split_arr:
                if i < len(word):
                    string_len += word[i]
                else:
                    string_len += " "
            res.append(string_len.rstrip())
            i += 1

        return res     
--


============================================================================================================================

-- Delete leaves with a given value


-- https://leetcode.com/problems/delete-leaves-with-a-given-value/
--


--
class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        temp = root

        def dfs(node, target):

            if not node:
                return None

            node.left = dfs(node.left, target)
            node.right = dfs(node.right, target)

            if not node.left and not node.right and node.val == target:
                return None
            return node
        
        return dfs(root, target)
--

===========================================================================================================================

-- break a Palindrome (Important)


-- https://leetcode.com/problems/break-a-palindrome/description/
--


--
class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n <= 1:
            return ""

        # Traverse the string untill the half length 
        # if the character is "a" is not found at that position, replace and return
        # else if all the characters are "a" then replace the last element with next character "b"

        res = list(palindrome)

        for i in range(len(res) // 2):
            if palindrome[i] != 'a':
                res[i] = 'a'
                return "".join(res)
        
        res[-1] = 'b'
        return "".join(res)
--


=====================================================================================================================


-- Sort the matrix diagonally


-- https://leetcode.com/problems/sort-the-matrix-diagonally/
--


--
from collections import defaultdict

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:

        diagonals = defaultdict(list)
        
        m, n = len(mat), len(mat[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i - j has the same slope for diagonal elements
        for i in range(m):
            for j in range(n):
                heapq.heappush(diagonals[i - j], mat[i][j])
        
        # Step 2: Replace matrix elements with the sorted diagonal elements from the heap
        for i in range(m):
            for j in range(n):
                mat[i][j] = heapq.heappop(diagonals[i - j])
        
        return mat
--


===============================================================================================================================


-- Filter restaurents by vegan friendly price and distance


-- https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/submissions/1405999741/
--


--
class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        n = len(restaurants)
        res = []
        for i in range(n):
            if (veganFriendly == 0 or restaurants[i][2] == veganFriendly) and restaurants[i][3] <= maxPrice and restaurants[i][4] <= maxDistance:
                res.append((restaurants[i][1], restaurants[i][0]))

        res.sort(reverse=True,key=lambda x:(x[0], x[1]))

        return [v for u, v in res]
--


===========================================================================================================================

-- Reduce array size to the half


-- https://leetcode.com/problems/reduce-array-size-to-the-half/
--


--
from heapq import heappop, heappush
from collections import defaultdict
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        m = defaultdict(int)

        n = len(arr)

        for i in range(n):
            m[arr[i]] += 1
        
        # m now has the freqeuncy array
        m = sorted(m.values(), reverse=True)
        cnt = 0
        removed_el = 0

        # iterate through the frequency array reduce that frequency amount and increment the count
        for i in m:
            removed_el += i
            cnt += 1

            if removed_el >= n // 2:
                break

        return cnt
            
--


==================================================================================================================================

-- Maximum prodcut of splitted binary tree


-- https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7  # To return the result modulo 10^9 + 7
        total_sum = 0  # To store the total sum of the tree
        max_product = 0  # To store the maximum product

        # First, get the total sum of the entire tree
        def get_total_sum(node):
            if not node:
                return 0
            return node.val + get_total_sum(node.left) + get_total_sum(node.right)

        # Second, calculate the max product by finding each subtree's sum
        def get_subtree_sum(node):
            nonlocal max_product
            if not node:
                return 0

            # Get the sum of the current subtree
            left_sum = get_subtree_sum(node.left)
            right_sum = get_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # Calculate product of splitting the tree at this subtree
            max_product = max(max_product, (total_sum - subtree_sum) * subtree_sum)

            return subtree_sum

        # Step 1: Calculate the total sum of the tree
        total_sum = get_total_sum(root)

        # Step 2: Traverse again to calculate the max product
        get_subtree_sum(root)

        # Return the maximum product modulo 10^9 + 7
        return max_product % MOD
--


===================================================================================================================================


-- Number of subarrys of size k and average greater than or equal to threshold


-- https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
--


--
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        n = len(arr)
        left = 0
        right = 0
        cur_sum = 0
        cnt = 0

        while right < n:
            cur_sum += arr[right]

            if right - left + 1 < k:
                right += 1
                continue
            else:
                if (cur_sum // k)  >= threshold:
                    cnt += 1
                
                cur_sum -= arr[left]
                
                right += 1
                left += 1 
        
        return cnt
            
        
--

===========================================================================================================================

-- Angle between hands of a clock


-- https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/submissions/1406105855/
--


--
from collections import defaultdict

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        map_s = defaultdict(int)
        map_t = defaultdict(int)
        n = len(s)
        m = len(t)
        i = 0
        j = 0

        while i < n or j < m:
            if i < n:
                map_s[s[i]] += 1
            if j < n:
                map_t[t[i]] += 1
            i += 1
            j += 1
        

        cnt = 0

        for char in map_s:
            if map_s[char] > map_t[char]:
                cnt += map_s[char] - map_t[char]

        return cnt       

        
--


====================================================================================================================


-- Tweet Counts per Frequency

-- https://leetcode.com/problems/tweet-counts-per-frequency/description/


--
--

============================================================================================================================


-- Maximum number of events that can be attended


-- https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
--


--
from heapq import heappush, heappop

class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        
        events.sort()
        n = len(events)

        current_day = 0
        event_count = 0
        i = 0

        heap = []

        while i < n or heap:
            
            # is not heap move the next available date of start date
            if not heap:
                current_day = events[i][0]
            
            # add all the events which is on the current day
            while i < n and events[i][0] <= current_day:
                heappush(heap, events[i][1])
                i += 1
            
            # Remove events from the heap that have already ended
            while heap and heap[0] < current_day:
                heappop(heap)

            if heap:
                heappop(heap)
                event_count += 1
        
            current_day += 1

        return event_count

            

        
--


=============================================================================================================================


-- Number of substrings containing all three characters


--
--

--
from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        char_count = defaultdict(int)
        n = len(s)

        i = 0
        j = 0
        k = 3
        cnt = 0
        
        while j < n:
            char_count[s[j]] += 1

            while len(char_count) == 3:

                cnt += len(s) - j
                char_count[s[i]] -= 1

                if char_count[s[i]] == 0:
                    del char_count[s[i]]
                i += 1
            j += 1
        
        return cnt

--


==============================================================================================================================

-- Validate binary tree nodes

-- https://leetcode.com/problems/validate-binary-tree-nodes/
--


--
class Solution:
    def validateBinaryTreeNodes(self, n: int, left: List[int], right: List[int]) -> bool:

        indegree = [0] * n

        i = 0

        while i < n:
            if left[i] != -1:
                indegree[left[i]] += 1
            if right[i] != -1:
                indegree[right[i]] += 1

            i += 1

        # root count should be equal to 1 if not return False
        root_count = 0
        root = -1
        for i in range(n):
            if indegree[i] == 0:
                root_count += 1
                root = i
        
        # If there's not exactly one root, it's not a valid binary tree
        if root_count != 1:
            return False
        
        vis = [0] * n
        cycle = True
        def dfs(node, vis):
            nonlocal cycle
            if node == -1:
                return

            if vis[node]: # there is a cycle in the binary tree
                cycle = False
                return 

            vis[node] = 1

            dfs(left[node], vis)
            dfs(right[node], vis)

        # dfs to check all the nodes to be connected or not
        dfs(root, vis)
        return all(vis) and cycle
    
        
--


==========================================================================================================================

-- Closest divisers 


-- https://leetcode.com/problems/closest-divisors/submissions/1407425844/
--



--
import math
class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        
        def find_closest_product(n):
            for i in range(int(math.sqrt(n)), 0, -1):
                if n % i == 0:
                    return [i, n // i]

        num1_divisor = find_closest_product(num + 1)
        num2_divisor = find_closest_product(num + 2)

        if abs(num1_divisor[0] - num1_divisor[1]) > abs(num2_divisor[0] - num2_divisor[1]):
            return num2_divisor
        else:
            return num1_divisor
        
--


====================================================================================================================================


-- Rank team by votes  (Imp)


-- https://leetcode.com/problems/rank-teams-by-votes/submissions/1407807178/
--


--
class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        
        teams = len(votes[0])
        d = {}

        for vote in votes:
            for i, char in enumerate(vote):
                if char not in d:
                    d[char] = [0] * len(vote)
                d[char][i] += 1

        voted_name = sorted(d.keys())
        print(voted_name, d)

        return "".join(sorted(voted_name, key=lambda x:d[x], reverse=True))
--


================================================================================================================================

-- Linked list in a binary tree


-- https://leetcode.com/problems/linked-list-in-binary-tree/
--


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        def dfs(listnode, treenode):
            if not listnode:  # If we've reached the end of the list, it's a match
                return True
            if not treenode:  # If the tree node is None, no match
                return False
            if listnode.val != treenode.val:  # If values don't match, return False
                return False
            # Recursively check both left and right subtrees
            return dfs(listnode.next, treenode.left) or dfs(listnode.next, treenode.right)


        if not root:
            return False
        
        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

--


==================================================================================================================


-- Find the longest substring containing vowels in even counts (Imp)


-- https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/
--


--
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # Map vowels to their bit positions
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        
        # Bitmask to track the parity of vowel counts
        bitmask = 0
        
        # Dictionary to store the first occurrence of each bitmask
        position_map = {0: -1}
        
        # Variable to store the maximum length of the valid substring
        max_len = 0
        
        for i, char in enumerate(s):
            # If the character is a vowel, flip the corresponding bit
            if char in vowels:
                bitmask ^= vowels[char]
            
            # If the current bitmask has been seen before
            if bitmask in position_map:
                # Update max_len with the distance between current index and previous occurrence of the same bitmask
                max_len = max(max_len, i - position_map[bitmask])
            else:
                # Otherwise, store the first occurrence of this bitmask
                position_map[bitmask] = i
        
        return max_len

--


========================================================================================================================

-- Longest zig zag path in a binary tree


-- https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
--


--
class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def traverse(node, cnt, prev):
            nonlocal ans
            if not node:
                ans = max(ans, cnt)
                return
            if prev:
                traverse(node.left, cnt+1, 0)
                traverse(node.right, 0, 1)
            else:
                traverse(node.right, cnt+1, 1)
                traverse(node.left, 0, 0)
        traverse(root.left, 0, 0)
        traverse(root.right, 0, 1)
        return ans
--


=====================================================================================================================

-- Number of times binary string is prefix aligned


-- https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/
--


--
class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        max_flipped = 0

        cnt = 0

        for i, flip in enumerate(flips, 1): # 1 at the end make it 1 index
            max_flipped = max(max_flipped, flip)

            if max_flipped == i:
                cnt += 1
        
        return cnt
--


=============================================================================================================================
-- Time needed to inform all employees


-- https://leetcode.com/problems/time-needed-to-inform-all-employees/
--


--
class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        
        # construct the graph from the given node

        g = defaultdict(list)

        for i, emp in enumerate(manager):
            if emp != -1:
                g[emp].append(i)
    

        def dfs(node):
            if node not in g:
                return 0
            max_time = 0

            for i in g[node]:
                max_time = max(dfs(i), max_time)
            return max_time + informTime[node]



        return dfs(headID)
--


=================================================================================================================================

-- Balanace a binary tree


-- https://leetcode.com/problems/balance-a-binary-search-tree/submissions/1409087547/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        # for the bst given get eh elements in the binary search tree to an array through inorder traversal
        # get the root and the left part comes to the left side and right part comes to right side of the root

        arr = []

        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            arr.append(node.val)
            inorder(node.right)

        inorder(root)

        def dfs(left, right):
            if left > right:
                return None

            mid = (left + right) // 2

            node = TreeNode(arr[mid])

            node.left = dfs(left, mid - 1)
            node.right = dfs(mid + 1, right)

            return node

        
        return dfs(0, len(arr) - 1)

--


=============================================================================================================================



-- Cinema seat allocation


--
--


--
class Solution:
	def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
		seats = collections.defaultdict(set)

		for i,j in reservedSeats:
			if j in [2,3,4,5]:
				seats[i].add(0)
			if j in [4,5,6,7]:
				seats[i].add(1)
			if j in [6,7,8,9]:
				seats[i].add(2)
		res = 2*n
		for i in seats:
			if len(seats[i]) == 3:
				res -= 2
			else:
				res -= 1

		return res
--


==========================================================================================================================

-- Sort the integers by the power value


-- 
-- https://leetcode.com/problems/sort-integers-by-the-power-value/


--
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:

        def get_power_value(x):
            steps = 0

            while x > 1:
                if x % 2 == 0:
                    x = x // 2
                else:
                    x = x * 3 + 1
                steps += 1
            return steps

        res = []
        for i in range(lo, hi + 1):
            res.append((get_power_value(i), i))
        
        res.sort(key=lambda x:x[0])

        return res[k - 1][1]
            

        
--


==========================================================================================================================


-- Count the number of teams


-- https://leetcode.com/problems/count-number-of-teams/submissions/1409330184/
--


--
class Solution:
    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        if n < 3:
            return 0
        
        # Initialize arrays to count smaller and larger soldiers to the left and right
        left_smaller = [0] * n
        left_larger = [0] * n
        right_smaller = [0] * n
        right_larger = [0] * n
        
        # Calculate the left_smaller and left_larger for each soldier
        for i in range(n):
            for j in range(i):
                if rating[j] < rating[i]:
                    left_smaller[i] += 1
                elif rating[j] > rating[i]:
                    left_larger[i] += 1
        
        # Calculate the right_smaller and right_larger for each soldier
        for i in range(n):
            for j in range(i + 1, n):
                if rating[j] > rating[i]:
                    right_larger[i] += 1
                elif rating[j] < rating[i]:
                    right_smaller[i] += 1
        
        # Calculate the number of valid teams
        total_teams = 0
        for i in range(n):
            # Increasing triplets
            total_teams += left_smaller[i] * right_larger[i]
            # Decreasing triplets
            total_teams += left_larger[i] * right_smaller[i]
        
        return total_teams


        
--


==============================================================================================================================

-- Contruct k paindrome strings


-- https://leetcode.com/problems/construct-k-palindrome-strings/submissions/1409350280/
--


--
class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False

        n = len(s)
        m = {}
        
        for i in s:
            m[i] = m.get(i, 0) + 1
        
        # the frequency of the character is greter than k then it is impossible to form the palindromic string 
        # else it is true
        odd_count = sum(1 for count in m.values() if count % 2 != 0)

        return odd_count <= k 

        
--

=============================================================================================================================


-- Number of steps to reduce in binary representation to one



--
-- https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/


--
class Solution:
    def numSteps(self, s: str) -> int:
        steps = 0
        
        while s != "1":
            if s[-1] == "0":
                s = s[:-1]
            else:
                # convert the string to decimal increment and then convert back to binary eg "0b1110"
                s = bin(int(s, 2) + 1)[2:]
            steps += 1

        return steps
        
--

===============================================================================================================================


-- Longest happy string


-- https://leetcode.com/problems/longest-happy-string/submissions/1409397836/
--


--
from collections import Counter

class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        m = Counter({"a": a, "b": b, "c": c})
        res = ["#"]

        while True:
            (a1, count1), (a2, count2) = m.most_common(2)

            if a1 == res[-1] == res[-2]:
                a1 = a2 # if 2 char is already present in the response array just use the second character

            if not m[a1]:
                break
            res.append(a1)
            m[a1] -= 1
            
        
        return "".join(res[1:])
--


========================================================================================================================

-- Queries on a permutaion with key (Imp)



-- https://leetcode.com/problems/queries-on-a-permutation-with-key/
--


--
class Solution: 
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        result = []
        
        m = [x for x in range(1, m + 1)]
        
        for x in queries:
            result.append(m.index(x))  # get the index of the q
            m.remove(x) # remove the element from that index
            m.insert(0, x) # inser the element at the start
        
        return result
--


=============================================================================================================================


-- Html entity parser


-- https://leetcode.com/problems/html-entity-parser/
--


--
class Solution:
    def entityParser(self, text: str) -> str:
        m = {
            '&quot;': '"',
            '&apos;': '\'',
            '&amp;': '&',
            '&gt;': '>',
            '&lt;': '<',
            '&frasl;': '/'
        }

        # minlen = 6, maxlen = 4


        def checker(start):
            # Try to find the longest possible entity from the current position
            for length in range(4, 8):  # Entities have lengths between 4 and 6
                candidate = text[start:start + length]
                if candidate in m:
                    return m[candidate], length  # Return the entity replacement and its length
            return False, 1


        n = len(text)
        i = 0
        res = ""
        while i < n:

            if text[i] != "&":
                res += text[i]
                i += 1
            else:
                found, length = checker(i)
                if found:
                    res += found
                    i += length
                else:
                    res += text[i]
                    i += 1
        return res


        
--

============================================================================================================================


-- Find the minimum number of fibonacci whose sum is k



--
-- https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/submissions/1409497619/


--
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        
        # the idea here is to subtract from the largest fib from the end of the array

        fib = [1, 1]

        while fib[-1] <= k:
            fib.append(fib[-1] + fib[-2])
        
        index = len(fib) - 1
        cnt = 0

        while k > 0:
            if fib[index] <= k:
                k -= fib[index]
                cnt += 1
            index -= 1
        
        return cnt 



        
--


===========================================================================================================================


-- Four divisors


-- https://leetcode.com/problems/four-divisors/
--


--
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:

        def divisors(num):
            div = set()

            for i in range(1, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    div.add(i)
                    div.add(num // i)
            if len(div) == 4:
                
                return sum(div)
            return False
        
        n = len(nums)
        cnt = 0

        for i in range(n):
            c = divisors(nums[i])
            if c:
                cnt += c
        
        return cnt
--

======================================================================================================================================


-- Check if there is a Valid path in a grid


--
-- https://leetcode.com/problems/minimum-number-of-frogs-croaking/submissions/1409685642/


--
class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        c = r = o = a = k = 0
        frogs = 0 
        max_frogs = 0 

        for char in croakOfFrogs:
            if char == 'c':
                c += 1
                frogs += 1  # A new frog starts croaking
                max_frogs = max(max_frogs, frogs)  # Update maximum active frogs
            elif char == 'r':
                r += 1
                if r > c:
                    return -1  # More 'r' than 'c', invalid sequence
            elif char == 'o':
                o += 1
                if o > r:
                    return -1  # More 'o' than 'r', invalid sequence
            elif char == 'a':
                a += 1
                if a > o:
                    return -1  # More 'a' than 'o', invalid sequence
            elif char == 'k':
                k += 1
                if k > a:
                    return -1  # More 'k' than 'a', invalid sequence
                frogs -= 1 

        # After processing, all counts should be equal
        if c == r == o == a == k:
            return max_frogs
        else:
            return -1 
--


============================================================================================================================

-- Diagonal traversal



-- https://leetcode.com/problems/diagonal-traverse-ii/
--


--
from collections import defaultdict

class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        diagonals = defaultdict(list)
        
        m, n = len(nums), len(nums[0])
        
        # Step 1: Group elements by diagonals and push into heaps
        # for the diagonals the i + j has the same slope for diagonal elements
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                diagonals[i + j].append(nums[i][j])

        res = []
        # Step 2: Append elements in the order of diagonals
        for k in sorted(diagonals.keys()):
            res.extend(reversed(diagonals[k]))  # Reversed to maintain the correct diagonal order

        return res
--


===============================================================================================================================


-- Max diff you can get from changing an integer


-- https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/submissions/1410678378/
--


--
class Solution:
    def maxDiff(self, num: int) -> int:
        num_str = str(num)

        max_a = num_str
        for i in num_str:
            if i != "9":
                max_a = num_str.replace(i, "9")
                break
        
        max_a = int(max_a)


        min_b = num_str
        if min_b[0] != "1":
            min_b = min_b.replace(min_b[0], "1")
        else:
            for i in num_str[1:]:
                if i != "0" and i != "1":
                    min_b = num_str.replace(i, "0")
                    break
        min_b = int(min_b)
        return max_a - min_b

--


=============================================================================================================================


-- Check if a string can break another string


--
--


--
class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        count1 = [0] * 26
        count2 = [0] * 26
        
        for c in s1:
            count1[ord(c) - ord('a')] += 1
        for c in s2:
            count2[ord(c) - ord('a')] += 1
        
        s1_breaks_s2 = True
        s2_breaks_s1 = True
        
        cumulative_s1 = 0
        cumulative_s2 = 0
        
	# if the cumulative is less than the other it wont break the other
        for i in range(26):
            cumulative_s1 += count1[i]
            cumulative_s2 += count2[i]
            
            if cumulative_s1 < cumulative_s2:
                s1_breaks_s2 = False
            if cumulative_s2 < cumulative_s1:
                s2_breaks_s1 = False
        
        return s1_breaks_s2 or s2_breaks_s1

--


==============================================================================================================================

-- Check if a there is a valid path in agrid


--
--


--
from collections import deque

class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0])
        directions = {
            # in that [1, 4, 6] in the left the number can be 1, 4, 6
            1: [(0, -1, [1, 4, 6]), (0, 1, [1, 3, 5])], # in an array have two directions mentioned left and right ones
            2: [(-1, 0, [2, 3, 4]), (1, 0, [2, 5, 6])],  # Up, Down
            3: [(0, -1, [1, 4, 6]), (1, 0, [2, 5, 6])],  # Left, Down
            4: [(0, 1, [1, 3, 5]), (1, 0, [2, 5, 6])],   # Right, Down
            5: [(0, -1, [1, 4, 6]), (-1, 0, [2, 3, 4])], # Left, Up
            6: [(0, 1, [1, 3, 5]), (-1, 0, [2, 3, 4])]   # Right, Up
        }

        q = deque([(0, 0)])
        visited = set()
        visited.add((0, 0))

        while q:
            x, y = q.popleft()
            
            if x == m - 1 and y == n - 1:
                return True

            # in this going both sides
            for a, b, valid_types in directions[grid[x][y]]:
                nx = x + a
                ny = y + b

                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                    if grid[nx][ny] in valid_types:
                        q.append((nx, ny))
                        visited.add((nx, ny))

        
        return False

--


===============================================================================================================================


-- Circle and rectangle overlapping



-- https://leetcode.com/problems/circle-and-rectangle-overlapping/
--


--
class Solution:
    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        nearest_x = max(x1, min(x2, xCenter))
        nearest_y = max(y1, min(y2, yCenter))

        # Use Euclidean formula to get the Euclidean dist between circle and rectangle

        disx = nearest_x - xCenter
        disy = nearest_y - yCenter

        return disx ** 2 + disy ** 2 <= radius ** 2
--


===============================================================================================================================

-- The kth lexicographical string of all strings
of length k



-- https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/submissions/1411165093/
--


--
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        string = "abc"
        cnt = [0]
        res = []

        def backtrack(current, n):
            if len(current) == n:
                cnt[0] += 1
                if cnt[0] == k:
                    res.append(current)
                return
            
            for i in 'abc':
                if not current or current[-1] != i:
                    backtrack(current + i, n)
                
                    if res:
                        return
        
        backtrack("", n)
    
        # If we found the k-th happy string, return it, otherwise return an empty string
        return res[0] if res else ""



        
--

================================================================================================================================


-- Display table of food orders in a restaurant


-- https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/submissions/1411790865/
--


--
from typing import List

class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = []

        pre = [0] * n
        suf = [0] * n
        pre[0] = nums[0]
        suf[n - 1] = nums[n - 1]

        for i in range(1, n):
            pre[i] = pre[i - 1] + nums[i]

        for i in range(n - 2, -1, -1):
            suf[i] = suf[i + 1] + nums[i]

        for i in range(n):
            temp = (i + 1) * nums[i] - pre[i]
            temp += (suf[i] - (n - i) * nums[i])
            ans.append(temp)

        return ans

--


================================================================================================================================


-- Longest Continuous subarray with absolute diff less than or equal to limit (Neetcode) (Imp)


-- https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
--


--
from collections import defaultdict
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        # using monotonic queue to get the solution
        # Use 2 queues, max queue and min queue

        min_queue = deque() # monotonically increasing
        max_queue = deque() # monotonically decrease
        n = len(nums)

        left = 0
        right = 0
        res = 0

        for right in range(n):
            while min_queue and nums[right] < min_queue[-1]:
                min_queue.pop()

            while max_queue and nums[right] > max_queue[-1]:
                max_queue.pop()

            max_queue.append(nums[right])
            min_queue.append(nums[right])

            while max_queue[0] - min_queue[0] > limit:
                if nums[left] == max_queue[0]:
                    max_queue.popleft()
                if nums[left] == min_queue[0]:
                    min_queue.popleft()
                left += 1
            
            res = max(res, right - left + 1)
    
        return res
--


=============================================================================================================================


-- Build an array with stack


--
--


--
class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        stack = []
        current = 1

        for num in target:

            while current < num:
                stack.append("Push")
                stack.append("Pop")
                current += 1
            
            stack.append("Push")
            current += 1
        
        return stack
--

===============================================================================================================================

-- Simplified fractions



-- https://leetcode.com/problems/simplified-fractions/
--


--
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []

        res = set()
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                if j / i in res:
                    continue
                
                temp = str(j) + '/' + str(i)
                ans.append(temp)
                res.add(j / i)  # Add the fraction tuple to the set
        return ans
--


--
from math import gcd
from typing import List

class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []
        
        ans = []
        
        for i in range(2, n + 1):
            for j in range(1, i):
                # Check if the fraction is in its simplest form using GCD
                if gcd(j, i) == 1:
                    ans.append(f"{j}/{i}")
        
        return ans

--


============================================================================================================================



-- Count good nodes in binary tree


-- https://leetcode.com/problems/count-good-nodes-in-binary-tree/
--

--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:

        res = []

        def dfs(node, maximum):
            if not node:
                return 
            
            if node.val >= maximum:
                res.append(node.val)
            
            dfs(node.left, max(node.val, maximum))
            dfs(node.right, max(node.val, maximum))

            return maximum

        dfs(root, root.val)
        return len(res)
      
--

============================================================================================================================


-- People whose list of favorite companies is not a subset of another list


-- https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
--


--
class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        result = []

        favoriteSets = [set(arr) for arr in favoriteCompanies]   

        for i in range(len(favoriteSets)):
            isSubset = False
            for j in range(len(favoriteSets)):
                if i != j and favoriteSets[i].issubset(favoriteSets[j]):
                    isSubset = True
                    break
            if not isSubset:
                result.append(i)
        
        return sorted(result)     
--


================================================================================================================================

--  Count triplets that can form two arrays of equal xor


--
-- https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/


--
class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        n = len(arr)
        prefixXor = 0
        count = 0
        freq = {0: 1}
        total = {0: 0}
        
        for i in range(n):
            prefixXor ^= arr[i]
            
            if prefixXor in freq:
                count += freq[prefixXor] * i - total[prefixXor]
            
            freq[prefixXor] = freq.get(prefixXor, 0) + 1
            total[prefixXor] = total.get(prefixXor, 0) + i + 1
        
        return count
--


=======================================================================================================================================

-- Maximum number of vowels ina  substring


-- https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
--


--
from collections import defaultdict

class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        cnt = 0
        left = 0
        right = 0
        n = len(s)
        ans = 0

        while right < n:
            if s[right] in "aeiou":
                cnt += 1

            if right - left + 1 < k:
                right += 1

            elif right - left + 1 == k:
                ans = max(ans, cnt)
                
                if s[left] in "aeiou":
                    cnt -= 1

                left += 1
                right += 1

        return ans

--


=========================================================================================================================


-- Check if a string contains all binary codes of size k


-- https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/
--

-
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        unique_substrings = set()
        n = len(s)
        
        for i in range(n - k + 1):
            substring = s[i:i + k]
            unique_substrings.add(substring)
        
        total_binary_codes = 2 ** k
        
        # you can also check that if the len of unique substrings equal to total binary codes
        return len(unique_substrings) == total_binary_codes

-

=============================================================================================================================

-- Pseudo palindromic path in a binary tree


--
-- https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/


--
# Definition for a binary tree node.
# class TreeNode:k
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node:
                return 0
            
            path ^= (1 << node.val)
            
            if not node.left and not node.right:
                if path & (path - 1) == 0:
                    return 1
                else:
                    return 0
            
            return dfs(node.left, path) + dfs(node.right, path)
        
        return dfs(root, 0)
        
--


========================================================================================================================


-- Course schedule IV (Imp)


-- https://leetcode.com/problems/course-schedule-iv/
--


--
from collections import defaultdict, deque
from typing import List

class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        # Create a graph and indegree array
        g = defaultdict(list)
        indegree = [0] * numCourses

        # Build the graph and indegree array
        for u, v in prerequisites:
            g[u].append(v)
            indegree[v] += 1

        # Initialize the queue for topological sorting
        q = deque()
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)

        # Reachable nodes tracking
        reachable_array = defaultdict(set)

        topo_order = []
        # Perform topological sorting
        while q:
            temp = q.popleft()  # use popleft for O(1) complexity
            topo_order.append(temp)
            for node in g[temp]:
                indegree[node] -= 1
                if indegree[node] == 0:
                    q.append(node)

        # Propagate reachable nodes
        for course in topo_order:
            for neighbor in g[course]:
                reachable_array[neighbor].add(course)
                reachable_array[neighbor].update(reachable_array[course])

        # Check each query
        result = []
        for u, v in queries:
            result.append(u in reachable_array[v])

        #   reachable_array = {
        #       1: {0},        # Course 1 can be reached by course 0
        #       2: {0, 1},     # Course 2 can be reached by courses 0, 1
        #       3: {0, 1, 2},  # Course 3 can be reached by courses 0, 1, 2     
        #   }

        return result


--


============================================================================================================================


-- Maximum area of a piece of cake after horizontal and vertical cuts



-- https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/submissions/1412723062/
--


--
class Solution:
    def maxArea(self, h: int, w: int, hr: List[int], vr: List[int]) -> int:
        hr.sort()
        vr.sort()


        max_hr = max(hr[0], h - hr[-1]) # from the edges to first and last cit
        for i in range(1, len(hr)):
            max_hr = max(max_hr, hr[i] - hr[i - 1])
        
        max_vr = max(vr[0], w - vr[-1])
        for j in range(1, len(vr)):
            max_vr = max(max_vr, vr[j] - vr[j - 1])

        MOD = 10**9 + 7
        return (max_vr * max_hr) % MOD
      
--

===========================================================================================================================

-- Removing stars from a string


-- https://leetcode.com/problems/removing-stars-from-a-string/
--


--
class Solution:
    def removeStars(self, s: str) -> str:

        stack = []

        for i in range(len(s)):
            if s[i] == "*" and stack:
                stack.pop()
            elif s[i] != "*":
                stack.append(s[i])
        
        return "".join(stack)
--


===============================================================================================================================


-- Optimal partition of string


-- https://leetcode.com/problems/optimal-partition-of-string/
--


--
from collections import defaultdict
class Solution:
    def partitionString(self, s: str) -> int:
        cnt = 0
        m = {}

        for i in range(len(s)):
            if s[i] in m:
                cnt += 1
                m = {}
            m[s[i]] = m.get(s[i], 0) + 1
        
        return cnt + 1
--


=============================================================================================================================
