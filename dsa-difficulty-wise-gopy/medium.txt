
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- 