
Dota2 senate

-- https://leetcode.com/problems/dota2-senate/
--


--
from collections import deque
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant = deque()
        dire = deque()

        # Once the senator casts an vote just eliminate the other team member and push back to the queue at the end
        
        # Fill the queues with the indices of the senators
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        n = len(senate)
        
        while radiant and dire:
            r_index = radiant.popleft()
            d_index = dire.popleft()
            
            if r_index < d_index:
                # Radiant senator bans Dire senator
                radiant.append(r_index + n)
            else:
                # Dire senator bans Radiant senator
                dire.append(d_index + n)
        
        return "Radiant" if radiant else "Dire"
        
--


=========================================================================================


-- Minimum ascoo delete sum for two strings


--
-- https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/


--
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
    
        # DP table initialization
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Base cases: sum of ASCII values when one of the strings is empty
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] + ord(s1[i-1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] + ord(s2[j-1])
        
        # Fill the DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # ascii value for all the characters
                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
        
        return dp[m][n]
--


===============================================================================================


-- Subarray product less than k


-- https://leetcode.com/problems/subarray-product-less-than-k/
--


-- (right - left + 1) gives u the total subarray from left to right
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        product = 1
        left = 0
        count = 0
        
        for right in range(len(nums)):
            product *= nums[right]
            
            while product >= k and left <= right:
                product //= nums[left]
                left += 1
            
            count += right - left + 1
        
        return count
--


==========================================================================================================

-- Maximum length of repeated subarray


-- https://leetcode.com/problems/maximum-length-of-repeated-subarray/submissions/1399892864/
--


--
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)
        n2 = len(nums2)
        dp = [[0 for i in range(n2 + 1)] for _ in range(n1 + 1)]
        max_len = 0

        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
        
        return max_len
--


==============================================================================================================


-- Longest word in dictionary

 
-- https://leetcode.com/problems/longest-word-in-dictionary/
--

--
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
    
        # Set to store valid prefixes
        valid_words = set([""])  # Start with an empty string as a valid prefix
        result = ""
        
        for word in words:
            # Check if the prefix (word[:-1]) exists in the valid_words set
            if word[:-1] in valid_words:
                valid_words.add(word)  # Add the word to the set
                # Update result if the current word is longer or lexicographically smaller
                if len(word) > len(result):
                    result = word
        
        return result
--


========================================================================================================


-- Accounts merge


-- https://leetcode.com/problems/accounts-merge/submissions/1400878057/
--

--
from collections import defaultdict

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        g = defaultdict(list)

        for i, account in enumerate(accounts):
            for j in range(1, len(account)):

                email = account[j]
                g[email].append(i) # storing the index for the email 


        vis = [False] * len(accounts)


        def dfs(index, emails):
            if vis[index] == True:
                return
            vis[index] = True
            
            for j in range(1, len(accounts[index])):
                email = accounts[index][j]
                emails.add(email)
                for neighbor in g[email]:
                    if not vis[neighbor]:
                        dfs(neighbor, emails)



        res = []
        for i, account in enumerate(accounts):
            if not vis[i]:
                name = account[0]
                emails = set()
                dfs(i, emails)
                res.append([name] + sorted(emails))
        
        return res

        
--


===============================================================================================================


--  Remove comments


--
--


--
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:

        res = []
        n = len(source)
        block_comment = False

        new_line = ""
        
        for char_arr in source:
            i = 0

            if not block_comment:
                new_line = ""

            while i < len(char_arr):

                if not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '*':
                    block_comment = True
                    i = i + 2
                
                elif block_comment and i + 1 < len(char_arr) and char_arr[i] == '*' and char_arr[i + 1] == '/':
                    block_comment = False
                    i = i + 2

                elif not block_comment and i + 1 < len(char_arr) and char_arr[i] == '/' and char_arr[i + 1] == '/':
                    break
                
                elif not block_comment:
                    new_line += char_arr[i]
                    i = i + 1

                # if the block_comment is True
                else:
                    i += 1
                
            if not block_comment and new_line:
                res.append(new_line)
            
        
        return res
        return "".join(res)            
--


===================================================================================================================

-- Split Linked list in Parts


--
-- https://leetcode.com/problems/split-linked-list-in-parts/


--
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        total_nodes = 0
        current = head
        while current:
            total_nodes += 1
            current = current.next
        
        # Step 2: Calculate the base size of each part and the extra nodes
        base_size = total_nodes // k
        extra_nodes = total_nodes % k
        
        # Step 3: Split the list
        parts = []
        current = head
        for i in range(k):
            part_size = base_size + (1 if i < extra_nodes else 0)  # Calculate the size of the current part
            if part_size == 0:
                parts.append(None)  # If the part size is 0, append None
            else:
                part_head = current
                for j in range(part_size - 1):
                    if current:
                        current = current.next
                next_part = None
                if current:
                    next_part = current.next
                    current.next = None  # Break the list

                parts.append(part_head) # important code which is used to get the list in linked lists to array
                current = next_part  # Move to the next part
        
        return parts
--


==============================================================================================================================


-- My Calender I


--
-- https://leetcode.com/problems/my-calendar-i/


--
class MyCalendar:
    def __init__(self):
        # Initialize an empty list to store the events
        self.events = []

    def book(self, start: int, end: int) -> bool:
        # Iterate over the list of events
        for event_start, event_end in self.events:
            # Check if the new event overlaps with an existing event
            if not (end <= event_start or start >= event_end):
                # If there is an overlap, return False (booking fails)
                return False
        # If no overlap is found, add the event to the calendar
        self.events.append((start, end))
        # Return True indicating successful booking
        return True

--


===================================================================================================================


-- NUMBER OF BURGERS with no waste of ingrediants


-- https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/solutions/4840518/easy-beginner-friendly-solution-in-cpp-0ms-beats-100-0-1-solution/
--


--class Solution:
    def numOfBurgers(self, to: int, ch: int) -> List[int]:

        if ch > to:
            return []
        else:
            if (to > ch * 4) and (to < ch * 2):
                return []
            else:
                if to % 2 == 0:
                    x = to - (2 * ch)
                    y = x // 2
                    z = ch - y
                    return [y, z]
                
                else:
                    return []
--


=======================================================================================================================


-- Count the servers that communicate


-- https://leetcode.com/problems/count-servers-that-communicate/
--


--
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        row = [0] * m
        col = [0] * n

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    row[i] += 1
                    col[j] += 1
        
        res = 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] and (row[i] > 1 or col[j] > 1):
                    res += 1
        
        return res
        
--

==============================================================================================================================


-- Search Suggestions


-- https://leetcode.com/problems/search-suggestions-system/
--

--class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()

        prefix = ""
        res = []

        for i in searchWord:
            prefix += i
            suggestions = []

            for j in range(len(products)):
                if products[j].startswith(prefix):
                    suggestions.append(products[j])
                    if len(suggestions) == 3:
                        break
            
            res.append(suggestions)
        
        return res
--

====================================================================================================================


-- Count squares submatrices with all ones


-- https://leetcode.com/problems/count-square-submatrices-with-all-ones/submissions/
--

-
class Solution:
    def countSquares(self, mp: List[List[int]]) -> int:
        m = len(mp)
        n = len(mp[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        total_squares = 0

        for i in range(m):
            for j in range(n):

                if mp[i][j] == 1:
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                total_squares += dp[i][j]
        
        return total_squares
-


=============================================================================================================================


-- Group the people given the group size


-- https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
--


--
from collections import defaultdict

class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        m = defaultdict(list)

        for i, num in enumerate(gs):
            m[num].append(i)

        res = []
        for group_size, people in m.items():
            for i in range(0, len(people), group_size):
                res.append(people[i: i + group_size])

        return res

--


==========================================================================================================================

-- Find the smallest divisor given a threshold


-- https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
--

--
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left = 1  # Smallest divisor should start from 1
        right = max(nums)  # Largest possible divisor can be the maximum element in the array

        def check(num):
            csum = 0
            for i in nums:
                csum += ceil(i / num)  # Use ceil to simulate rounding up the division result
            return csum

        ans = float("inf")
        while left <= right:
            mid = (left + right) // 2

            if check(mid) > threshold:
                left = mid + 1
            else:
                ans = min(ans, mid)
                right = mid - 1
        
        return ans
--


============================================================================================================================

-- Remove covered intervals


-- https://leetcode.com/problems/remove-covered-intervals/
--


--
class Solution:
    def removeCoveredIntervals(self, inter: List[List[int]]) -> int:
        cnt = 0
        inter.sort(key=lambda x:(x[0], -x[1]))

        ending_time = 0

        for i in range(len(inter)):
            if ending_time < inter[i][1]:
                cnt += 1
                ending_time = inter[i][1]

        return cnt
--


==========================================================================================================================


-- Sequential digits


-- https://leetcode.com/problems/sequential-digits/
--



--
class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:

        num = "123456789"
        res = []

        for length in range(2, 10):
            for start in range(0, 10 - length): # the range is from 0 to 10 - length because the we will be adding length
                number = int(num[start: start + length])

                if low <= number <= high:
                    res.append(number)
        return sorted(res)
--

=======================================================================================================================


-- Maximum Side Length of a Square with Sum Less than or Equal to Threshold


-- https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/1404694299/
--


--
from typing import List

class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])

        # Initialize prefix sum matrix
        prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        # Build prefix sum matrix
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = mat[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

        # This function gets the sum of the square from (i, j) to (i + k - 1, j + k - 1)
        def get_sum(i, j, k):
            return prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]

        left = 0
        right = min(m, n)
        ans = 0

        # Binary search for the maximum possible square length
        while left <= right:
            mid = (left + right) // 2
            found = False

            # Check for any valid square of side length 'mid'
            for i in range(m - mid + 1):
                for j in range(n - mid + 1):
                    if get_sum(i, j, mid) <= threshold:
                        found = True
                        break
                if found:
                    break

            if found:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1

        return ans

--

=============================================================================================================================

-- Divide Array in Sets of K consecutive numbers

  
-- https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/submissions/1404733179/
--


--
from collections import defaultdict

class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        nums.sort()
        m = defaultdict(int)

        for i in nums:
            m[i] += 1

        for num in nums:
            if m[num] > 0:
                for j in range(num, num + k):
                    if m[j] == 0:
                        return False
                    m[j] -= 1

        return True
--


=================================================================================================================================

-- Maximum Number of Occurances of a substring


-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/
-- https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/1404853330/


--
from collections import defaultdict
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        string_count = defaultdict(int)
        ans = 0
        for i in range(len(s) - minSize + 1):
            string = s[i : i + minSize]
            unique_string = set(string)
            
            # since the length is used you can use length to get the maximum unique letters
            if len(unique_string) <= maxLetters:
                string_count[string] += 1
                ans = max(ans, string_count[string])

        return ans
--



===============================================================================================================================

-- Sum of Mutated Array Closest to Target


-
- https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/description/

--
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:        
        
        arr.sort()

        prefix_sum = [0]
        for num in arr:
            prefix_sum.append(prefix_sum[-1] + num)

        def helper(arr, value):
            left, right = 0, len(arr) - 1

            while left <= right:
                mid = (left + right)// 2

                if arr[mid] > value:
                    right = mid - 1
                else:
                    left = mid + 1
                
            return left


        left = 0
        right = max(arr)
        closest_sum_diff = float('inf')
        best_value = right

        while left <= right:
            mid = (left + right) // 2

            index = helper(arr, mid)

            # get the total sum after replacing the number with the mid
            curr_sum = prefix_sum[index] + (len(arr) - index) * mid
            diff = abs(curr_sum - target)

            if diff < closest_sum_diff or (diff == closest_sum_diff and mid < best_value):
                best_value = mid
                closest_sum_diff = diff
            
            if curr_sum < target:
                left = mid + 1
            else:
                right = mid - 1

        
        return best_value
--

===============================================================================================================================

-- Deepest leaves sum


-- https://leetcode.com/problems/deepest-leaves-sum/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:

        # returning the array with depth and the node
        def dfs(node, depth):
            if not node:
                return (0, 0)

            if not node.left and not node.right:
                return (node.val, depth)
            
            left = dfs(node.left, depth + 1)
            right = dfs(node.right, depth + 1)

            if left[1] > right[1]:
                return left
            elif right[1] > left[1]:
                return right
            else:
                return (left[0] + right[0], left[1])
        
        return dfs(root, 0)[0]
--


=============================================================================================================================


-- all elements in two binary search trees


-- https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
--


--
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def dfs(node, arr):
            if not node:
                return None

            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)

            return arr
        
        arr1, arr2 = [], []
        arr1 = dfs(root1, arr1) if root1 else []
        arr2 = dfs(root2, arr2) if root2 else []

        i = 0
        j = 0
        ans = []
        n = len(arr1)
        m = len(arr2)

        while i < n and j < m:
            if arr1[i] <= arr2[j]:
                ans.append(arr1[i])
                i += 1
            else:
                ans.append(arr2[j])
                j += 1
        
        ans.extend(arr1[i:])
        ans.extend(arr2[j:])
        
        return ans
        
            
        
--


==========================================================================================================================

-- Jump game 3


-- https://leetcode.com/problems/jump-game-iii/submissions/1405149002/
--


--
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        # Using queue and BFS to get the solution since you can jump to i - arr[i] or i - arr[i]


        q = []
        q.append(start)
        vis = [0] * len(arr)
        n = len(arr)

        while q:

            index = q.pop(0)

            vis[index] = 1
 
            if arr[index] == 0:
                return True

            left = index - arr[index]

            if left >= 0 and not vis[left]:
                q.append(left)
            
            right = index + arr[index]
            if right < n and not vis[right]:
                q.append(right)
        
        return False
--


==============================================================================================================================


-- Xor queries of a subarrya


-- https://leetcode.com/problems/xor-queries-of-a-subarray/
--

--
class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:

        prefix = [0] * (len(arr) + 1)

        for i in range(1, len(arr) + 1):
            prefix[i] = prefix[i - 1] ^ arr[i - 1]

        result = []
        for left, right in queries:
            result.append(prefix[left] ^ prefix[right + 1])
        
        return result
        
--


============================================================================================================================