

check for Pallindrome

-- 
--

--
import (
    "fmt"
    "strconv"
)

func isPalindrome(x int) bool {
    str := strconv.Itoa(x)

    for i:= 0; i < len(str) / 2; i++ {
        if str[i] != str[len(str)-i-1] {
			return false
		}
    }

    return true
}

--


========================================================================================================

-- Convert 1d array to 2d


-- https://leetcode.com/problems/convert-1d-array-into-2d-array/?envType=daily-question&envId=2024-09-01
--


--
class Solution:
    def construct2DArray(self, arr: List[int], m: int, n: int) -> List[List[int]]:
        if m * n != len(arr):
            return []

        res = []
        index = 0

        for i in range(m):
            col = []
            for j in range(n):
                col.append(arr[index])
                index += 1
            res.append(col)
        return res     
--


=================================================================================================================


-- Symmetric binary tree


-- https://leetcode.com/problems/symmetric-tree/submissions/1376558768/
--


--
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(left, right):
            if not left and not right:
                return True

            if not left or not right:
                return False
            
            if left.val != right.val:
                return False
            
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        
        return dfs(root.left, root.right)
--

-- Go code

--
func dfs(left *TreeNode, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }

    if left == nil || right == nil {
        return false
    }

    if left.Val != right.Val {
        return false
    }

    return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)
}
func isSymmetric(root *TreeNode) bool {
    return dfs(root.Left, root.Right)
}
--


==========================================================================================================================

-- Maximum depth of the binary tree


--
-- https://leetcode.com/problems/maximum-depth-of-binary-tree/

--
func dfs(node *TreeNode) int {
    if node == nil {
        return 0
    }

    left := dfs(node.Left)
    right := dfs(node.Right)

    return max(left, right) + 1
}

func maxDepth(root *TreeNode) int {

    return dfs(root)
}
--

==========================================================================================================================

-- Longest common prefix 


-- https://leetcode.com/problems/longest-common-prefix/submissions/1379023169/
--


--
func longestCommonPrefix(strs []string) string {

    res := ""

    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return res
            }
        } 
        res += string(strs[0][i])
    }

    return res

}
--


===================================================================================================================================


-- Climbing stairs


-- https://leetcode.com/problems/climbing-stairs/
--


-
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }

    dp := make([]int, n + 1)
    dp[0] = 1
    dp[1] = 1

    for i := 2; i < n + 1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
-


============================================================================================================================================

-- Happy Number


-- https://leetcode.com/problems/happy-number/
--

-- The concept is the non happy number will always be repeated after words

--
func sqaure(n int) int {
    sqaure := 0

    for n != 0 {
        temp := n % 10
        sqaure += temp * temp
        n /= 10
    }

    return sqaure
}

func isHappy(n int) bool {
    slow := n
    fast := n


    for  {
        slow = sqaure(slow)
        fast = sqaure(sqaure(fast))

        if slow == fast {
            break
        }
    }

    return slow == 1
}
--


===================================================================================================

-- Clear digits


-- https://leetcode.com/problems/clear-digits/submissions/1380780060/
--


--

// IsDigit checks if a character is a digit.
func IsDigit(a rune) bool {
	return unicode.IsDigit(a)
}

// clearDigits removes digits and the adjacent character from the string.
func clearDigits(s string) string {
	runes := []rune(s) // Convert the string to a slice of runes to handle Unicode characters
	for i := 0; i < len(runes); i++ {
		if IsDigit(runes[i]) {
			if i != 0 {
				// Remove the character before the digit and the digit itself
				runes = append(runes[:i-1], runes[i+1:]...)
				i -= 2 // Adjust the index to handle the new length
			} else {
				// Remove the first character and the digit
				runes = runes[2:]
				i-- // Adjust the index
			}
		}
	}
	return string(runes)
}
--

==========================================================================================================


-- Find the child who has the ball after k seconds


-- https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/submissions/1380793962/
--


--
func numberOfChild(n int, k int) int {
    p := 0
    i := 0

    for k != 0 {
        if i == 0 {
            p = 1
        }
        if i == n - 1 {
            p = -1
        }

        i += p
        k -= 1
    }
    return i
}
--


=========================================================================================================

-- Count the pairs that form a complete day


-- https://leetcode.com/problems/count-pairs-that-form-a-complete-day-i/
--


--
func countCompleteDayPairs(hours []int) int{
	// Create a map to store the frequency of remainders
	remainderFreq := make(map[int]int)
	pairs := 0

	for _, hour := range hours {
		// Find the remainder when divided by 24
		rem := hour % 24
		
		// Calculate the complement remainder
		complement := (24 - rem) % 24
		
		// If the complement remainder exists in the map, it means we found a valid pair
		if count, exists := remainderFreq[complement]; exists {
			pairs += count
		}
		
		// Increment the frequency of the current remainder
		remainderFreq[rem]++
	}

	return pairs
}
--


================================================================================================================

-- Minimum time visiting all points


-- https://leetcode.com/problems/minimum-time-visiting-all-points/
--


--
import (
	"fmt"
	"math"
)

func minTimeToVisitAllPoints(points [][]int) int {
	time := 0

	for i := 1; i < len(points); i++ {
		prev := points[i-1]
		curr := points[i]

		// Calculate the absolute difference between x and y coordinates
		first := math.Abs(float64(prev[0] - curr[0]))
		second := math.Abs(float64(prev[1] - curr[1]))

		// Add the maximum of the two differences to the time
		time += int(math.Max(first, second))
	}

	return time
}


--

===============================================================================================================


-- Shft 2d grid


-- https://leetcode.com/problems/shift-2d-grid/
--


--
func shiftGrid(grid [][]int, k int) [][]int {
    m, n := len(grid), len(grid[0])
    totalElements := m * n
    k = k % totalElements // Reduce unnecessary full rotations

    // Flatten the 2D grid into a 1D array
    flat := make([]int, totalElements)
    idx := 0
    for _, row := range grid {
        for _, val := range row {
            flat[idx] = val
            idx++
        }
    }

    // Shift the flat array
    shifted := make([]int, totalElements)
    for i, val := range flat {
        shifted[(i+k)%totalElements] = val
    }

    // Convert the shifted 1D array back into a 2D grid
    result := make([][]int, m)
    for i := range result {
        result[i] = make([]int, n)
        for j := range result[i] {
            result[i][j] = shifted[i*n+j]
        }
    }

    return result
}
--

===================================================================================================

-- Cells with odd values in a matrix


-- https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/submissions/1381645907/
--


--
func oddCells(m int, n int, indices [][]int) int {
    // Create a 2D slice with size m x n
    res := make([][]int, m)
    for i := range res {
        res[i] = make([]int, n)
    }

    // Apply the operations for each index pair in indices
    for _, el := range indices {
        r := el[0]
        c := el[1]

        // Increment all elements in the r-th row
        for i := 0; i < n; i++ {
            res[r][i] += 1
        }

        // Increment all elements in the c-th column
        for j := 0; j < m; j++ {
            res[j][c] += 1
        }
    }

    cnt := 0
    // Count the number of odd cells
    for _, row := range res {
        for _, el := range row {
            if el%2 == 1 {
                cnt++
            }
        }
    }

    return cnt
}

--


========================================================================================================


-- Check if it is a straight line


-- https://leetcode.com/problems/check-if-it-is-a-straight-line/
--


--
func checkStraightLine(coordinates [][]int) bool {
    x1 := coordinates[0][0]
    x2 := coordinates[1][0]
    y1 := coordinates[0][1]
    y2 := coordinates[1][1]

    for i:= 2; i < len(coordinates); i++ {
        x := coordinates[i][0]
        y := coordinates[i][1]

        if (x - x2)*(y - y1) != (y - y2)*(x - x1) {
            return false
        }
    }
    return true

}
--

======================================================================================================

-- Subtract the product and sum of the digits of an integer


-- https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/submissions/1381753084/
--


--
func subtractProductAndSum(n int) int {
    product := 1
    sumarry := 0

    for n != 0 {
        temp := n % 10
        
        product *= temp

        sumarry += temp
        n /= 10
    }
    return product - sumarry
}
--


========================================================================================================


-- Element appearing more than 25 in sorted array


-- https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/
--


--
func findSpecialInteger(arr []int) int {
    n := len(arr)
    if n == 0 {
        return -1 // Handle the case when the array is empty
    }

    m := make(map[int]int)
    maximumElement := 0
    maxCount := 0

    for _, val := range arr {
        m[val]++
        if m[val] > maxCount {
            maxCount = m[val]
            maximumElement = val
        }
    }

    if maxCount > n/4 {
        return maximumElement
    }

    return -1 // Return -1 if no element appears more than 25% of the time
}
--

=========================================================================================================


-- Convert the binary number in a linked list to a integer


-- https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/
--

--
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

func binarytodecimal(binary string) int {
    decimal := 0
    n := len(binary)
    for i:= 0; i < n; i++ {
        // Convert the current binary character to an integer (0 or 1)
        bit, _ := strconv.Atoi(string(binary[i]))
        
        // Calculate the base-10 equivalent
        decimal += bit * (1 << (n - i - 1))  // 1 << n is equivalent to 2 ** n

    } 
    return decimal
}


func getDecimalValue(head *ListNode) int {
    str := ""
    for head != nil {
        str += strconv.Itoa(head.Val)
        head = head.Next
    }
    return binarytodecimal(str)
}
--

=======================================================================================================


-- Find the numbers with even number of digits


--
-- https://leetcode.com/problems/find-numbers-with-even-number-of-digits/description/


--
func findNumbers(nums []int) int {
    cnt := 0

    for _, val := range nums {
        if len(strconv.Itoa(val)) % 2 == 0 {
            cnt += 1
        }
    }

    return cnt
}
--


===========================================================================================================

-- Replace elements with greatest element on the right side


-- https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/
--


--
func replaceElements(arr []int) []int {
    // Initialize stack with -1, which acts as the greatest element for the last position
    stack := []int{-1}
    n := len(arr)
    res := make([]int, n)

    // Iterate over the array from right to left
    for i := n - 1; i >= 0; i-- {
        // The top of the stack is always the greatest element to the right
        res[i] = stack[len(stack)-1]

        // If the current element is greater than the stack's top, update the stack
        if arr[i] > stack[len(stack)-1] {
            stack = append(stack, arr[i])
        }
    }

    return res
}
--

=======================================================================================================

-- Find the n unique sum up to zero


--
-- https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/


--
func sumZero(n int) []int {
    ans := []int{}  // Initialize the slice

    mid := n / 2
    fmt.Println(mid)
    for i := 0; i < n/ 2; i++ {
        ans = append(ans, mid)
        ans = append(ans, -mid)
        mid -= 1
    }

    if n % 2 == 1 {  // Check if n is odd
        ans = append(ans, 0)
    }
    all_zero := true

    for _, val := range ans {
        if val != 0 {
            all_zero = false
        }
    }
    zeroSlice := []int{0}

    if all_zero {
        return zeroSlice
    }

    return ans
}

--


========================================================================================================

-- Decrypt string from alphavet to integer mapping


-- https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/submissions/1382026983/
--

--
package main

import (
	"fmt"
	"strconv"
)

func freqAlphabets(s string) string {
	res := []byte{}
	n := len(s)
	i := 0

	for i < n {
		if i+2 < n && s[i+2] == '#' {
			// Convert the substring s[i:i+2] to an integer
			temp, _ := strconv.Atoi(s[i : i+2])
			// Append the corresponding alphabet character
			res = append(res, byte(temp+96))
			i += 3
		} else {
			// Convert the single character s[i] to an integer
			temp, _ := strconv.Atoi(string(s[i]))
			// Append the corresponding alphabet character
			res = append(res, byte(temp+96))
			i++
		}
	}

	return string(res)
}
--


--
class Solution(object):
    def freqAlphabets(self, s):
        """
        :type s: str
        :rtype: str
        """

        res = []
        n = len(s)
        i = 0
        while i < n:
            if i + 2 < n and s[i + 2] == "#":
                temp = int(s[i: i+2])

                res.append(chr(temp + 96))
                i += 3
            else:
                temp = int(s[i])
                res.append(chr(temp + 96))
                i += 1

        return "".join(res)        
--

========================================================================================================

-- Decompress run length encoded list

--
-- https://leetcode.com/problems/decompress-run-length-encoded-list/

--
func decompressRLElist(nums []int) []int {
    n := len(nums)

    res := [] int{}

    for i:= 1; i < n; i+=2 {
        count := nums[i - 1]
        num := nums[i]
        for c:= 0; c < count; c++ {
            res = append(res, num)
        }
    }
    return res
}
--


==============================================================================================================

