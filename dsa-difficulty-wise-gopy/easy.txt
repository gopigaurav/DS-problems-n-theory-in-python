

check for Pallindrome

-- 
--

--
import (
    "fmt"
    "strconv"
)

func isPalindrome(x int) bool {
    str := strconv.Itoa(x)

    for i:= 0; i < len(str) / 2; i++ {
        if str[i] != str[len(str)-i-1] {
			return false
		}
    }

    return true
}

--


========================================================================================================

-- Convert 1d array to 2d


-- https://leetcode.com/problems/convert-1d-array-into-2d-array/?envType=daily-question&envId=2024-09-01
--


--
class Solution:
    def construct2DArray(self, arr: List[int], m: int, n: int) -> List[List[int]]:
        if m * n != len(arr):
            return []

        res = []
        index = 0

        for i in range(m):
            col = []
            for j in range(n):
                col.append(arr[index])
                index += 1
            res.append(col)
        return res     
--


=================================================================================================================


-- Symmetric binary tree


-- https://leetcode.com/problems/symmetric-tree/submissions/1376558768/
--


--
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(left, right):
            if not left and not right:
                return True

            if not left or not right:
                return False
            
            if left.val != right.val:
                return False
            
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        
        return dfs(root.left, root.right)
--

-- Go code

--
func dfs(left *TreeNode, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }

    if left == nil || right == nil {
        return false
    }

    if left.Val != right.Val {
        return false
    }

    return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)
}
func isSymmetric(root *TreeNode) bool {
    return dfs(root.Left, root.Right)
}
--


==========================================================================================================================

-- Maximum depth of the binary tree


--
-- https://leetcode.com/problems/maximum-depth-of-binary-tree/

--
func dfs(node *TreeNode) int {
    if node == nil {
        return 0
    }

    left := dfs(node.Left)
    right := dfs(node.Right)

    return max(left, right) + 1
}

func maxDepth(root *TreeNode) int {

    return dfs(root)
}
--

==========================================================================================================================

-- Longest common prefix 


-- https://leetcode.com/problems/longest-common-prefix/submissions/1379023169/
--


--
func longestCommonPrefix(strs []string) string {

    res := ""

    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return res
            }
        } 
        res += string(strs[0][i])
    }

    return res

}
--


===================================================================================================================================


-- Climbing stairs


-- https://leetcode.com/problems/climbing-stairs/
--


-
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }

    dp := make([]int, n + 1)
    dp[0] = 1
    dp[1] = 1

    for i := 2; i < n + 1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
-


============================================================================================================================================