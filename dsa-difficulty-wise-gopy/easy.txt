

check for Pallindrome

-- 
--

--
import (
    "fmt"
    "strconv"
)

func isPalindrome(x int) bool {
    str := strconv.Itoa(x)

    for i:= 0; i < len(str) / 2; i++ {
        if str[i] != str[len(str)-i-1] {
			return false
		}
    }

    return true
}

--


========================================================================================================

-- Convert 1d array to 2d


-- https://leetcode.com/problems/convert-1d-array-into-2d-array/?envType=daily-question&envId=2024-09-01
--


--
class Solution:
    def construct2DArray(self, arr: List[int], m: int, n: int) -> List[List[int]]:
        if m * n != len(arr):
            return []

        res = []
        index = 0

        for i in range(m):
            col = []
            for j in range(n):
                col.append(arr[index])
                index += 1
            res.append(col)
        return res     
--


=================================================================================================================


-- Symmetric binary tree


-- https://leetcode.com/problems/symmetric-tree/submissions/1376558768/
--


--
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(left, right):
            if not left and not right:
                return True

            if not left or not right:
                return False
            
            if left.val != right.val:
                return False
            
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        
        return dfs(root.left, root.right)
--

-- Go code

--
func dfs(left *TreeNode, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }

    if left == nil || right == nil {
        return false
    }

    if left.Val != right.Val {
        return false
    }

    return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)
}
func isSymmetric(root *TreeNode) bool {
    return dfs(root.Left, root.Right)
}
--


==========================================================================================================================

-- Maximum depth of the binary tree


--
-- https://leetcode.com/problems/maximum-depth-of-binary-tree/

--
func dfs(node *TreeNode) int {
    if node == nil {
        return 0
    }

    left := dfs(node.Left)
    right := dfs(node.Right)

    return max(left, right) + 1
}

func maxDepth(root *TreeNode) int {

    return dfs(root)
}
--

==========================================================================================================================

-- Longest common prefix 


-- https://leetcode.com/problems/longest-common-prefix/submissions/1379023169/
--


--
func longestCommonPrefix(strs []string) string {

    res := ""

    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return res
            }
        } 
        res += string(strs[0][i])
    }

    return res

}
--


===================================================================================================================================


-- Climbing stairs


-- https://leetcode.com/problems/climbing-stairs/
--


-
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }

    dp := make([]int, n + 1)
    dp[0] = 1
    dp[1] = 1

    for i := 2; i < n + 1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
-


============================================================================================================================================

-- Happy Number


-- https://leetcode.com/problems/happy-number/
--

-- The concept is the non happy number will always be repeated after words

--
func sqaure(n int) int {
    sqaure := 0

    for n != 0 {
        temp := n % 10
        sqaure += temp * temp
        n /= 10
    }

    return sqaure
}

func isHappy(n int) bool {
    slow := n
    fast := n


    for  {
        slow = sqaure(slow)
        fast = sqaure(sqaure(fast))

        if slow == fast {
            break
        }
    }

    return slow == 1
}
--


===================================================================================================

-- Clear digits


-- https://leetcode.com/problems/clear-digits/submissions/1380780060/
--


--

// IsDigit checks if a character is a digit.
func IsDigit(a rune) bool {
	return unicode.IsDigit(a)
}

// clearDigits removes digits and the adjacent character from the string.
func clearDigits(s string) string {
	runes := []rune(s) // Convert the string to a slice of runes to handle Unicode characters
	for i := 0; i < len(runes); i++ {
		if IsDigit(runes[i]) {
			if i != 0 {
				// Remove the character before the digit and the digit itself
				runes = append(runes[:i-1], runes[i+1:]...)
				i -= 2 // Adjust the index to handle the new length
			} else {
				// Remove the first character and the digit
				runes = runes[2:]
				i-- // Adjust the index
			}
		}
	}
	return string(runes)
}
--

==========================================================================================================


-- Find the child who has the ball after k seconds


-- https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/submissions/1380793962/
--


--
func numberOfChild(n int, k int) int {
    p := 0
    i := 0

    for k != 0 {
        if i == 0 {
            p = 1
        }
        if i == n - 1 {
            p = -1
        }

        i += p
        k -= 1
    }
    return i
}
--


=========================================================================================================

-- Count the pairs that form a complete day


-- https://leetcode.com/problems/count-pairs-that-form-a-complete-day-i/
--


--
func countCompleteDayPairs(hours []int) int{
	// Create a map to store the frequency of remainders
	remainderFreq := make(map[int]int)
	pairs := 0

	for _, hour := range hours {
		// Find the remainder when divided by 24
		rem := hour % 24
		
		// Calculate the complement remainder
		complement := (24 - rem) % 24
		
		// If the complement remainder exists in the map, it means we found a valid pair
		if count, exists := remainderFreq[complement]; exists {
			pairs += count
		}
		
		// Increment the frequency of the current remainder
		remainderFreq[rem]++
	}

	return pairs
}
--


================================================================================================================

-- 




