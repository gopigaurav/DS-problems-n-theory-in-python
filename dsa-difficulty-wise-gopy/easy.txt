

check for Pallindrome

-- 
--

--
import (
    "fmt"
    "strconv"
)

func isPalindrome(x int) bool {
    str := strconv.Itoa(x)

    for i:= 0; i < len(str) / 2; i++ {
        if str[i] != str[len(str)-i-1] {
			return false
		}
    }

    return true
}

--


========================================================================================================

-- Convert 1d array to 2d


-- https://leetcode.com/problems/convert-1d-array-into-2d-array/?envType=daily-question&envId=2024-09-01
--


--
class Solution:
    def construct2DArray(self, arr: List[int], m: int, n: int) -> List[List[int]]:
        if m * n != len(arr):
            return []

        res = []
        index = 0

        for i in range(m):
            col = []
            for j in range(n):
                col.append(arr[index])
                index += 1
            res.append(col)
        return res     
--


=================================================================================================================


-- Symmetric binary tree


-- https://leetcode.com/problems/symmetric-tree/submissions/1376558768/
--


--
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def dfs(left, right):
            if not left and not right:
                return True

            if not left or not right:
                return False
            
            if left.val != right.val:
                return False
            
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        
        return dfs(root.left, root.right)
--

-- Go code

--
func dfs(left *TreeNode, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }

    if left == nil || right == nil {
        return false
    }

    if left.Val != right.Val {
        return false
    }

    return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)
}
func isSymmetric(root *TreeNode) bool {
    return dfs(root.Left, root.Right)
}
--


==========================================================================================================================

-- Maximum depth of the binary tree


--
-- https://leetcode.com/problems/maximum-depth-of-binary-tree/

--
func dfs(node *TreeNode) int {
    if node == nil {
        return 0
    }

    left := dfs(node.Left)
    right := dfs(node.Right)

    return max(left, right) + 1
}

func maxDepth(root *TreeNode) int {

    return dfs(root)
}
--

==========================================================================================================================

-- Longest common prefix 


-- https://leetcode.com/problems/longest-common-prefix/submissions/1379023169/
--


--
func longestCommonPrefix(strs []string) string {

    res := ""

    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return res
            }
        } 
        res += string(strs[0][i])
    }

    return res

}
--


===================================================================================================================================


-- Climbing stairs


-- https://leetcode.com/problems/climbing-stairs/
--


-
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }

    dp := make([]int, n + 1)
    dp[0] = 1
    dp[1] = 1

    for i := 2; i < n + 1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
-


============================================================================================================================================

-- Happy Number


-- https://leetcode.com/problems/happy-number/
--

-- The concept is the non happy number will always be repeated after words

--
func sqaure(n int) int {
    sqaure := 0

    for n != 0 {
        temp := n % 10
        sqaure += temp * temp
        n /= 10
    }

    return sqaure
}

func isHappy(n int) bool {
    slow := n
    fast := n


    for  {
        slow = sqaure(slow)
        fast = sqaure(sqaure(fast))

        if slow == fast {
            break
        }
    }

    return slow == 1
}
--


===================================================================================================

-- Clear digits


-- https://leetcode.com/problems/clear-digits/submissions/1380780060/
--


--

// IsDigit checks if a character is a digit.
func IsDigit(a rune) bool {
	return unicode.IsDigit(a)
}

// clearDigits removes digits and the adjacent character from the string.
func clearDigits(s string) string {
	runes := []rune(s) // Convert the string to a slice of runes to handle Unicode characters
	for i := 0; i < len(runes); i++ {
		if IsDigit(runes[i]) {
			if i != 0 {
				// Remove the character before the digit and the digit itself
				runes = append(runes[:i-1], runes[i+1:]...)
				i -= 2 // Adjust the index to handle the new length
			} else {
				// Remove the first character and the digit
				runes = runes[2:]
				i-- // Adjust the index
			}
		}
	}
	return string(runes)
}
--

==========================================================================================================


-- Find the child who has the ball after k seconds


-- https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/submissions/1380793962/
--


--
func numberOfChild(n int, k int) int {
    p := 0
    i := 0

    for k != 0 {
        if i == 0 {
            p = 1
        }
        if i == n - 1 {
            p = -1
        }

        i += p
        k -= 1
    }
    return i
}
--


=========================================================================================================

-- Count the pairs that form a complete day


-- https://leetcode.com/problems/count-pairs-that-form-a-complete-day-i/
--


--
func countCompleteDayPairs(hours []int) int{
	// Create a map to store the frequency of remainders
	remainderFreq := make(map[int]int)
	pairs := 0

	for _, hour := range hours {
		// Find the remainder when divided by 24
		rem := hour % 24
		
		// Calculate the complement remainder
		complement := (24 - rem) % 24
		
		// If the complement remainder exists in the map, it means we found a valid pair
		if count, exists := remainderFreq[complement]; exists {
			pairs += count
		}
		
		// Increment the frequency of the current remainder
		remainderFreq[rem]++
	}

	return pairs
}
--


================================================================================================================

-- Minimum time visiting all points


-- https://leetcode.com/problems/minimum-time-visiting-all-points/
--


--
import (
	"fmt"
	"math"
)

func minTimeToVisitAllPoints(points [][]int) int {
	time := 0

	for i := 1; i < len(points); i++ {
		prev := points[i-1]
		curr := points[i]

		// Calculate the absolute difference between x and y coordinates
		first := math.Abs(float64(prev[0] - curr[0]))
		second := math.Abs(float64(prev[1] - curr[1]))

		// Add the maximum of the two differences to the time
		time += int(math.Max(first, second))
	}

	return time
}


--

===============================================================================================================


-- Shft 2d grid


-- https://leetcode.com/problems/shift-2d-grid/
--


--
func shiftGrid(grid [][]int, k int) [][]int {
    m, n := len(grid), len(grid[0])
    totalElements := m * n
    k = k % totalElements // Reduce unnecessary full rotations

    // Flatten the 2D grid into a 1D array
    flat := make([]int, totalElements)
    idx := 0
    for _, row := range grid {
        for _, val := range row {
            flat[idx] = val
            idx++
        }
    }

    // Shift the flat array
    shifted := make([]int, totalElements)
    for i, val := range flat {
        shifted[(i+k)%totalElements] = val
    }

    // Convert the shifted 1D array back into a 2D grid
    result := make([][]int, m)
    for i := range result {
        result[i] = make([]int, n)
        for j := range result[i] {
            result[i][j] = shifted[i*n+j]
        }
    }

    return result
}
--

===================================================================================================

-- Cells with odd values in a matrix


-- https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/submissions/1381645907/
--


--
func oddCells(m int, n int, indices [][]int) int {
    // Create a 2D slice with size m x n
    res := make([][]int, m)
    for i := range res {
        res[i] = make([]int, n)
    }

    // Apply the operations for each index pair in indices
    for _, el := range indices {
        r := el[0]
        c := el[1]

        // Increment all elements in the r-th row
        for i := 0; i < n; i++ {
            res[r][i] += 1
        }

        // Increment all elements in the c-th column
        for j := 0; j < m; j++ {
            res[j][c] += 1
        }
    }

    cnt := 0
    // Count the number of odd cells
    for _, row := range res {
        for _, el := range row {
            if el%2 == 1 {
                cnt++
            }
        }
    }

    return cnt
}

--


========================================================================================================


-- Check if it is a straight line


-- https://leetcode.com/problems/check-if-it-is-a-straight-line/
--


--
func checkStraightLine(coordinates [][]int) bool {
    x1 := coordinates[0][0]
    x2 := coordinates[1][0]
    y1 := coordinates[0][1]
    y2 := coordinates[1][1]

    for i:= 2; i < len(coordinates); i++ {
        x := coordinates[i][0]
        y := coordinates[i][1]

        if (x - x2)*(y - y1) != (y - y2)*(x - x1) {
            return false
        }
    }
    return true

}
--

======================================================================================================

-- Subtract the product and sum of the digits of an integer


-- https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/submissions/1381753084/
--


--
func subtractProductAndSum(n int) int {
    product := 1
    sumarry := 0

    for n != 0 {
        temp := n % 10
        
        product *= temp

        sumarry += temp
        n /= 10
    }
    return product - sumarry
}
--


========================================================================================================