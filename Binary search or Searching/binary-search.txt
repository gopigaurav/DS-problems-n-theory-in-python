-- Allocate Pages (imp) or same as Book allocation


-- https://www.geeksforgeeks.org/allocate-minimum-number-pages/
-- https://practice.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1

--
 class Solution:
    
    #Function to find minimum number of pages.
    def findPages(self,A, N, M):
        def sol(arr, n, m, cmin):
            k = 1
            csum = 0
            
            for i in range(n):
                if cmin < arr[i]:
                    return False
                if csum + arr[i] > cmin:
                    k += 1
                    csum = arr[i]
                    
                    if k > m:
                        return False
                else:
                    csum += arr[i]
                    
            return True
                    
            
            
            
        if M > N:
            return -1
        start = 0
        end = 0
        for i in range(N):
            end += A[i]
            start = max(start, A[i])
        
        res = 0
        while start <= end:
            mid = ( start + end )// 2
            
            if sol(A, N, M, mid):
                res = mid
                end = mid - 1
            else:
                start = mid + 1
        return res
--


==================================================================================================================================

-- Median of two sorted array

-- https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/
-- https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/



--
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        A, B = nums1, nums2
        total = len(nums1) + len(nums2)
        
        if (len(A) > len(B)):
            A, B = B, A  # Swapping to make A smaller
        n = len(A)
        m = len(B)
        start = 0
        end = n
        realmidinmergedarray = (n + m + 1) // 2
  
        while (start <= end):
            
            mid = (start + end) // 2
            # mid for A
            leftAsize = mid
            
            # median for B
            leftBsize = realmidinmergedarray - mid
              
            # checking overflow of indices
            leftA = A[leftAsize - 1] if (leftAsize > 0) else float('-inf')
            leftB = B[leftBsize - 1] if (leftBsize > 0) else float('-inf')
            rightA = A[leftAsize] if (leftAsize < n) else float('inf')
            rightB = B[leftBsize] if (leftBsize < m) else float('inf')
  
            # if correct partition is done
            if leftA <= rightB and leftB <= rightA:
                if ((m + n) % 2 == 0):
                    return (max(leftA, leftB) + min(rightA, rightB)) / 2.0
                return max(leftA, leftB)
  
            elif (leftA > rightB):
                end = mid - 1
            else:
                start = mid + 1
--

================================================================================================================================================================================

-- The painters partition problem

-- https://practice.geeksforgeeks.org/problems/the-painters-partition-problem1535/1
-- https://www.geeksforgeeks.org/painters-partition-problem/


--
class Solution:
    def minTime (self, A, n, k):
        def sol(arr, n, m, cmin):
            k = 1
            csum = 0
            
            for i in range(n):
                if cmin < arr[i]:
                    return False
                if csum + arr[i] > cmin:
                    k += 1
                    csum = arr[i]
                    
                    if k > m:
                        return False
                else:
                    csum += arr[i]
                    
            return True
                    
            
            
        # no need or can be taken 
        # if k > n:
        #    return -1
        start = 0
        end = 0
        for i in range(n):
            end += A[i]
            start = max(start, A[i])
        
        res = 0
        while start <= end:
            mid = ( start + end )// 2
            
            if sol(A, n, k, mid):
                res = mid
                end = mid - 1
            else:
                start = mid + 1
        return res
--

=========================================================================================================================================

-- find elements present in first array and not in second

-- https://www.geeksforgeeks.org/find-elements-present-first-array-not-second/


--
# Python3 efficient program to find elements
# which are not present in second array

# Function for finding elements which
# are there in a[] but not in b[].
def findMissing(a, b, n, m):
	
	# Store all elements of second
	# array in a hash table
	s = dict()
	for i in range(m):
		s[b[i]] = 1

	# Print all elements of first array
	# that are not present in hash table
	for i in range(n):
		if a[i] not in s.keys():
			print(a[i], end = " ")

# Driver code
a = [ 1, 2, 6, 3, 4, 5 ]
b = [ 2, 4, 3, 1, 0 ]
n = len(a)
m = len(b)
findMissing(a, b, n, m)

# This code is contributed by mohit kumar

--

==================================================================================================================================================================================

-- square root

-- https://www.geeksforgeeks.org/square-root-of-an-integer/



--
class Solution:
    def countSquares(self, x):
        if x == 0 or x == 1:
            return 0
        start = 1
        end = x
        
        while start <= end:
            mid = (start+end)//2
            
            if mid*mid == x:
                return mid
            if mid*mid < x:
                start = mid+1
                ans = mid
            else:
                end = mid - 1
        return ans
                
--


==============================================================================================================================================================

-- Search an element in a sorted and rotated array

-- https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/

-- https://practice.geeksforgeeks.org/problems/search-in-a-rotated-array4618/1


--
method - 2 => recursion

==
class Solution:
    def search(self, arr : list, l : int, h : int, key : int):
        if l > h:
            return -1
        mid = (l+h)//2
        
        if arr[mid] == key:
            return mid
        
        if arr[l] <= arr[mid]:
            if key>=arr[l] and key<= arr[mid]:
                return self.search(arr, l, mid-1, key)
            return self.search(arr, mid+1, h, key)
        if key >= arr[mid] and key <= arr[h]:
            return self.search(arr, mid+1, h, key)
        return self.search(arr, l, mid-1, key)
==


============================================================================================================================================================

-- bitonic point in an array

-- https://www.geeksforgeeks.org/find-bitonic-point-given-bitonic-sequence/
-- https://leetcode.com/problems/peak-index-in-a-mountain-array/


-- 

class Solution(object):
    def peakIndexInMountainArray(self, arr):
        start = 0
        end = len(arr) - 1
        while(start<=end):
            mid = start + ((end-start)/2)
            if(arr[mid - 1] < arr[mid] > arr[mid + 1]):
                return mid
            elif(arr[mid] < arr[mid + 1]):
                start = mid + 1
            else:
                end = mid-1
        
        
--


==============================================================================================================================================================

-- Pivot index

-- https://leetcode.com/problems/find-pivot-index/


--
class Solution(object):
    def pivotIndex(self, nums):
	if len(nums) == 1: return 0
	left, right = 0, sum(nums)

	for i in range(0, len(nums)):
		right -= nums[i]
		if left == right:
			return i
		left += nums[i]
	return -1
	
--

==============================================================================================================================================================

-- Peak element or index

-- https://leetcode.com/problems/find-peak-element/


--
class Solution(object):
    def findPeakElement(self, arr):
        start = 0
        end = len(arr) - 1
        while(start<end):
            mid = int(start + ((end-start)/2))
            if(arr[mid] > arr[mid + 1]):
                end = mid
            else:
                start = mid+1
        return start
         
--

================================================================================================================================================================

-- 


