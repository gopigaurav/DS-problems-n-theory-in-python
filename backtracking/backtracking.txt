
-- print all paths from left top to right bottom

-- https://www.youtube.com/watch?v=76sqTXhyufc
-- https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/


================================================================================================================================================

-- lexicographically permuations 




====================================================================================================================================================

-- special matrix (maze with obstacles)
-- https://www.youtube.com/watch?v=zg5v2rlV1tM&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=36
-- https://leetcode.com/problems/unique-paths-ii/
-- https://practice.geeksforgeeks.org/problems/special-matrix4201/1/#

#User function Template for python3

class Solution:
	def FindWays(self, n, m, blocked_cells):
	    
        maze = [[0 for l in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if [i+1,j+1] in blocked_cells:
                    maze[i][j] = -1
                    
        if (maze[0][0] == -1):
            return 0
        for i in range(n):
            if (maze[i][0] == 0):
                maze[i][0] = 1
 
        # If we encounter a blocked cell in
        # leftmost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
        
        
        for i in range(1, m, 1):
            if (maze[0][i] == 0):
                maze[0][i] = 1
 
        # If we encounter a blocked cell in
        # bottommost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
 
        # The only difference is that if a cell is -1,
        # simply ignore it else recursively compute
        # count value maze[i][j]
        for i in range(1, n, 1):
            for j in range(1, m, 1):
                 
                # If blockage is found, ignore this cell
                if (maze[i][j] == -1):
                    continue
     
                # If we can reach maze[i][j] from
                # maze[i-1][j] then increment count.
                if (maze[i - 1][j] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i - 1][j])
     
                # If we can reach maze[i][j] from
                # maze[i][j-1] then increment count.
                if (maze[i][j - 1] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i][j - 1])
     
        # If the final cell is blocked,
        # output 0, otherwise the answer
        if (maze[n - 1][m - 1] > 0):
            return maze[n - 1][m - 1]
        else:
            return 0




===================================================================================================================================

-- kth permutation 

-- https://www.youtube.com/watch?v=wT7gcXLYoao

==============================================================================================================================

-- kth lexicological permutation
 
-- https://practice.geeksforgeeks.org/problems/permutations-of-a-given-string-1587115620/1/#
-- https://www.youtube.com/watch?v=GuTPwotSdYw&t=362s 

-- 

# Python program to print all permutations with 
# duplicates allowed 

def toString(List): 
    return ''.join(List) 

# Function to print permutations of string 
# This function takes three parameters: 
# 1. String 
# 2. Starting index of the string 
# 3. Ending index of the string. 
def permute(a, l, r): 
    if l==r: 
        print (toString(a))
    else: 
        for i in range(l,r): 
            a[l], a[i] = a[i], a[l] 
            permute(a, l+1, r) 
            a[l], a[i] = a[i], a[l] # backtrack 

# Driver program to test the above function 
string = "ABC"
n = len(string) 
a = list(string) 
permute(a, 0, n) 

# This code is contributed by Bhavya Jain 

==========================================================================================================================

 
