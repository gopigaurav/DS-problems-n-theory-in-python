
-- print all paths from left top to right bottom

-- https://www.youtube.com/watch?v=76sqTXhyufc
-- https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/


================================================================================================================================================

-- lexicographically permuations 




====================================================================================================================================================

-- special matrix (maze with obstacles)
-- https://www.youtube.com/watch?v=zg5v2rlV1tM&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=36
-- https://leetcode.com/problems/unique-paths-ii/
-- https://practice.geeksforgeeks.org/problems/special-matrix4201/1/#

#User function Template for python3

class Solution:
	def FindWays(self, n, m, blocked_cells):
	    
        maze = [[0 for l in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if [i+1,j+1] in blocked_cells:
                    maze[i][j] = -1
                    
        if (maze[0][0] == -1):
            return 0
        for i in range(n):
            if (maze[i][0] == 0):
                maze[i][0] = 1
 
        # If we encounter a blocked cell in
        # leftmost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
        
        
        for i in range(1, m, 1):
            if (maze[0][i] == 0):
                maze[0][i] = 1
 
        # If we encounter a blocked cell in
        # bottommost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
 
        # The only difference is that if a cell is -1,
        # simply ignore it else recursively compute
        # count value maze[i][j]
        for i in range(1, n, 1):
            for j in range(1, m, 1):
                 
                # If blockage is found, ignore this cell
                if (maze[i][j] == -1):
                    continue
     
                # If we can reach maze[i][j] from
                # maze[i-1][j] then increment count.
                if (maze[i - 1][j] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i - 1][j])
     
                # If we can reach maze[i][j] from
                # maze[i][j-1] then increment count.
                if (maze[i][j - 1] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i][j - 1])
     
        # If the final cell is blocked,
        # output 0, otherwise the answer
        if (maze[n - 1][m - 1] > 0):
            return maze[n - 1][m - 1]
        else:
            return 0




===================================================================================================================================

-- 
