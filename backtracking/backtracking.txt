
-- print all paths from left top to right bottom

-- https://www.youtube.com/watch?v=76sqTXhyufc
-- https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/


================================================================================================================================================

-- lexicographically permuations 

-- https://www.geeksforgeeks.org/find-n-th-lexicographically-permutation-string-set-2/
-- https://practice.geeksforgeeks.org/problems/permutations-of-a-given-string-1587115620/1


====================================================================================================================================================

-- special matrix (maze with obstacles)
-- https://www.youtube.com/watch?v=zg5v2rlV1tM&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=36
-- https://leetcode.com/problems/unique-paths-ii/
-- https://practice.geeksforgeeks.org/problems/special-matrix4201/1/#

#User function Template for python3

class Solution:
	def FindWays(self, n, m, blocked_cells):
	    
        maze = [[0 for l in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if [i+1,j+1] in blocked_cells:
                    maze[i][j] = -1
                    
        if (maze[0][0] == -1):
            return 0
        for i in range(n):
            if (maze[i][0] == 0):
                maze[i][0] = 1
 
        # If we encounter a blocked cell in
        # leftmost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
        
        
        for i in range(1, m, 1):
            if (maze[0][i] == 0):
                maze[0][i] = 1
 
        # If we encounter a blocked cell in
        # bottommost row, there is no way of
        # visiting any cell directly below it.
            else:
                break
 
        # The only difference is that if a cell is -1,
        # simply ignore it else recursively compute
        # count value maze[i][j]
        for i in range(1, n, 1):
            for j in range(1, m, 1):
                 
                # If blockage is found, ignore this cell
                if (maze[i][j] == -1):
                    continue
     
                # If we can reach maze[i][j] from
                # maze[i-1][j] then increment count.
                if (maze[i - 1][j] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i - 1][j])
     
                # If we can reach maze[i][j] from
                # maze[i][j-1] then increment count.
                if (maze[i][j - 1] > 0):
                    maze[i][j] = (maze[i][j] +
                                  maze[i][j - 1])
     
        # If the final cell is blocked,
        # output 0, otherwise the answer
        if (maze[n - 1][m - 1] > 0):
            return maze[n - 1][m - 1]
        else:
            return 0




===================================================================================================================================

-- kth permutation 

-- https://www.youtube.com/watch?v=wT7gcXLYoao

==============================================================================================================================

-- kth lexicological permutation
 
-- https://practice.geeksforgeeks.org/problems/permutations-of-a-given-string-1587115620/1/#
-- https://www.youtube.com/watch?v=GuTPwotSdYw&t=362s 

-- 

# Python program to print all permutations with 
# duplicates allowed 

def toString(List): 
    return ''.join(List) 

# Function to print permutations of string 
# This function takes three parameters: 
# 1. String 
# 2. Starting index of the string 
# 3. Ending index of the string. 
def permute(a, l, r): 
    if l==r: 
        print (toString(a))
    else: 
        for i in range(l,r): 
            a[l], a[i] = a[i], a[l] 
            permute(a, l+1, r) 
            a[l], a[i] = a[i], a[l] # backtrack 

# Driver program to test the above function 
string = "ABC"
n = len(string) 
a = list(string) 
permute(a, 0, n) 

# This code is contributed by Bhavya Jain 

======================================================================================================================================

-- letter combination of phone numbers

-- https://www.interviewbit.com/problems/letter-phone/hints/
-- https://www.youtube.com/watch?v=0snEunUacZY
-- https://www.geeksforgeeks.org/find-possible-words-phone-digits/

================================================================================================================================================

-- balanced parenthesis

-- https://www.youtube.com/watch?v=s9fokUqJ76A
-- https://www.youtube.com/watch?v=eyCj_u3PoJE
-- https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/



==========================================================================================================================

 
-- Rat in maze

-- https://www.youtube.com/watch?v=bLGZhJlt4y0
-- https://practice.geeksforgeeks.org/problems/rat-in-a-maze-problem/1
-- https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/
--https://www.geeksforgeeks.org/rat-in-a-maze-problem-when-movement-in-all-possible-directions-is-allowed/

# Python3 program to solve Rat in a Maze
# problem using backtracking

# Maze size
n = 4

# A utility function to check if x, y is valid
# index for N * N Maze


def isValid(n, maze, x, y, res):
	if x >= 0 and y >= 0 and x < n and y < n and maze[x][y] == 1 and res[x][y] == 0:
		return True
	return False

# A recursive utility function to solve Maze problem


def RatMaze(n, maze, move_x, move_y, x, y, res):
	# if (x, y is goal) return True
	if x == n-1 and y == n-1:
		return True
	for i in range(4):
		# Generate new value of x
		x_new = x + move_x[i]

		# Generate new value of y
		y_new = y + move_y[i]

		# Check if maze[x][y] is valid
		if isValid(n, maze, x_new, y_new, res):

			# mark x, y as part of solution path
			res[x_new][y_new] = 1
			if RatMaze(n, maze, move_x, move_y, x_new, y_new, res):
				return True
			res[x_new][y_new] = 0
	return False


def solveMaze(maze):
	# Creating a 4 * 4 2-D list
	res = [[0 for i in range(n)] for i in range(n)]
	res[0][0] = 1

	# x matrix for each direction
	move_x = [-1, 1, 0, 0]

	# y matrix for each direction
	move_y = [0, 0, -1, 1]

	if RatMaze(n, maze, move_x, move_y, 0, 0, res):
		for i in range(n):
			for j in range(n):
				print(res[i][j], end=' ')
			print()
	else:
		print('Solution does not exist')


# Driver program to test above function
if __name__ == "__main__":
	# Initialising the maze
	maze = [[1, 0, 0, 0],
			[1, 1, 0, 1],
			[0, 1, 0, 0],
			[1, 1, 1, 1]]

	solveMaze(maze)

# This code is contributed by Anvesh Govind Saxena


==========================================================================================================================================

-- Boggle words II

-- https://www.youtube.com/watch?v=bppy7tHFQVM&t=1418s
-- https://www.geeksforgeeks.org/boggle-set-2-using-trie/
-- https://practice.geeksforgeeks.org/problems/72cf44eabd18006810efad06fbb623a0682acee2/1/


====================================================================================================================================================

-- word boggle I

-- https://www.geeksforgeeks.org/boggle-find-possible-words-board-characters/
-- https://www.youtube.com/results?search_query=word+boggle