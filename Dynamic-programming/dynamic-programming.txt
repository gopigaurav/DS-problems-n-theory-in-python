-- 0-1 knapsack

-- https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1
-- https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/


--
class Solution:
    
    #Function to return max value that can be put in knapsack of capacity W.
    def knapSack(self,W, wt, val, n):
       
        dp = [[0 for i in range(W + 1)] for j in range(n + 1)]  # Making the dp array

        for i in range(1, n+1):  # taking first i elements
            for j in range(1, W+1):  
                if wt[i-1] <= j:
                    dp[i][j] = max(val[i-1] + dp[i-1][j -wt[i-1]],dp[i-1][j])
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[n][W]
    
    def knapSack(self, W, wt, val, n):
        dp = [0 for i in range(W+1)]  # Making the dp array
 
        for i in range(1, n+1):  # taking first i elements
            for w in range(W, 0, -1):  # starting from back,so that we also have data of
                                    # previous computation when taking i-1 items
                if wt[i-1] <= w:
                    # finding the maximum value
                    dp[w] = max(dp[w], dp[w-wt[i-1]]+val[i-1])
     
        return dp[W] 
--


============================================================================================================
## Longest common substring
--

class Solution:
    # @param A : string
    # @param B : string
    # @return an integer
    def solve(self, A, B):
        # longest common letter between two string which is non-continuous
        # if A[] == B[] then increase length
        # else max( f(A[:], B[:-1]), f(A[:-1], B[:])
        
        # if n==0 and m==0 then return 0
        l1 = len(A)
        l2 = len(B)
        dp = [[-1]*(l2+1) for _ in range(l1+1)]
        
        # initialise first row and first column with 0
        for i in range(l1+1):
            dp[i][0] = 0
        for j in range(l2+1):
            dp[0][j] = 0
            
        # apply from 1 to n
        for i in range(1, l1+1):
            for j in range(1, l2+1):
                if A[i-1] == B[j-1]:
                    dp[i][j] = 1+dp[i-1][j-1]
                else:
                    dp[i][j] = 0
        
        return dp[l1][l2] 

--
=============================================================================================================================================
# Longest common subsequence
# https://www.interviewbit.com/blog/longest-common-substring

-- Longest common subsequence
-- https://leetcode.com/problems/longest-common-subsequence/submissions/
-- https://www.interviewbit.com/problems/longest-common-subsequence/

def LCS(s1,s2):
    l1 = len(s1)
    l2 = len(s2)
    dp = [[None]*(l2+1) for _ in range(l1+1)]

    # Initialise dp
    # If length of any substring is 0 then length of LCS will be zero
    # So dp[0][i] and dp[j][0] will be zero

    for i in range(l1+1):
        dp[i][0] = 0
    for j in range(l2+1):
        dp[0][j] = 0

    # if s1[i] == s2[j] then increase by 1 else search in i-1 and j or i and j-1
    for i in range(1,l1+1):
        for j in range(1,l2+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i][j-1],dp[i-1][j])

    # dp[l1][l2] contains the length of LCS of s1 and s2
    return dp[l1][l2]


-- Longest common subsequence
-- https://www.interviewbit.com/problems/longest-palindromic-subsequence/
-- https://leetcode.com/problems/longest-palindromic-subsequence/

# longest palindromic subsequence

def LPS(s):
    # Length of the Largest palindromic subsequence is equal to Longest Common Subsequence of string s and reversed(s)
    srev = s[::-1]
    return LCS(s,srev)

if __name__ == '__main__':
    s = 'agbdba'
    length = LPS(s)
    print(f'Length of the largest Palindromic Subsequence is {length}')

==================================================================================================================================


# longest palindromic substring

	public static List<string> SubString(String str)
    {
    	var list = new List<string>();
        for (int i = 0; i < str.Length; i++)
        {
            for (int j = 1; j <= str.Length - i; j++)
            {
                var temp = str.Substring(i, j);
                if(temp==ReverseString(temp))
                {
                    list.Add(temp);
                }
            }
        }
        
        return list;
    }
    public static string ReverseString(string s)
    {
        char[] arr = s.ToCharArray();
        Array.Reverse(arr);
        return new string(arr);
    }

================================================================================================

# longest palindromic substring or subsequence
# Longest common substring or subsequence
def LCS(s1,s2):
    l1 = len(s1)
    l2 = len(s2)
    mx = 0
    # Initialise dp
    # If length of any substring is 0 then length of LCS will be zero
    # So dp[0][i] and dp[j][0] will be zero
    dp = [[0 for k in range(l2+1)] for l in range(l1+1)]

    # if s1[i] == s2[j] then increase by 1 else search in i-1 and j or i and j-1
    for i in range(1,l1+1):
        for j in range(1,l2+1):
		# not required if statement
            if (i == 0 or j == 0):
                dp[i][j] = 0
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
                mx = max(mx, dp[i][j])
            else:
                dp[i][j] = 0
		# dp[i][j] = max(dp[i][j-1],dp[i-1][j])

    # dp[l1][l2] contains the length of LCS of s1 and s2
    return mx

def LPS(s):
    # Length of the Largest palindromic subsequence is equal to Longest Common Subsequence of string s and reversed(s)
    srev = s[::-1]
    #srev = ""
    return LCS(s,srev)

if __name__ == '__main__':
    s = 'aabaade'
    length = LPS(s)
    print(f'Length of the largest Palindromic Subsequence is {length}')

========================================================================================================

-- Print longest common subsequence

-- https://www.geeksforgeeks.org/printing-longest-common-subsequence/


--
# Dynamic programming implementation of LCS problem

# Returns length of LCS for X[0..m-1], Y[0..n-1]


def lcs(X, Y, m, n):
	L = [[0 for i in range(n+1)] for j in range(m+1)]

	# Following steps build L[m+1][n+1] in bottom up fashion. Note
	# that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1]
	for i in range(m+1):
		for j in range(n+1):
			if i == 0 or j == 0:
				L[i][j] = 0
			elif X[i-1] == Y[j-1]:
				L[i][j] = L[i-1][j-1] + 1
			else:
				L[i][j] = max(L[i-1][j], L[i][j-1])

		# Create a string variable to store the lcs string
	lcs = ""

	# Start from the right-most-bottom-most corner and
	# one by one store characters in lcs[]
	i = m
	j = n
	while i > 0 and j > 0:

		# If current character in X[] and Y are same, then
		# current character is part of LCS
		if X[i-1] == Y[j-1]:
			lcs += X[i-1]
			i -= 1
			j -= 1

		# If not same, then find the larger of two and
		# go in the direction of larger value
		elif L[i-1][j] > L[i][j-1]:
			i -= 1
			
		else:
			j -= 1

	# We traversed the table in reverse order
	# LCS is the reverse of what we got
	lcs = lcs[::-1]
	print("LCS of " + X + " and " + Y + " is " + lcs)


# Driver program
X = "AGGTAB"
Y = "GXTXAYB"
m = len(X)
n = len(Y)
lcs(X, Y, m, n)

# This code is contributed by AMAN ASATI

--


====================================================================================================================================================
Print the longest common substing
https://www.interviewbit.com/blog/longest-common-substring/
# https://www.techiedelight.com/longest-common-substring-problem/
# Function to find the longest common substring of sequences `X[0…m-1]` and `Y[0…n-1]`
def LCS(X, Y, m, n):
 
    maxLength = 0           # stores the max length of LCS
    endingIndex = m         # stores the ending index of LCS in `X`
 
    # `lookup[i][j]` stores the length of LCS of substring `X[0…i-1]` and `Y[0…j-1]`
    lookup = [[0 for x in range(n + 1)] for y in range(m + 1)]
 
    # fill the lookup table in a bottom-up manner
    for i in range(1, m + 1):
        for j in range(1, n + 1):
 
            # if the current character of `X` and `Y` matches
            if X[i - 1] == Y[j - 1]:
                lookup[i][j] = lookup[i - 1][j - 1] + 1
 
                # update the maximum length and ending index
                if lookup[i][j] > maxLength:
                    maxLength = lookup[i][j]
                    endingIndex = i
 
    # return longest common substring having length `maxLength`
    return X[endingIndex - maxLength: endingIndex]
 
 
if __name__ == '__main__':
 
    X = 'ABC'
    Y = 'BABA'
 
    m = len(X)
    n = len(Y) 
 
    # Find longest common substring
    print('The longest common substring is', LCS(X, Y, m, n)) # result AB

==========================================================================================================================

# minimum no of sqaures whose sum equals to given no
https://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/

# A dynamic programming based Python
# program to find minimum number of
# squares whose sum is equal to a
# given number
from math import ceil, sqrt

# Returns count of minimum squares
# that sum to n
def getMinSquares(n):

	# Create a dynamic programming table
	# to store sq and getMinSquares table
	# for base case entries
	dp = [0, 1, 2, 3]

	# getMinSquares rest of the table
	# using recursive formula
	for i in range(4, n + 1):
		
		# max value is i as i can always
		# be represented as 1 * 1 + 1 * 1 + ...
		dp.append(i)

		# Go through all smaller numbers
		# to recursively find minimum
		for x in range(1, int(ceil(sqrt(i))) + 1):
			temp = x * x;
			if temp > i:
				break
			else:
				dp[i] = min(dp[i], 1 + dp[i-temp])

	# Store result
	return dp[n]

# Driver code
print(getMinSquares(6))

# This code is contributed by nuclode


=====================================================================================================================================

knapsack 

# We know we are always using the  current row or
    # the previous row of the array/vector . Thereby we can
    # improve it further by using a 2D array but with only
    # 2 rows i%2 will be giving the index inside the bounds
    # of 2d array K

optimised use array[i%2][j]
https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/


=========================================================================================================

MAXIMIZE CUT SEGMENTS 

-- https://www.youtube.com/watch?v=QKx7d0MV2OQ
-- https://www.geeksforgeeks.org/maximize-the-number-of-segments-of-length-p-q-and-r/

# Python 3 program to
# maximize the number
# of segments of length
# p, q and r

# Function that returns
# the maximum number
# of segments possible


def findMaximum(l, p, q, r):

	# Array to store the cut
	# at each length
	# All values with -1
	dp = [-1]*(l + 1)

	# if length of rod is 0 then
	# total cuts will be 0
	# so, initialize the dp[0] with 0
	dp[0] = 0

	for i in range(l+1):

		# if certain length is not
		# possible
		if (dp[i] == -1):
			continue

		# if a segment of p is possible
		if (i + p <= l):
			dp[i + p] = (max(dp[i + p],
							dp[i] + 1))

		# if a segment of q is possible
		if (i + q <= l):
			dp[i + q] = (max(dp[i + q],
							dp[i] + 1))

		# if a segment of r is possible
		if (i + r <= l):
			dp[i + r] = (max(dp[i + r],
							dp[i] + 1))

	# if no segment can be cut then return 0
	if dp[l] == -1:
		dp[l] = 0
	# return value corresponding
	# to length l
	return dp[l]


# Driver Code
if __name__ == "__main__":
	l = 11
	p = 2
	q = 3
	r = 5

	# Calling Function
	ans = findMaximum(l, p, q, r)
	print(ans)

==============================================================================================================

https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/
neetcode problem

# Dynamic Programming Approach of Finding LIS by reducing the problem to longest common Subsequence

-- https://www.youtube.com/watch?v=IFfYfonAFGc
-- https://leetcode.com/problems/longest-increasing-subsequence/

def lis(a):
	n = len(a)
	# Creating the sorted list
	b = sorted(list(set(a)))
	m = len(b)

	# Creating dp table for storing the answers of sub problems
	dp = [[-1 for i in range(m+1)] for j in range(n+1)]

	# Finding Longest common Subsequence of the two arrays
	for i in range(n+1):

		for j in range(m+1):
			if i == 0 or j == 0:
				dp[i][j] = 0
			elif a[i-1] == b[j-1]:
				dp[i][j] = 1+dp[i-1][j-1]
			else:
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
	return dp[-1][-1]


# Driver program to test above function
arr = [10, 22, 9, 33, 21, 50, 41, 60]
print("Length of lis is ", lis(arr))
# This code is Contributed by Dheeraj Khatri

or 

# Dynamic programming Python implementation
# of LIS problem

# lis returns length of the longest
# increasing subsequence in arr of size n

-- https://www.interviewbit.com/problems/longest-increasing-subsequence/
-- Refer this

-- https://leetcode.com/problems/longest-increasing-subsequence/submissions/

class Solution(object):
    def lengthOfLIS(self, A):
        DP = [1]*len(A)
        for i in range(len(A)):
            #compair from 0 to i again and check if a[previous] < a[i] then 1+dp[j]
            for j in range(i):
                if A[j] < A[i]:
                    DP[i] = max(DP[i], DP[j]+1)
        return max(DP)


        
# end of lis function


# Driver program to test above function
arr = [10, 22, 9, 33, 21, 50, 41, 60]
print ("Length of lis is", lis(arr))
# This code is contributed by Nikhil Kumar Singh


-- Binary Search O(n*logn)

-- https://leetcode.com/problems/longest-increasing-subsequence/submissions/
-- https://www.youtube.com/watch?v=on2hvxBXJH4

--
def lengthOfLIS(self, A):
        res = [A[0]]
        for i in range(1, len(A)):
            if A[i] > res[-1]:
                res.append(A[i])
            elif A[i] < res[-1]:
                print(res)
                res[self.searchInsert(res, A[i])]  = A[i]
        print(res)
        return len(res)
                
            
            
    def searchInsert(self, arr, target):
        start = 0
        end = len(arr) - 1
        res = -1
        while(start<=end):
            mid = start + ((end-start)/2)
            if(arr[mid] == target):
                return mid
            elif(arr[mid] < target):
                start = mid+1
            else:
                end = mid-1
        return start
--

=======================================================================================================================

-- Edit distance

-- 
Given two strings A and B, find the minimum number of steps required to convert 
A to B. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character

--

-- https://www.interviewbit.com/problems/edit-distance/
-- https://neetcode.io/
-- https://www.youtube.com/watch?v=fJaKO8FbDdo


-- Using 2 ID array
--
def minDistance1(self, A, B):
        # using 2d array
        # prev = [0, 1, 2, 3, ... len(A)+1]
        # curr = [5] that is length of A
        prev, curr = range(len(A)+1), [len(A)]
        for i, bi in enumerate(B):
            curr = [i+1]
            for j, aj in enumerate(A):
                if aj == bi:
                    val = prev[j]
                else:
                    # min of insert , delete, replace
                    val = min(prev[j], prev[j+1], curr[j])+1
                curr.append(val)
            #print(prev, curr)
            prev = curr
        #print([prev])
        return curr[-1]
--

or

--
def minDistance1(self, A, B):
        # using 2d array
        n = len(A)
        prev = range(n+1)
	cur = [0] * (m+1)
        for i in range(1, n+1):
            curr = [i+1]
            for j in range(1, m+1):
                if A[i-1] == B[j-1]:
                    cur[j] = prev[j-1]
                else:
                    # min of insert , delete, replace
                    val = min(prev[j], prev[j-1], curr[j-1])+1
            #print(prev, curr)
            prev = curr
        #print([prev])
        return prev[m]
--

=========================================================================================================================================

# wild card pattern
-- https://www.geeksforgeeks.org/dynamic-programming-wildcard-pattern-matching-linear-time-constant-space/
-- https://www.youtube.com/watch?v=ZmlQ3vgAOMo&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=35
-- https://leetcode.com/problems/wildcard-matching/submissions/
-- code -- https://www.codingninjas.com/codestudio/problems/wildcard-pattern-matching_701650?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=0

-- https://www.codingninjas.com/codestudio/problems/wildcard-pattern-matching_701650?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=0

method - 1:
class Solution(object):
    def isMatch1(self, text, pattern):
        n = len(pattern)
        m = len(text)
        dp = [[-1 for k in range(m+1)] for l in range(n+1)]
        # go from right to left
        # from n-1 to 0

        def solve(i, j, pattern, text, dp):
            if i<0 and j<0:
                return True
            if i < 0 and j >= 0:
                return False
            if j<0 and i>= 0:
                for u in range(i,-1,-1):
                    if pattern[u] != "*":
                        return False
                return True
            if dp[i][j] != -1: return dp[i][j]
            if (pattern[i] == text[j] or pattern[i] == "?"):
                #then shrink the string
                dp[i][j] = solve(i-1,j-1,pattern,text,dp)
                return dp[i][j]
            if (pattern[i] == "*"):
                dp[i][j] = solve(i,j-1,pattern,text,dp) or solve(i-1,j,pattern,text,dp)
                return dp[i][j]
            dp[i][j] = False
            return dp[i][j]
        
        return 1 if solve(n-1, m-1, pattern, text, dp) == True else 0
        
        # refer this
    def isMatch(self, text, pattern):
        n = len(pattern)
        m = len(text)
        dp = [[False for k in range(m+1)] for l in range(n+1)]
        dp[0][0] = True
        for j in range(1, m+1):
            dp[0][j] = False
        for i in range(1, n+1):
            flag = True
            for u in range(1,i+1):
                if pattern[u-1] != "*":
                    flag = False
                    break
            dp[i][0] = flag

        for i in range(1,n+1):
            for j in range(1,m+1):
                if (pattern[i-1] == text[j-1] or pattern[i-1] == "?"):
                    dp[i][j] = dp[i-1][j-1]
                elif (pattern[i-1] == "*"):
                    dp[i][j] = dp[i][j-1] or dp[i-1][j]
                else:
                    dp[i][j] = False
        return dp[n][m]
    
    def isMatch1(self, text, pattern):
        n = len(pattern)
        m = len(text)
        prev = [False] * (m+1)
        cur = [False] * (m+1)
        prev[0] = True
            
        for i in range(1,n+1):
            flag = True
            for u in range(1,i+1):
                if pattern[u-1] != "*":
                    flag = False
                    break
            cur[0] = flag
            for j in range(1,m+1):
                if (pattern[i-1] == text[j-1] or pattern[i-1] == "?"):
                    cur[j] = prev[j-1]
                elif (pattern[i-1] == "*"):
                    cur[j] = prev[j] or cur[j-1]
                else:
                    cur[j] = False
            prev = cur
        return cur[m]
    


method - 2:
-- https://www.codingninjas.com/codestudio/problems/wildcard-pattern-matching_701650?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=0

================================================================================================================================

-- max lenght chain

--https://www.geeksforgeeks.org/maximum-length-chain-of-pairs-dp-20/
--https://www.youtube.com/watch?v=x6_FP48roTQ

code 1 - dp
code 2 - greedy

=============================================================================================================================

== Maximum sum increasing subsequnce 

-- https://www.youtube.com/watch?v=Y88xh18XcbE
-- https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/


=============================================================================================================================

-- min number of jumps

-- https://www.youtube.com/watch?v=liTMFOhs6ZM
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

=============================================================================================================================

# max path sum matrix

-- https://www.geeksforgeeks.org/maximum-path-sum-matrix/
-- https://www.youtube.com/watch?v=OCz6rm9Nh1o

===================================================================================================================

# prefix sum array 

-- https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/

=====================================================================================================================
-- max score possible
-- https://www.geeksforgeeks.org/maximum-score-possible-after-performing-given-operations-on-an-array/
========================================================================================================================

# shoretest common supersequence

-- https://www.geeksforgeeks.org/shortest-common-supersequence/
-- https://leetcode.com/problems/shortest-common-supersequence/submissions/

class Solution(object):
    def shortestCommonSupersequence(self, s1, s2):
        
        l1 = len(s1)
        l2 = len(s2)
        mx = 0
        res = []
        dp = [[0 for k in range(l2+1)] for l in range(l1+1)]
        for i in range(1,l1+1):
            for j in range(1,l2+1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    mx = max(mx, dp[i][j])
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])

        while i > 0 and j > 0:
            if s1[i-1] == s2[j-1]:
                res.append(s1[i-1])
                i-=1
                j-=1
            else:
                if dp[i-1][j] > dp[i][j-1]:
                    res.append(s1[i-1])
                    i-=1
                else:
                    res.append(s2[j-1])
                    j-=1
            
        while(i>0):
            res.append(s1[i-1])
            i-=1
        while(j>0):
            res.append(s2[j-1])
            j-=1
        res = res[::-1]
        res = "".join(res)
        return res

==================================================================================================================================

-- palindrome partitioning 1 and 2

-- https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/
-- https://www.youtube.com/watch?v=szKVpQtBHh8&t=200s
-- https://www.youtube.com/watch?v=WBgsABoClE0
-- https://www.youtube.com/watch?v=3jvWodd7ht0

-- refer this
-- https://www.youtube.com/watch?v=wMoOpnihXJY

# Python code for implementation of Naive Recursive
# approach
def isPalindrome(x):
	return x == x[::-1]


def minPalPartion(string, i, j):
	if i >= j or isPalindrome(string[i:j + 1]):
		return 0
	ans = float('inf')
	for k in range(i, j):
		count = (
			1 + minPalPartion(string, i, k)
			+ minPalPartion(string, k + 1, j)
		)
		ans = min(ans, count)
	return ans


def main():
	string = "ababbbabbababa"
	print(
	"Min cuts needed for Palindrome Partitioning is ",
	minPalPartion(string, 0, len(string) - 1),
	)

if __name__ == "__main__":
	main()

# This code is contributed by itsvinayak


--- palindrome 1
-- https://www.youtube.com/watch?v=WBgsABoClE0
-- https://leetcode.com/problems/palindrome-partitioning/submissions/
-- https://leetcode.com/problems/palindrome-partitioning/

--
class Solution:
    def partition(self, s):
        res = [] # which will be our answer
        self.helper(res, [], s) # calling to recursion function 
        return res
    
    def helper(self, res, curr, s):
        if s == "":
            res.append(curr)
            return
        
        for i in range(len(s)):
            if self.isPalindrome(s[:i + 1]):
                self.helper(res, curr + [s[:i + 1]], s[i + 1:])
    
    def isPalindrome(self, s):
        if s[:] != s[::-1]:
            return False
        return True
--



-- palindrome 2
-- https://www.youtube.com/watch?v=_H8V5hJUGd0&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=54
-- https://leetcode.com/problems/palindrome-partitioning-ii/
-- min cuts in palindrome partitioning


--

class Solution(object):
    def minCut1(self, s):
        # front partitioning
        # if i == n : return 0
        n = len(s)
        dp = [-1] * (n+1)
        return self.sol(0, s, n, dp) - 1
    
    def sol(self, i, s, n, dp):
        if i == n: return 0
        if dp[i] != -1: return dp[i]
        minCost = float("inf")
        
        
        for j in range(i, n):
            # from i to j check for palindrome if yes and add 1 and recursion for rest of the palindrome
            temp = s[i:j+1]
            if temp[:] == temp[::-1]:
                # from j+1 to end
                cost = 1 + self.sol(j+1, s, n, dp)
                minCost = min(minCost, cost)
        dp[i] = minCost
        return dp[i]
                
        
        
    def isPalindrome(self, i, j, s):
        temp = s[i:j+1]
        if s[i:j+1] != temp[::-1]:
            return False
        return True
    
    
    # Tabulation approach that is bottom up
    def minCut2(self, s):
        cut = [x for x in range(-1,len(s))]
        for i in range(0,len(s)):
            for j in range(i,len(s)):
                if s[i:j] == s[j:i:-1]:
                    cut[j+1] = min(cut[j+1],cut[i]+1)
        return cut[-1]
    
    
    def minCut(self, s):
        
        n = len(s)
        if n == 1:
            return 0
        dp = [0 for _ in range(n+1)]
        
        dp[n] = 0 # base case
        
        # i from n-1 to 0
        minCost = float("inf")
        for i in range(n-1, -1, -1):    
            minCost = float("inf")
            for j in range(i, n):
                
            # from i to j check for palindrome if yes and add 1 and recursion for rest of the palindrome
            # palindrome functions might give u TLE here 
            
                temp = s[i:j+1]
		# be careful in next step
                if temp[:] == temp[::-1]:
                    # from j+1 to end
                    cost = 1 + dp[j+1]
                    minCost = min(minCost, cost)
            dp[i] = minCost
        return dp[0] - 1

-- 

=======================================================================================================================

-- minimum number of insertion to make palindrome


-- https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/submissions/
-- geeksforgeeks.org/minimum-insertions-to-form-a-palindrome-dp-28/



# find longest common sunsequence
# then n - LCS
--

class Solution(object):
    def minInsertions(self, s):
        srev = s[::-1]
        lcs = self.LCS(s,srev)
        res = len(s) - lcs
        return res
    def LCS(self,s1,s2):
        l1 = len(s1)
        l2 = len(s2)
        mx = 0
        dp = [[0 for k in range(l2+1)] for l in range(l1+1)]

        for i in range(1,l1+1):
            for j in range(1,l2+1):
            # not required if statement
                if (i == 0 or j == 0):
                    dp[i][j] = 0
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    mx = max(mx, dp[i][j])
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])

        return mx
--

=========================================================================================================================

-- min cost 


-- https://www.geeksforgeeks.org/min-cost-path-dp-6/
# minimum number of insertion == min number of deletions
-- that is ==> len of string - Longest palindromic subsequence

class Solution(object):
    def minInsertions(self, s):
        srev = s[::-1]
        lcs = self.LCS(s,srev)
        res = len(s) - lcs
        return res

    def LCS(self,s1,s2):
        l1 = len(s1)
        l2 = len(s2)
        mx = 0
        dp = [[0 for k in range(l2+1)] for l in range(l1+1)]

        for i in range(1,l1+1):
            for j in range(1,l2+1):
            # not required if statement
                if (i == 0 or j == 0):
                    dp[i][j] = 0
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    mx = max(mx, dp[i][j])
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])

        return mx

===============================================================================================================================

  # Burst baloons 

-- https://www.youtube.com/watch?v=Yz4LlDSlkns
-- https://leetcode.com/problems/burst-balloons/submissions/
-- class Solution(object):
    def maxCoins(self, nums):
        def fopt(i, j, a,dp):
            if i > j:
                return 0
            if dp[i][j] != -1:
                return dp[i][j]
            maxi = 0
            for ind in range(i,j+1):
                cost = a[i-1] * a[ind] * a[j+1] + f(i,ind-1,a,dp) + f(ind+1,j,a,dp)
                maxi = max(maxi, cost)
            dp[i][j] = maxi
            return dp[i][j]
            
        n = len(nums)
        # dp = [[-1 for k in range(n+1)] for l in range(n+1)]
        
        
        
        
        
        # tabulation
        dp = [[0 for k in range(n+2)] for l in range(n+2)]
        nums.append(1)
        nums.insert(0,1)
        
        for i in range(n,0,-1):
            for j in range(1,n+1):
                if (i > j): continue 
                maxi = 0
                for ind in range(i,j+1):
                    cost = nums[i-1] * nums[ind] * nums[j+1] + dp[i][ind-1] + dp[ind +1][j]
                    maxi = max(maxi, cost)
                dp[i][j] = maxi
        return dp[1][n]
        
        # return fopt(1,n,nums, dp)


===============================================================================================================

-- Matrix chain multiplication (MCM)

--https://www.youtube.com/watch?v=pDCXsbAw5Cg&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=50
-- https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/

-- tabulation
# Dynamic Programming Python implementation of Matrix
# Chain Multiplication. See the Cormen book for details
# of the following algorithm
import sys
maxint=int(1e9+7)
# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n


def MatrixChainOrder(p, n):
	# For simplicity of the program,
	# one extra row and one
	# extra column are allocated in m[][].
	# 0th row and 0th
	# column of m[][] are not used
	m = [[0 for x in range(n)] for x in range(n)]

	# m[i, j] = Minimum number of scalar
	# multiplications needed
	# to compute the matrix A[i]A[i + 1]...A[j] =
	# A[i..j] where
	# dimension of A[i] is p[i-1] x p[i]

	# cost is zero when multiplying one matrix.
	for i in range(1, n):
		m[i][i] = 0

	# L is chain length.
	for L in range(2, n):
		for i in range(1, n-L + 1):
			j = i + L-1
			m[i][j] = maxint
			for k in range(i, j):

				# q = cost / scalar multiplications
				q = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]
				if q < m[i][j]:
					m[i][j] = q

	return m[1][n-1]


# Driver code
arr = [1, 2, 3, 4]
size = len(arr)

print("Minimum number of multiplications is " +
	str(MatrixChainOrder(arr, size)))
# This Code is contributed by Bhavya Jain

-- memoization

# Python program using memoization
import sys
dp = [[-1 for i in range(100)] for j in range(100)]

# Function for matrix chain multiplication
def matrixChainMemoised(p, i, j):
	if(i == j):
		return 0
	
	if(dp[i][j] != -1):
		return dp[i][j]
	
	dp[i][j] = sys.maxsize
	
	for k in range(i,j):
		dp[i][j] = min(dp[i][j], matrixChainMemoised(p, i, k) + matrixChainMemoised(p, k + 1, j)+ p[i - 1] * p[k] * p[j])
	
	return dp[i][j]

def MatrixChainOrder(p,n):
	i = 1
	j = n - 1
	return matrixChainMemoised(p, i, j)

# Driver Code
arr = [1, 2, 3, 4]
n = len(arr)
print("Minimum number of multiplications is",MatrixChainOrder(arr, n))

# This code is contributed by rag2127


==========================================================================================================================================

-- partition problem 
-- https://www.geeksforgeeks.org/partition-problem-dp-18/

===============================================================================================================================================

min no of cuts 

-- https://www.youtube.com/watch?v=xwomavsC86c&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=51

===================================================================================================================

max rectangle area of 1

-- https://www.youtube.com/watch?v=tOylVCugy9k&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=56
        
=====================================================================================================================================================

-- scrambled strings

-- https://www.geeksforgeeks.org/check-if-a-string-is-a-scrambled-form-of-another-string/
-- https://www.programiz.com/python-programming/online-compiler/
-- https://leetcode.com/problems/scramble-string/
-- https://leetcode.com/problems/scramble-string/discuss/29452/Python-dp-solutions-(with-and-without-memorization).

# Python3 program to check if a
# given string is a scrambled
# form of another string
def isScramble(S1: str, S2: str):
	
	# Strings of non-equal length
	# cant' be scramble strings
	if len(S1) != len(S2):
		return False

	n = len(S1)

	# Empty strings are scramble strings
	if not n:
		return True

	# Equal strings are scramble strings
	if S1 == S2:
		return True

	# Check for the condition of anagram
	if sorted(S1) != sorted(S2):
		return False

	for i in range(1, n):
		
		# Check if S2[0...i] is a scrambled
		# string of S1[0...i] and if S2[i+1...n]
		# is a scrambled string of S1[i+1...n]
		if (isScramble(S1[:i], S2[:i]) and
			isScramble(S1[i:], S2[i:])):
			return True

		# Check if S2[0...i] is a scrambled
		# string of S1[n-i...n] and S2[i+1...n]
		# is a scramble string of S1[0...n-i-1]
		if (isScramble(S1[-i:], S2[:i]) and
			isScramble(S1[:-i], S2[i:])):
			return True

	# If none of the above
	# conditions are satisfied
	return False

# Driver Code
if __name__ == "__main__":
	
	S1 = "coder"
	S2 = "ocred"
	
	if (isScramble(S1, S2)):
		print("Yes")
	else:
		print("No")

# This code is contributed by sgshah2


-- 

# DP with memorization refer this
def __init__(self):
    self.dic = {}
    
def isScramble(self, s1, s2):
    if (s1, s2) in self.dic:
        return self.dic[(s1, s2)]
    if len(s1) != len(s2) or sorted(s1) != sorted(s2): # prunning
        self.dic[(s1, s2)] = False
        return False
    if s1 == s2:
        self.dic[(s1, s2)] = True
        return True

	# due to partition go from 1 to n
    for i in range(1, len(s1)):
        if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \
        (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):
            return True
    self.dic[(s1, s2)] = False
    return False


=== 

class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2): return False
        if s1==s2: return True
        @lru_cache(None)
        def solve(s1,s2):
            n=len(s1)
            if s1==s2: return True
            if n<=1: return False
            flag=False
            for i in range(1,n):
                cond1=solve(s1[:i],s2[:i]) and solve(s1[i:],s2[i:])
                cond2=solve(s1[:i],s2[n-i:]) and solve(s1[i:],s2[:n-i])
                if cond1 or cond2:
                    flag=True
                    break
            return flag
        return solve(s1,s2)


-- example use in programiz

s1 = "greatest"
s2 = "rgeatest"
i = 3            
            
# Check if S2[0...i] is a scrambled
# string of S1[n-i...n] and S2[i+1...n]
# is a scramble string of S1[0...n-i-1]


#    s1 [n-i to n] and s2[0 to i] 
print(s1[-i:],"to",s2[:i])
#    s1[0 to n-i-1] to s2[i+1 to n]
print(s1[:-i],"to",s2[i:])
========================================================================================================================================

        
-- egg drop problem

-- https://www.interviewbit.com/blog/egg-dropping-puzzle/
-- https://medium.com/@parv51199/egg-drop-problem-using-dynamic-programming-e22f67a1a7c3
-- https://leetcode.com/problems/super-egg-drop/
-- https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/



INT_MAX = 32767
def eggDrop(n, k):
    eggFloor = [[0 for x in range(k + 1)] for x in range(n + 1)]
 
    for i in range(1, n + 1):
        eggFloor[i][1] = 1
        eggFloor[i][0] = 0
 
    for j in range(1, k + 1):
        eggFloor[1][j] = j
 
    for i in range(2, n + 1):
        for j in range(2, k + 1):
            eggFloor[i][j] = INT_MAX
            for x in range(1, j + 1):
                res = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x])
                if res < eggFloor[i][j]:
                    eggFloor[i][j] = res
 
    return eggFloor[n][k]

--

================================================================================================================================================================

-- Max Value of k coins from piles

-- https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/
-- leetcode weekly contest 286


--
class Solution(object):
    def maxValueOfCoins(self, piles, k):
        
        # from n piles pick atmost k coins which pick min(k, len(piles[i]))
        # piles can be picked one by one not separately
        
        # https://www.youtube.com/watch?v=A98psR_mIMQ&t=1004s
        # pick and not pick startery using recursion and dp
        
        # f(ind + 1, k - (i+1))
        #               remaining number of guys
        
        # ans = sum(o to i) + f(ind + 1, k-(i+1))
        #dp = [[-1]* (k+1)] * (len(piles))
        '''
        k = 2
        p = [[1,100,3],[7,8,9]]
        dp = [[-1]* (k+1)] * (len(p))
        dp2 = [[-1]*(k+1) for _ in range(len(p))]
        print(dp)
        print(dp2)
        '''
        
        dp = [[-1]*(k+1) for _ in range(len(piles))]
        return self.f(0, k, piles, dp)
        
    def f(self, ind, k, piles, dp):
        if ind == len(piles) or k == 0:
            return 0
        
        if dp[ind][k] != -1:
            return dp[ind][k]
        
        best = self.f(ind+1, k, piles, dp) # not picking
        
        pilesSum = 0
        loopTill = len(piles[ind])
        for i in range(min(loopTill, k)):
            pilesSum += piles[ind][i]
             # picking element and sending the remaining elements
            best = max(best, pilesSum + self.f(ind+1, k-(i+1), piles, dp))
            
        dp[ind][k] = best
        return dp[ind][k]
--


==========================================================================================================================================


-- Longest repeating subsequence (interviewbit)

-- https://www.interviewbit.com/problems/repeating-subsequence/
-- https://www.geeksforgeeks.org/longest-repeating-subsequence/


--
# Python 3 program to find the longest repeating
# subsequence


# This function mainly returns LCS(str, str)
# with a condition that same characters at
# same index are not considered.
def findLongestRepeatingSubSeq( str):

	n = len(str)

	# Create and initialize DP table
	dp=[[0 for i in range(n+1)] for j in range(n+1)]

	# Fill dp table (similar to LCS loops)
	for i in range(1,n+1):
		for j in range(1,n+1):
			# If characters match and indexes are
			# not same
			if (str[i-1] == str[j-1] and i != j):
				dp[i][j] = 1 + dp[i-1][j-1]		
						
			# If characters do not match
			else:
				dp[i][j] = max(dp[i][j-1], dp[i-1][j])
		
	
	return dp[n][n]


# Driver Program
if __name__=='__main__':
	str = "aabb"
	print("The length of the largest subsequence that repeats itself is : "
		,findLongestRepeatingSubSeq(str))

# this code is contributed by ash264

--

--
class Solution:
    # @param A : string
    # @return an integer
    def anytwo(self, A):
        n = len(A)
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        #dp = [[0] *(n+1)] * (n+1)
        
        for i in range(1, n+1):
            for j in range(1, n+1):
                if A[i-1] == A[j-1] and i != j:
                    dp[i][j] = 1 + dp[i-1][j-1]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return 1 if dp[n][n] > 1 else 0
--

===================================================================================================================================================


-- Distinct Subsequences

-- https://www.interviewbit.com/problems/distinct-subsequences/
-- https://leetcode.com/problems/distinct-subsequences/submissions/
-- https://www.youtube.com/watch?v=aV-OEO-eNJQ

--

class Solution:
    # @param A : string
    # @param B : string
    # @return an integer

	# refer this 
    def numDistinct(self, A, B):
        m = len(A)
        n = len(B)
        dp=[[0 for i in range(m+1)] for j in range(n+1)]
        
        for i in range(m+1):
            dp[0][i] = 1
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                if A[j-1] == B[i-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[n][m] 
                


    def numDistinct1(self, A, B):
        # recursive approach for the upper dp Solution
        
        n = len(A)
        m = len(B)
        i = 0 # index for A
        j = 0  # index for B
        dp=[[0 for i in range(m+1)] for j in range(n+1)]
        
        def sol(A, B, n, m, i, j):
            if i == n: # A ="" and B is not empty
                return 0
            if j == m: # here B = "" and A is not empty
                return 1
            if A[i] == B[j]:
                # consider i+1 and j+1  + not consider i + 1
                return dp[i][j] = sol(A, B, n, m, i+1, j+1) +
                                    sol(A, B, n, m, i+1, j)
            
            # then just move i
            else:
                return dp[i][j] = sol(A, B, n, m, i+1, j)
        
        return sol(A, B, n, m, i, j)

--


======================================================================================================================================

-- Regular expression

-- https://leetcode.com/problems/regular-expression-matching/
-- https://leetcode.com/problems/wildcard-matching/discuss/256025/Python-DP-with-illustration
-- https://www.interviewbit.com/problems/regular-expression-ii/hints/


--

class Solution:
    def regex_helper(self,A,B,m,n):
        if m < 0 and n < 0: return 1
        if m < 0 and n >= 0: return 0
        if m >= 0 and n < 0: return 0
        if B[n] != '.' and B[n] != '*':
            if A[m] != B[n]:
                return 0
            else:
                return self.regex_helper(A,B,m-1,n-1)
        elif B[n] == '.':
            # consider A[m] and B[n] matched
            return self.regex_helper(A,B,m-1,n-1)
        elif B[n] == '*':
            if n <= 0: return 0
            if B[n-1] == '.': 
                return 1
            else:
                if A[m] != B[n-1]:
                    return self.regex_helper(A,B,m,n-2)
                while A[m] == B[n-1]:
                    if m == 0: return 1
                    m -= 1
                return self.regex_helper(A,B,m,n-2)

    # @param s : string
    # @param p : string
    # @return an integer
    def isMatch(self, s, p):
        return self.regex_helper(s,p,len(s)-1,len(p)-1)

--

--
def isMatch(self, text, pattern):
        n = len(pattern)
        m = len(text)
        dp = [[-1 for k in range(m+1)] for l in range(n+1)]
        # go from right to left
        # from n-1 to 0

        def solve(i, j, pattern, text, dp):
            if i<0 and j<0:
                return True
            if i < 0 and j >= 0:
                return False
            if j<0 and i>= 0:
                for u in range(i,-1,-1):
                    if pattern[u] != "*":
                        return False
                return True
            if dp[i][j] != -1: return dp[i][j]
            if (pattern[i] == text[j] or pattern[i] == "."):
                #then shrink the string
                dp[i][j] = solve(i-1,j-1,pattern,text,dp)
                return dp[i][j]
            if (pattern[i] == "*"):
                dp[i][j] = solve(i,j-1,pattern,text,dp) or solve(i-1,j,pattern,text,dp)
                return dp[i][j]
            dp[i][j] = False
            return dp[i][j]
        
        return 1 if solve(n-1, m-1, pattern, text, dp) == True else 0
--
===========================================================================================================================================================

-- Interleaving Strings

-- https://www.youtube.com/watch?v=jaQF6FSWYdE
-- https://www.geeksforgeeks.org/find-if-a-string-is-interleaved-of-two-other-strings-dp-33/
-- https://leetcode.com/problems/interleaving-string/submissions/
-- https://www.interviewbit.com/problems/interleaving-strings/
-- (important) => https://leetcode.com/problems/interleaving-string/discuss/31885/Python-DP-solutions-(O(m*n)-O(n)-space)-BFS-DFS.


--
class Solution(object):
    def isInterleave1(self, s1, s2, s3):
        # recursive approach
        if len(s1) + len(s2) != len(s3):
            return False
        n = len(s1)
        m = len(s2)
        l = len(s3)
        dp = [[-1]*(m+1)]*(n+1)
        
        def sol(s1, s2, s3, n, m, l):
            if l == 0:
                return 1
            
            if dp[n][m] != -1:
                return dp[n][m]
            goStringOne = 0
            goStringTwo = 0
            if n-1 >= 0 and s1[n-1] == s3[l-1]:
                goStringOne = sol(s1, s2, s3, n-1, m, l-1)
            if m -1 >= 0 and s2[m-1] == s3[l-1]:
                goStringTwo = sol(s1, s2, s3, n, m-1, l-1)
            
            dp[n][m] = goStringOne or goStringTwo
            return dp[n][m]
        
        return sol(s1, s2, s3, n, m, l)
    
	# refer this
    def isInterleave(self, s1, s2, s3):
        r, c, l= len(s1), len(s2), len(s3)
        if r+c != l:
            return False
        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]
        
        for i in xrange(1, r+1):
            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]
        for j in xrange(1, c+1):
            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]
            
        a = True
        b = True
        for i in xrange(1, r+1):
            for j in xrange(1, c+1):
                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or (dp[i][j-1] and s2[j-1] == s3[i-1+j])
        return dp[-1][-1]


-- refer this for understanding
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        if len(s1) + len(s2) != len(s3):
            return False

        def dfs(i, j):
            if i == len(s1) and j == len(s2):
                return True
            choose_s1, choose_s2 = False, False
            if i < len(s1) and s1[i] == s3[i + j]:
                choose_s1 = dfs(i + 1, j)
            if j < len(s2) and s2[j] == s3[i + j]:
                choose_s2 = dfs(i, j + 1)

            return choose_s1 or choose_s2

        return dfs(0, 0)
--
--
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m, n = len(s1), len(s2)
        if m + n != len(s3):
            return False
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for i in range(1, m + 1):
            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                choose_s1, choose_s2 = False, False
                if s1[i - 1] == s3[i + j - 1]:
                    choose_s1 = dp[i - 1][j]
                if s2[j - 1] == s3[i + j - 1]:
                    choose_s2 = dp[i][j - 1]
                dp[i][j] = choose_s1 or choose_s2

        return dp[m][n]
--

================================================================================================================

-- shortest common supersequence and also printing

-- https://www.interviewbit.com/problems/shortest-common-superstring/hints/
-- https://www.geeksforgeeks.org/print-shortest-common-supersequence/#:~:text=Given%20two%20strings%20X%20and,print%20any%20one%20of%20them.&text=Recommended%3A%20Please%20try%20your%20approach,moving%20on%20to%20the%20solution.
-- https://leetcode.com/problems/find-the-shortest-superstring/
-- https://www.geeksforgeeks.org/print-shortest-common-supersequence/

--
# A dynamic programming based Python3 program print
# shortest supersequence of two strings

# returns shortest supersequence of X and Y
def printShortestSuperSeq(m, n, x, y):

	# dp[i][j] contains length of shortest
	# supersequence for X[0..i-1] and Y[0..j-1]
	dp = [[0 for i in range(n + 1)]
			for j in range(m + 1)]

	# Fill table in bottom up manner
	for i in range(m + 1):
		for j in range(n + 1):

			# Below steps follow recurrence relation
			if i == 0:
				dp[i][j] = j
			elif j == 0:
				dp[i][j] = i
			elif x[i - 1] == y[j - 1]:
				dp[i][j] = 1 + dp[i - 1][j - 1]
			else:
				dp[i][j] = 1 + min(dp[i - 1][j],
								dp[i][j - 1])

	# Following code is used to print
	# shortest supersequence

	# dp[m][n] stores the length of the
	# shortest supersequence of X and Y

	# string to store the shortest supersequence
	string = ""

	# Start from the bottom right corner and
	# add the characters to the output string
	i = m
	j = n
	while i * j > 0:

		# If current character in X and Y are same,
		# then current character is part of
		# shortest supersequence
		if x[i - 1] == y[j - 1]:

			# Put current character in result
			string = x[i - 1] + string

			# reduce values of i, j and index
			i -= 1
			j -= 1

		# If current character in X and Y are different
		elif dp[i - 1][j] > dp[i][j - 1]:

			# Put current character of Y in result
			string = y[j - 1] + string

			# reduce values of j and index
			j -= 1
		else:

			# Put current character of X in result
			string = x[i - 1] + string

			# reduce values of i and index
			i -= 1

	# If Y reaches its end, put remaining characters
	# of X in the result string
	while i > 0:
		string = x[i - 1] + string
		i -= 1

	# If X reaches its end, put remaining characters
	# of Y in the result string
	while j > 0:
		string = y[j - 1] + string
		j -= 1

	return string

# Driver Code
if __name__ == "__main__":
	x = "GXTXAYB"
	y = "AGGTAB"
	m = len(x)
	n = len(y)
	
	# Take the smaller string as x and larger one as y
	if m > n:
	x, y = y, x
	m, n = n, m
	
	print(*printShortestSuperSeq(m, n, x, y))

# This code is contributed by
# sanjeev2552

        
--

====================================================================================================================

-- Subset sum


-- https://www.geeksforgeeks.org/subset-sum-problem-dp-25/
-- https://www.interviewbit.com/problems/subset-sum-problem/hints/
-- https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1


--
class Solution:
    # @param A : list of integers
    # @param B : integer
    # @return an integer
    def solve(self, A, B):
        n = len(A)
        #dp = [[None] * (B+1)] * (n+1)
        dp = [[None]*(B+1) for _ in range(n+1)]
        dp[0][0] = True
        
        for i in range(1, n+1):
            dp[i][0] = True
        for j in range(1, B+1):
            dp[0][j] = False
        for i in range(1, n+1):
            for j in range(1, B+1):
                if A[i-1] <= j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j - A[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return 1 if dp[n][B] else 0
                    
--
============================================================================================================================

-- Partition Equal subset sum

-- https://leetcode.com/problems/partition-equal-subset-sum/submissions/
-- 

--
class Solution(object):
    def canPartition(self, nums):
        csum = 0
        for i in range(len(nums)):
            csum += nums[i]
        if csum % 2:
            return False
        
        return self.solve(nums, (csum // 2))
    def solve(self, A, B):
        n = len(A)
        #dp = [[None] * (B+1)] * (n+1)
        dp = [[None]*(B+1) for _ in range(n+1)]
        dp[0][0] = True
        
        for i in range(1, n+1):
            dp[i][0] = True
        for j in range(1, B+1):
            dp[0][j] = False
        for i in range(1, n+1):
            for j in range(1, B+1):
                if A[i-1] <= j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j - A[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return 1 if dp[n][B] else 0
--

==========================================================================================================================================

-- Tushars birthday party

-- https://www.interviewbit.com/problems/tushars-birthday-party/
-- https://www.youtube.com/watch?v=ij0R4p5CjMw&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=15


--
class Solution:
    # @param A : tuple of integers
    # @param B : tuple of integers
    # @param C : tuple of integers
    # @return an integer
    def solve(self, A, B, C):
        
        # take max of friends capacity as dp length
        # take 1d array
        dp = [float("inf")] * (max(A)+1)
        dp[0] = 0 # coz colorie of 0 takes cost 0
        n = max(A)
        # i => colorie
        # j = cost
        
        for i in range(1, n+1):
            for j in range(0, len(B)):
                if B[j] <= i:
                    dp[i] = min(dp[i], C[j] + dp[i-B[j]])
                
        ans = 0
        for i in range(len(A)):
            ans += dp[A[i]]
        return ans
            
-- 

============================================================================================================================================

-- shortest supersequence

-- https://leetcode.com/problems/shortest-common-supersequence/submissions/

-- 
class Solution(object):
    def shortestCommonSupersequence(self, s1, s2):
        
        l1 = len(s1)
        l2 = len(s2)
        mx = 0
        res = []
        dp = [[0 for k in range(l2+1)] for l in range(l1+1)]
        for i in range(1,l1+1):
            for j in range(1,l2+1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    mx = max(mx, dp[i][j])
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])
        
        i = l1
        j = l2
        while i > 0 and j > 0:
            if s1[i-1] == s2[j-1]:
                res.append(s1[i-1])
                i-=1
                j-=1
            else:
                if dp[i-1][j] > dp[i][j-1]:
                    res.append(s1[i-1])
                    i-=1
                else:
                    res.append(s2[j-1])
                    j-=1
            
        while(i>0):
            res.append(s1[i-1])
            i-=1
        while(j>0):
            res.append(s2[j-1])
            j-=1
        res = res[::-1]
        return res
--

==============================================================================================================================

-- Kingdom war

-- https://www.interviewbit.com/problems/kingdom-war/
-- https://www.youtube.com/watch?v=lInhOSvjg6E&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=1


--
class Solution:
    # @param A : list of list of integers
    # @return an integer
    def solve(self, A):
        # https://www.youtube.com/watch?v=lInhOSvjg6E&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=1
        # reverse dp from bottom
        
        n = len(A)
        m = len(A[0])
        
        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
        ans = float("-inf")
        for i in range(n, -1, -1):
            for j in range(m, -1, -1):
                if i == n or j == m:
                    continue
                # also take current  cell value
                dp[i][j] = A[i][j] + dp[i+1][j] + dp[i][j+1] - dp[i+1][j+1]
                ans = max(ans, dp[i][j])
        return ans
--


=====================================================================================================================================================


-- Max sum without adjacent elements

-- https://www.youtube.com/watch?v=sMQf92ikq8s&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=2
-- https://www.interviewbit.com/problems/max-sum-without-adjacent-elements/


--
class Solution:
    # @param A : list of list of integers
    # @return an integer
    def adjacent(self, A):
        n = len(A[0]) # number of columns
        
        # cal the sum for every column ans take max
        ans = float("-inf")
        dp = [0] * (n+1)
        dp[0] = max(A[0][0], A[1][0])
        #dp[1] = max(dp[0], max(A[0][1], A[1][1]))
        
        for i in range(1, n):
            dp[i] = max(dp[i-1], max(A[0][i], A[1][i]) + dp[i-2])
        
        return dp[n-1]
        

	# without using dp
    def adjacent(self, A):
        n = len(A[0]) # number of columns
        
        # cal the sum for every column ans take max
        ans = float("-inf")
        #dp = [0] * (n+1)
        if n == 1: return max(A[0][0], A[1][0])
        A[0][0] = max(A[0][0], A[1][0])
        A[0][1] = max(A[0][0], max(A[0][1], A[1][1]))
        
        for i in range(2, n):
            A[0][i] = max(A[0][i-1], max(A[0][i], A[1][i]) + A[0][i-2])
        
        return A[0][n-1]
--

==================================================================================================================================

-- Best time to Buy and sell stock atmost k transactions allowed

-- https://www.interviewbit.com/problems/best-time-to-buy-and-sell-stock-atmost-b-times/
-- https://www.youtube.com/watch?v=j48AzIpO5Os&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=3




-- 
class Solution:
    # @param A : list of integers
    # @param B : integer
    # @return an integer
    
    # initialization for first row all 0s coz k =0 transactions
    # and first column to 0s coz in first day only buying no profit so 0s
    
    def solve(self, A, B):
        # B is no. of transactions
        n = len(A)
        dp = [[0] * (n+1)] * (B+1)
        if n <= 1:
            return 0
        
        if B > len(A): 
            B = len(A)
        
        for i in range(1, B+1):
            var = -A[0] + dp[i-1][0]
            for j in range(1, n):
                for prevj in range(1, j):
                    var = max(var, -A[prevj] + dp[i-1][prevj])
                
                dp[i][j] = max(A[j] + var, dp[i][j-1])
        
        return dp[B][n-1]
--
========================================================================================================================================

-- Maximal square

-- https://leetcode.com/problems/maximal-square/discuss/600149/Python-Thinking-Process-Diagrams-DP-Approach
-- https://leetcode.com/problems/maximal-square/submissions/
-- https://www.interviewbit.com/problems/maximum-size-square-sub-matrix/
-- https://www.youtube.com/watch?v=nZAyRZC8tko&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=4

--
class Solution:
    # @param A : list of list of integers
    # @return an integer
    # https://www.youtube.com/watch?v=nZAyRZC8tko&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=4
    def solve(self, A):
        # take min of
        # from left
        # from top
        # from diaginal left
        n = len(A)
        m = len(A[0])
        # no need for extra +1 here
        dp = [[0 for _ in range(m)] for _ in range(n)]
        ans = 0
        for i in range(n):
            for j in range(m):
                if i == 0 or j ==0:
                    if A[i][j]:
                        dp[i][j] = 1
                elif A[i][j]:
                    dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))
                ans = max(ans, dp[i][j])
        return (ans*ans)  

--
--

class Solution(object):
    def maximalSquare(self, A):
        # take min of
        # from left
        # from top
        # from diaginal left
        n = len(A)
        m = len(A[0])
        # no need for extra +1 here
        dp = [[0 for _ in range(m)] for _ in range(n)]
        ans = 0
        for i in range(n):
            for j in range(m):
                if i == 0 or j ==0:
                    if A[i][j] == "1":
                        dp[i][j] = 1
                elif A[i][j] == "1":
                    dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))
                ans = max(ans, dp[i][j])
        return (ans*ans) 
        
--

=====================================================================================================================================================================

-- Minimum absolute diff

-- https://leetcode.com/problems/minimum-absolute-difference/

--
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        c=abs(arr[0]-arr[1])
        for i in range(len(arr)-1):
            c=min(c,abs(arr[i]-arr[i+1]))
        l=0
        z=[]
        while l<len(arr)-1:
            if abs(arr[l]-arr[l+1])==c:
                z.append([arr[l],arr[l+1]])
            l+=1
        return z
--


============================================================================================================================================================

-- Minimum diff subsets


-- https://www.interviewbit.com/problems/minimum-difference-subsets/

--
class Solution:
    # @param A : list of integers
    # @return an integer
    def solve(self, A):
        # S1 - S2 = min
        # S1 + S2 = max
        # min = 0 and max = sum(A)
        
        n = len(A)
        B = 0
        for i in range(n):
            B += A[i] 
            
        #dp = [[None] * (B+1)] * (n+1)
        dp = [[False]*(B+1) for _ in range(n+1)]
        dp[0][0] = True
        
        for i in range(1, n+1):
            dp[i][0] = True
        for j in range(1, B+1):
            dp[0][j] = False
        for i in range(1, n+1):
            for j in range(1, B+1):
                if A[i-1] <= j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j - A[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
                    
                    
        # only take the last whole row
        mini = float("inf")
        for i in range((B//2)+1):
            if dp[n][i] == True:
                mini = max(mini, B-(2*i))
        return mini
--

=========================================================================================================================================\\

-- Ugly number

-- https://leetcode.com/problems/ugly-number-ii/submissions/
-- https://www.youtube.com/watch?v=X5SuOsIWCoI&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=11

-- 
class Solution(object):
    def nthUglyNumber(self, n):
        
        dp = [None] * n
        
        dp[0] = 1
        # take three pointer for 2 3 and 5
        p1, p2, p3 = 0, 0, 0
        for i in range(1, n):
            twomul = dp[p1] * 2
            threemul = dp[p2] * 3
            fivemul = dp[p3] * 5
            
            dp[i] = min(twomul, min(threemul, fivemul))
            if dp[i] == twomul: p1 += 1
            if dp[i] == threemul: p2 += 1
            if dp[i] == fivemul: p3 += 1
        
        return dp[n-1]
--

=============================================================================================================================================

-- Minimum Number of removals


-- https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/submissions/
-- https://www.youtube.com/watch?v=nW4Kx41G7XE&list=PLLT4EuYB4kIY_DWiiFY_TW3Egm9pmZPuS&index=13
-- https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/2337849/or-Python-or-Easy-Longest-Bitonic-Sequence-O(N2)-or-Fast-Binary-Search-O(Nlog(N))


--
def minimumMountainRemovals(self, nums):
		n = len(nums)
		len1 = [1]
		left = [nums[0]]
		for i in range(1,n):
			if nums[i] > left[-1]:
				left.append(nums[i])
				len1.append(len1[-1]+1)
			else:
				left[bisect_left(left,nums[i])] = nums[i]
				len1.append(len1[-1])


		len2 = [1]
		ans = 0
		right = [nums[-1]]
		for i in range(n-2,-1,-1):
			if nums[i] > right[-1]:
				right.append(nums[i])
				len2.append(len2[-1]+1)
			else:
				right[bisect_left(right,nums[i])] = nums[i]
				len2.append(len2[-1])
			if len1[i]>1 and len2[n-1-i]>1:
				ans = max(ans,len1[i]+len2[n-1-i]-1)

		return n-ans

--

==========================================================================================================================================================

-- Unique BST

-- https://www.interviewbit.com/problems/unique-binary-search-trees-ii/
-- https://leetcode.com/problems/unique-binary-search-trees/submissions/
-- https://leetcode.com/problems/unique-binary-search-trees/discuss/703644/PythonEasy-DP-Solution-Explained-By-Someone-Who-Used-To-Struggle-To-Understand-DP


--
class Solution(object):
    def numTrees(self, A):
        dp = [0] * (A+1)
        dp[0] = 1 # for n = 0
        dp[1] = 1 # for n = 1
        #dp[2] = 2 # for n = 2
        # for every num cal the number of value greater 
        # than and lesser than num
        for i in range(2, A+1):
            csum = 0
            for j in range(1, i+1):
            # i-1 numbers are smaller than
                leftBST = dp[j-1]
                rightBST = dp[i-j]
                csum += leftBST * rightBST
                
            dp[i] = csum
        return dp[A]
        
--

================================================================================================================================================================================

-- decode ways

-- https://leetcode.com/problems/decode-ways/discuss/608268/Python-Thinking-process-diagram-(DP-%2B-DFS)
-- https://leetcode.com/problems/decode-ways/
-- https://leetcode.com/problems/decode-ways/discuss/253018/Python%3A-Easy-to-understand-explanation-bottom-up-dynamic-programming

--
def numDecodings(self, s):
        if len(s) == 0 or s is None:
            return 0

        @lru_cache(maxsize=None)
        def dfs(string):
            if len(string)>0:
                if string[0] == '0':
                    return 0
            if string == "" or len(string) == 1:
                return 1
            if int(string[0:2]) <= 26:
                first = dfs(string[1:])
                second = dfs(string[2:])
                return first+second
            else:
                return dfs(string[1:])

        result_sum = dfs(s)

        return result_sum

## optimized

def numDecodings(self, s): 
        if not s:
            return 0

        dp = [0 for x in range(len(s) + 1)] 

        # base case initialization
        dp[0] = 1 
        dp[1] = 0 if s[0] == "0" else 1   #(1)

        for i in range(2, len(s) + 1): 
            # One step jump
            if 0 < int(s[i-1:i]) <= 9:    #(2)
                dp[i] += dp[i - 1]
            # Two step jump
            if 10 <= int(s[i-2:i]) <= 26: #(3)
                dp[i] += dp[i - 2]
        return dp[len(s)]
--

=================================================================================================================================================================

-- Consecutive ones not allowed

-- https://leetcode.com/discuss/general-discussion/1287402/count-number-of-binary-strings-without-consecutive-1s


-- 