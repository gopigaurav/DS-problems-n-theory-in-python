=== Nearest greater element to right ================================

# Python program to print next greater element using stack

# Stack Functions to be used by printNGE()


def createStack():
	stack = []
	return stack


def isEmpty(stack):
	return len(stack) == 0


def push(stack, x):
	stack.append(x)


def pop(stack):
	if isEmpty(stack):
		print("Error : stack underflow")
	else:
		return stack.pop()


'''prints element and NGE pair for all elements of
arr[] '''


def printNGE(arr):
	s = createStack()
	element = 0
	next = 0

	# push the first element to stack
	push(s, arr[0])

	# iterate for rest of the elements
	for i in range(1, len(arr), 1):
		next = arr[i]

		if isEmpty(s) == False:

			# if stack is not empty, then pop an element from stack
			element = pop(s)

			'''If the popped element is smaller than next, then
				a) print the pair
				b) keep popping while elements are smaller and
				stack is not empty '''
			while element < next:
				print(str(element) + " -- " + str(next))
				if isEmpty(s) == True:
					break
				element = pop(s)

			'''If element is greater than next, then push
			the element back '''
			if element > next:
				push(s, element)

		'''push next to stack so that we can find
		next greater for it '''
		push(s, next)

	'''After iterating over the loop, the remaining
	elements in stack do not have the next greater
	element, so print -1 for them '''

	while isEmpty(s) == False:
		element = pop(s)
		next = -1
		print(str(element) + " -- " + str(next))


# Driver code
arr = [11, 13, 21, 3]
printNGE(arr)

# This code is contributed by Sunny Karira



============================== Next greater element in circular array ============================


# Function to find the Next Greater Element(NGE)
def printNGE(a, n):
    s = []
    ans = [0] * n
    for i in range(2 * n - 1, -1, -1):
        while s and a[i % n] >= s[-1]:
            s.pop()
        if i < n:
            if s:
                ans[i] = s[-1]
 
            else:
                ans[i] = -1
 
        s.append(a[i % n])
 
    for i in range(n):
        print(ans[i], end=" ")
 
 
# Driver Code
if __name__ == "__main__":
    # Given array arr[]
    arr = [8, 6, 7]
 
    N = len(arr)
 
    # Function call
    printNGE(arr, N)
================================================ Next Greater element without circular array ==================================================================
-- https://practice.geeksforgeeks.org/problems/next-larger-element-1587115620/1/
-- https://www.geeksforgeeks.org/next-greater-element/

def NextGreaterElement(arr):
    ans = []
    stack = []
    n = len(arr)
    s = len(stack)
    for i in range(n-1, -1, -1):
        print(i)
        if len(stack) == 0:
            ans.append(-1)
        elif len(stack) > 0 and stack[s-1] > arr[i]:
            ans.append(stack[s-1])
        elif stack[s-1] <= arr[i]:
            while len(stack) > 0 and stack[s-1] <= arr[i]:
                stack.pop()
            if len(stack) == 0:
                ans.append(-1)
            else:
                ans.append(stack[s-1])
        stack.append(arr[i])
    print(ans[::-1])
        
        
array = [3,2,1]
print(NextGreaterElement(array))

--

class Solution:
    def nextLargerElement(self,arr,n):
        stack =[]
        res = []
        
        for i in range(n-1,-1,-1):
            if not stack:
                res.append(-1)
            elif len(stack) > 0 and arr[i] < stack[-1]:
                res.append(stack[-1]) # dont pop it instead appedn the tp of stack element in the res
            elif arr[i] >= stack[-1]:
                while len(stack) > 0 and stack[-1] <= arr[i]:
                    stack.pop()
                if not stack:
                    res.append(-1)
                else:
                    res.append(stack[-1]) # dont pop it instead appedn the tp of stack element in the res
            stack.append(arr[i])
        
        return res[::-1]

--


========================================================= Nearest Samller to left =====================================================================

class Solution:
    # @param A : list of integers
    # @return a list of integers
    def prevSmaller(self, A):
        ans = []
        stack = []
        for i in range(0, len(A), 1): 
            while (stack!=[] and stack[len(stack) - 1]>=A[i]):
                stack.pop()
            if stack == []:
                ans.append(-1)
            else:
                ans.append(stack[- 1])
            
            stack.append(A[i])
        
        return ans

============================================================= Largest area in histogram ===================================================

class Solution:
    # @param A : list of integers
    # @return an integer
    def largestRectangleArea(self, A):
        stack = []
        n = len(A)
        ret = 0
        tp = -1
        area_with_top = -1
        i = 0
        while i < n:
            if len(stack) == 0 or A[i] >= A[stack[-1]]:
                stack.append(i)
                i += 1
            else:
                tp = stack.pop()
                area_with_top = A[tp]*(i if len(stack) == 0 else i - stack[-1] - 1)
                if ret < area_with_top:
                    ret = area_with_top
        while len(stack) != 0:
            tp = stack.pop()
            area_with_top = A[tp]*(i if len(stack) == 0 else i - stack[-1] - 1)
            if ret < area_with_top:
                ret = area_with_top
                
        return ret   

=================================================================== Valid paranthesis=================================
-- https://practice.geeksforgeeks.org/problems/valid-expression1025/1/
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

class Solution(object):
    def isValid(self, s):
        stack = []
        closeToOpen = { ")" : "(", "}": "{", "]" : "["}
        
        for i in s:
            if i in closeToOpen:
                if stack and stack[-1] == closeToOpen[i]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return True if not stack else False
        
==============================================================================================================================


-- Infix to prefix

-- https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/
-- https://practice.geeksforgeeks.org/problems/infix-to-postfix-1587115620/1/


--
# Python program to convert infix expression to postfix

# Class to convert the expression


class Conversion:

	# Constructor to initialize the class variables
	def __init__(self, capacity):
		self.top = -1
		self.capacity = capacity
		# This array is used a stack
		self.array = []
		# Precedence setting
		self.output = []
		self.precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}

	# check if the stack is empty
	def isEmpty(self):
		return True if self.top == -1 else False

	# Return the value of the top of the stack
	def peek(self):
		return self.array[-1]

	# Pop the element from the stack
	def pop(self):
		if not self.isEmpty():
			self.top -= 1
			return self.array.pop()
		else:
			return "$"

	# Push the element to the stack
	def push(self, op):
		self.top += 1
		self.array.append(op)

	# A utility function to check is the given character
	# is operand
	def isOperand(self, ch):
		return ch.isalpha()

	# Check if the precedence of operator is strictly
	# less than top of stack or not
	def notGreater(self, i):
		try:
			a = self.precedence[i]
			b = self.precedence[self.peek()]
			return True if a <= b else False
		except KeyError:
			return False

	# The main function that
	# converts given infix expression
	# to postfix expression
	def infixToPostfix(self, exp):

		# Iterate over the expression for conversion
		for i in exp:
			# If the character is an operand,
			# add it to output
			if self.isOperand(i):
				self.output.append(i)

			# If the character is an '(', push it to stack
			elif i == '(':
				self.push(i)

			# If the scanned character is an ')', pop and
			# output from the stack until and '(' is found
			elif i == ')':
				while((not self.isEmpty()) and
					self.peek() != '('):
					a = self.pop()
					self.output.append(a)
				if (not self.isEmpty() and self.peek() != '('):
					return -1
				else:
					self.pop()

			# An operator is encountered
			else:
				while(not self.isEmpty() and self.notGreater(i)):
						# this is to pass cases like a^b^c
					# without if ab^c^
					# with if abc^^
					if i == "^" and self.array[-1] == i:
						break
					self.output.append(self.pop())
				self.push(i)

		# pop all the operator from the stack
		while not self.isEmpty():
			self.output.append(self.pop())

		print "".join(self.output)


# Driver program to test above function
exp = "a+b*(c^d-e)^(f+g*h)-i"
obj = Conversion(len(exp))
obj.infixToPostfix(exp)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)


==============================================================================================================================================


-- Reduce the string

-- https://www.geeksforgeeks.org/reduce-the-string-by-removing-k-consecutive-identical-characters/


--
# Python3 implementation of the approach

# Pair class to store character and freq
class Pair:
	def __init__(self,c ,ctr):
		self.c= c
		self.ctr = ctr

class Solution:
	
	# Function to find the reduced string
	def reduced_String(self , k , s):
		
		#Base Case
		if (k == 1):
			return ""

		# Creating a stack of type Pair
		st = []
	
		# iterate through given string
		for i in range(len(s)):
			
			# if stack is empty then simply add the
			# character with count 1 else check if
			# character is same as top of stack
			if (len(st) == 0):
				st.append((Pair(s[i] , 1)))
				continue
				
			
			# if character at top of stack is same as
			# current character increase the number of
			# repetitions in the top of stack by 1
			if (st[-1].c == s[i]):
				
				pair = st.pop()
				pair.ctr +=1
				
				if (pair.ctr == k):
					continue
				
				else:
					st.append(pair)
	
			
			else:
				
				# if character at top of stack is not
				# same as current character push the
				# character along with count 1 into the
				# top of stack
				st.append((Pair(s[i] , 1)))
	
	
		# Iterate through the stack
		# Use string(int,char) in order to replicate the
		# character multiple times and convert into string
		# then add in front of output string
		ans = ""
		while(len(st) > 0):
			
			c = st[-1].c
			cnt = st[-1].ctr
			
			while(cnt >0):
				ans = c + ans
				cnt -= 1
			
			st.pop()
		
		return (ans)

# Driver code
if __name__ == "__main__":
	
	k = 2
	s = "geeksforgeeks"
	obj = Solution()
	print(obj.reduced_String(k,s))

	# This code is contributed by chantya17.


--

========================================================================================================================================================================

-- Stock span problem

-- https://www.geeksforgeeks.org/the-stock-span-problem/
-- https://practice.geeksforgeeks.org/problems/stock-span-problem-1587115621/1
-- https://www.youtube.com/watch?v=p9T-fE1g1pU

-- 

def calculateSpan(self,arr,n):
        s = []     
        ans = []
        for i in range(0,n):
             
            while(s != [] and a[s[-1]] <= a[i]):
                s.pop()
             
            if(s == []):
                ans.append(i+1)
             
            else:
                top = s[-1]
                ans.append(i - top)
            s.append(i)
     
        return ans
            


--

=====================================================================================================================================================================================

-- celebrity problem

-- https://www.geeksforgeeks.org/the-celebrity-problem/


