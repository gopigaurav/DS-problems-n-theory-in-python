
-- FInd the missing number


-- https://www.geeksforgeeks.org/problems/missing-number-in-array1416/1?page=1&company=Flipkart&sortBy=submissions
-- 

--
class Solution:
    def missingNumber(self,a,n):
        # code here
        
        total = n * (n + 1) // 2
        
        dif = total - sum(a)
        return dif
--


======================================================================================


-- jump game


-- https://leetcode.com/problems/jump-game/submissions/1240898979/
-- https://www.youtube.com/watch?v=EgMPjWliYGY

--
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        # We can do this in dp but also we can do this with greedy
        index = len(nums) - 1
        for i in range(len(nums) - 1, -1, -1):
            # plus index becoz u need to check with respect to index
            if nums[i] + i >= index:
                index = i

        if index == 0:
            return True
        return False
--


=======================================================================================

-- Min number of jumps to reach the end (Jump game 2)


-- https://www.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

--
#User function Template for python3
class Solution:
	def minJumps(self, arr, n):
	    #code here
	    
        # greedy approach
        
        farthest = 0
        cur = 0
        jumps = 0
        
        for i in range(n - 1):
            
            if arr[i] + i > farthest:
                farthest = arr[i] + i
            
            if i == cur:
                if farthest == cur:
                    return -1
                cur = farthest
                jumps += 1
            
        
            
        if len(arr) == 1:
            return 0
        
        if arr[0] == 0:
            return -1
        

        return jumps
--


==========================================================================================================

-- Find duplicates in array for O(N)

-- https://www.geeksforgeeks.org/problems/find-duplicates-in-an-array/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/


--
class Solution:
    def duplicates(self, arr, n): 
    	# code here
    	
    	result = []

        # Step 1: Iterate through the array to mark frequencies
        for i in range(len(arr)):
            # Calculate the index where the frequency needs to be stored
            index = arr[i] % len(arr)
            # Increment the value at the calculated index by n, marking the frequency
            arr[index] += len(arr)
        
        # Step 2: Traverse the modified array to find duplicate elements
        found = False
        for i in range(len(arr)):
            # Calculate the frequency of the current element
            if arr[i] // len(arr) > 1:
                # If frequency is greater than 1, add the index to the result list
                result.append(i)
                found = True
    
        # Step 3: If no duplicates found, add -1 to the result
        if not found:
            result.append(-1)
    
        return result
--

==================================================================================================================

-- Parenthesis Checker

-- https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

--
class Solution:
    
    #Function to check if brackets are balanced or not.
    def ispar(self,x):
        # code here
        
        possible_combination = { '}': '{', ']': '[', ')': '('}
        
        stack = []
        
        for i in range(len(x)):
            if x[i] in ['(', '[', '{']:
                stack.append(x[i])
            else:
                if stack and stack[-1] == possible_combination.get(x[i], 0):
                    stack.pop()
                else:
                    return False
        
        if not stack:
            return True
        return False
--

===============================================================================================================================

-- Check for BST


-- https://www.geeksforgeeks.org/problems/check-for-bst/1?page=1&company=Flipkart&sortBy=submissions
-- https://geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

--
class Solution:
    
    #Function to check whether a Binary Tree is BST or not.
    def isBST(self, root):
        #code here
        
        def dfs(node, mx_v, mi_v):
            
            if not node:
                return True
                
            if mi_v > node.data:
                return False
            
            if mx_v < node.data:
                return False
                
            return dfs(node.left, node.data - 1, mi_v) and dfs(node.right, mx_v, node.data - 1)
    
            
        
        return dfs(root, float("inf"), float("-inf"))
--


=======================================================================================================================================


-- Left view of the binary tree


-- https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-- Check the level of the and then input

--
def LeftView(root):
    
    # code here
    
    res = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(res):
            res.append(node.data)
        
        if node.left:
            dfs(node.left, level + 1)
        if node.right:
            dfs(node.right, level + 1)
        
        
    dfs(root, 0)
    return res
--


==========================================================================================================================================

-- Trapping water


-- https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=m18Hntz4go8


--
class Solution:
    def trappingWater(self, arr,n):
        #Code here
        
        # the logic is get the left most greater one which is greater than the current number
        # get the right most greater one which is greater than the current number
        
        # min(left[i], right[i]) - arr[i]
        
        # for this the better approach is to get the prefix array from left side and suffix array from right side
        
        # the optimal solution is using two pointer approach
        
        left = 0
        right = n - 1
        max_left = 0
        max_right = 0
        res = 0
        
        while left <= right:
            
            if arr[left] <= arr[right]:
                if arr[left] > max_left:
                    max_left = arr[left]
                    
                else:
                    res += max_left - arr[left]
                
                left += 1
                    
            else:
                if arr[right] > max_right:
                    max_right = arr[right]
                
                else:
                    res += max_right - arr[right]
                
                right += 1
        
        return res
--


======================================================================================================================

--  Count pairs of given sum


-- https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1?page=1&company=Flipkart&sortBy=submissions
--


--
from collections import defaultdict
class Solution:
    def getPairsCount(self, arr, n, sum):
        # code here

        unordered_map = {}
        count = 0
        for i in range(n):
            if sum - arr[i] in unordered_map:
                count += unordered_map[sum - arr[i]]
            if arr[i] in unordered_map:
                unordered_map[arr[i]] += 1
            else:
                unordered_map[arr[i]] = 1
        return count
--


===============================================================================================================================

-- boundary traversal of the binary tree


-- https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-
from collections import defaultdict

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def printBoundaryView(self, root):
        # Code here
        
        # method 1
        
        # Using recursion
        
        # first print left tree view excluding leaf
        # second print all the leaves
        # third print the right from bottom up approach
        res = [root.data]
        
        def printleft(node):
            
            if node:
            
                if node.left:
                    # only add it into the res if the either of the child is present
                    
                    res.append(node.data)
                    
                    printleft(node.left)
                    
                elif node.right:
                    
                    res.append(node.data)
                    
                    printleft(node.right)
        
        def printRight(node):
            
            if node:
                
                if node.right:
                    printRight(node.right)
                    res.append(node.data)
                    
                elif node.left:
                    
                    printRight(node.left)
                    res.append(node.data)
                
                
        
        def printLeaves(node):
            
            if node:
            
                printLeaves(node.left)
                
                if not node.left and not node.right:
                    res.append(root.data)
                
                printLeaves(node.right)
        
        printleft(root.left)
        
        printLeaves(root.left)
        printLeaves(root.right)
        
        printRight(root.right)
        
        return res
-

=========================================================================================================


-- find the middle element in linked list


-- https://www.geeksforgeeks.org/problems/finding-middle-element-in-a-linked-list/1?page=1&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        
        slow = head
        fast = head
        
        while fast and fast.next:
            
            slow = slow.next
            fast = fast.next.next
            

        return slow.data
--


===========================================================================================================


-- Maximum of all subarray


-- https://www.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1?page=2&company=Flipkart&sortBy=submissions
--

--
from collections import deque

class Solution:
    
    #Function to find maximum of each subarray of size k.
    def max_of_subarrays(self,arr,n,k):
        
        #code here
        q = deque()
        j = 0

        res = []
        
        i = 0
        j = 0
        
        while j < n:
            
            # check the queue if it is in decreasing order else pop the elements
            # since we want the next greater after popping the max element
            
            
            while q and q[-1] < arr[j]:
                q.pop()
            
            q.append(arr[j])
            

            
            if j - i + 1 < k:
                j += 1
            
            elif j - i + 1 == k:
                res.append(q[0])
                
                # get the answer and slide the window which mean i and j will be moved
                
                if arr[i] == q[0]:
                    q.popleft()
                
                i += 1
                j += 1
            
        return res
            
--


============================================================================================================

-- Anagrams


-- https://www.geeksforgeeks.org/problems/anagram-1587115620/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    
    #Function is to check whether two strings are anagram of each other or not.
    def isAnagram(self,a,b):
        #code here
        
        if len(a) != len(b):
            return False
        
        A = [0] * 26
        B = [0] * 26
        
        
        for i in range(len(a)):
            A[ord(a[i]) - ord("a")] += 1
            B[ord(b[i]) - ord("a")] += 1
        
        if A == B:
            return True
        return False
        
--


======================================================================================================

-- Spirally traversing a matrix


-- https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=BJnMZNwUk1M


--
class Solution:
    
    #Function to return a list of integers denoting spiral traversal of matrix.
    def spirallyTraverse(self,matrix, r, c): 
        # code here 
        
        left = 0
        right = c - 1
        top = 0
        bottom = r - 1
        res = []
        
        while left <= right and top <= bottom:
            
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            
            top += 1
            
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            
            right -= 1
            
            if top <= bottom:
                for i in range(right, left - 1, -1):
                    res.append(matrix[bottom][i])
                    
                bottom -= 1
            
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    res.append(matrix[i][left])
                
                left += 1
        
        return res
--


===================================================================================================================

-- Determine if two trees are identical


-- https://www.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to check if two trees are identical.
    def isIdentical(self,root1, root2):
        # Code here
        
        def dfs(node1, node2):
            if not node1 and not node2:
                return True
            
            if node1 and node2:
                if node1.data == node2.data and dfs(node1.left, node2.left) and dfs(node1.right, node2.right):
                    return True
            
            return False
        
        return 1 if dfs(root1, root2) else 0 
--

==============================================================================================================

-- Key pair


-- https://www.geeksforgeeks.org/problems/key-pair5616/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
	def hasArrayTwoCandidates1(self,arr, n, x):
		# code here
		m = {}
		
		for i in range(n):
		    m[arr[i]] = 1
		   
        
        for i in range(n):
            if abs(x - arr[i]) in m:
                return True
        
        return False
    
    def hasArrayTwoCandidates(self, arr, n, x):
        hashmap = {}

        for i in range(n):
            temp = x-arr[i]
            if (temp in hashmap):
                return 1
            hashmap[arr[i]] = i
        return 0
--



==============================================================================================================

-- Wave array 


-- https://www.geeksforgeeks.org/problems/wave-array-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/sort-array-wave-form-2/


--
from typing import List


class Solution:
    def convertToWave(self, n : int, arr : List[int]) -> None:
        # code here
        
        # Traverse all even elements
        for i in range(0, n - 1, 2):
     
            # If current even element is smaller than previous
            if (i > 0 and arr[i] < arr[i-1]):
                arr[i], arr[i-1] = arr[i-1], arr[i]
     
            # If current even element is smaller than next
            if (i < n-1 and arr[i] < arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                
        return arr
--


======================================================================================================


-- Add two numbers represented by linked lists


-- https://www.geeksforgeeks.org/problems/add-two-numbers-represented-by-linked-lists/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, num1, num2):
        # code here
        # return head of sum list
        
        carry = 0
        dummy = Node(0)
        temp = dummy
        
        z = True
        
        def reverse(node):
            if not node:
                return node
            
            cur = node
            prev = None
            nxt = node
            
            while cur:
                
                nxt = cur.next
                cur.next = prev
                prev = cur
                cur = nxt
            
            return prev
            
        num1 = reverse(num1)
        num2 = reverse(num2)        
        
        
        while num1 or num2 or carry:
            v1 = num1.data if num1 else 0
            v2 = num2.data if num2 else 0
            
            # calculate sum and carry
            csum = carry + v1 + v2
            carry = csum // 10
            
            if csum % 10 != 0 and z:
                z = False
            
            # create new node with the sum mod 10
            temp.next = Node(csum % 10)
            temp = temp.next
            
            # move to next nodes
            if num1:
                num1 = num1.next
            if num2:
                num2 = num2.next
        
        reversedHead = reverse(dummy.next)
        
    
        if z:
            return Node(0)
        
        while reversedHead and reversedHead.data == 0:
            reversedHead = reversedHead.next
        return reversedHead
        

        return reversedHead
--


===================================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=CiiXBvrX-5A&t=352s


--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
            
--


================================================================================================================




