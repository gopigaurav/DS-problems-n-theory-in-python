
-- FInd the missing number


-- https://www.geeksforgeeks.org/problems/missing-number-in-array1416/1?page=1&company=Flipkart&sortBy=submissions
-- 

--
class Solution:
    def missingNumber(self,a,n):
        # code here
        
        total = n * (n + 1) // 2
        
        dif = total - sum(a)
        return dif
--


======================================================================================


-- jump game


-- https://leetcode.com/problems/jump-game/submissions/1240898979/
-- https://www.youtube.com/watch?v=EgMPjWliYGY

--
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        # We can do this in dp but also we can do this with greedy
        index = len(nums) - 1
        for i in range(len(nums) - 1, -1, -1):
            # plus index becoz u need to check with respect to index
            if nums[i] + i >= index:
                index = i

        if index == 0:
            return True
        return False
--


=======================================================================================

-- Min number of jumps to reach the end (Jump game 2)


-- https://www.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

--
#User function Template for python3
class Solution:
	def minJumps(self, arr, n):
	    #code here
	    
        # greedy approach
        
        farthest = 0
        cur = 0
        jumps = 0
        
        for i in range(n - 1):
            
            if arr[i] + i > farthest:
                farthest = arr[i] + i
            
            if i == cur:
                if farthest == cur:
                    return -1
                cur = farthest
                jumps += 1
            
        
            
        if len(arr) == 1:
            return 0
        
        if arr[0] == 0:
            return -1
        

        return jumps
--


==========================================================================================================

-- Find duplicates in array for O(N)

-- https://www.geeksforgeeks.org/problems/find-duplicates-in-an-array/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/


--
class Solution:
    def duplicates(self, arr, n): 
    	# code here
    	
    	result = []

        # Step 1: Iterate through the array to mark frequencies
        for i in range(len(arr)):
            # Calculate the index where the frequency needs to be stored
            index = arr[i] % len(arr)
            # Increment the value at the calculated index by n, marking the frequency
            arr[index] += len(arr)
        
        # Step 2: Traverse the modified array to find duplicate elements
        found = False
        for i in range(len(arr)):
            # Calculate the frequency of the current element
            if arr[i] // len(arr) > 1:
                # If frequency is greater than 1, add the index to the result list
                result.append(i)
                found = True
    
        # Step 3: If no duplicates found, add -1 to the result
        if not found:
            result.append(-1)
    
        return result
--

==================================================================================================================

-- Parenthesis Checker

-- https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

--
class Solution:
    
    #Function to check if brackets are balanced or not.
    def ispar(self,x):
        # code here
        
        possible_combination = { '}': '{', ']': '[', ')': '('}
        
        stack = []
        
        for i in range(len(x)):
            if x[i] in ['(', '[', '{']:
                stack.append(x[i])
            else:
                if stack and stack[-1] == possible_combination.get(x[i], 0):
                    stack.pop()
                else:
                    return False
        
        if not stack:
            return True
        return False
--

===============================================================================================================================

-- Check for BST


-- https://www.geeksforgeeks.org/problems/check-for-bst/1?page=1&company=Flipkart&sortBy=submissions
-- https://geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

--
class Solution:
    
    #Function to check whether a Binary Tree is BST or not.
    def isBST(self, root):
        #code here
        
        def dfs(node, mx_v, mi_v):
            
            if not node:
                return True
                
            if mi_v > node.data:
                return False
            
            if mx_v < node.data:
                return False
                
            return dfs(node.left, node.data - 1, mi_v) and dfs(node.right, mx_v, node.data - 1)
    
            
        
        return dfs(root, float("inf"), float("-inf"))
--


=======================================================================================================================================


-- Left view of the binary tree


-- https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-- Check the level of the and then input

--
def LeftView(root):
    
    # code here
    
    res = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(res):
            res.append(node.data)
        
        if node.left:
            dfs(node.left, level + 1)
        if node.right:
            dfs(node.right, level + 1)
        
        
    dfs(root, 0)
    return res
--


==========================================================================================================================================

-- Trapping water


-- https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=m18Hntz4go8


--
class Solution:
    def trappingWater(self, arr,n):
        #Code here
        
        # the logic is get the left most greater one which is greater than the current number
        # get the right most greater one which is greater than the current number
        
        # min(left[i], right[i]) - arr[i]
        
        # for this the better approach is to get the prefix array from left side and suffix array from right side
        
        # the optimal solution is using two pointer approach
        
        left = 0
        right = n - 1
        max_left = 0
        max_right = 0
        res = 0
        
        while left <= right:
            
            if arr[left] <= arr[right]:
                if arr[left] > max_left:
                    max_left = arr[left]
                    
                else:
                    res += max_left - arr[left]
                
                left += 1
                    
            else:
                if arr[right] > max_right:
                    max_right = arr[right]
                
                else:
                    res += max_right - arr[right]
                
                right += 1
        
        return res
--


======================================================================================================================

--  Count pairs of given sum


-- https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1?page=1&company=Flipkart&sortBy=submissions
--


--
from collections import defaultdict
class Solution:
    def getPairsCount(self, arr, n, sum):
        # code here

        unordered_map = {}
        count = 0
        for i in range(n):
            if sum - arr[i] in unordered_map:
                count += unordered_map[sum - arr[i]]
            if arr[i] in unordered_map:
                unordered_map[arr[i]] += 1
            else:
                unordered_map[arr[i]] = 1
        return count
--


===============================================================================================================================

-- boundary traversal of the binary tree


-- https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-
from collections import defaultdict

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def printBoundaryView(self, root):
        # Code here
        
        # method 1
        
        # Using recursion
        
        # first print left tree view excluding leaf
        # second print all the leaves
        # third print the right from bottom up approach
        res = [root.data]
        
        def printleft(node):
            
            if node:
            
                if node.left:
                    # only add it into the res if the either of the child is present
                    
                    res.append(node.data)
                    
                    printleft(node.left)
                    
                elif node.right:
                    
                    res.append(node.data)
                    
                    printleft(node.right)
        
        def printRight(node):
            
            if node:
                
                if node.right:
                    printRight(node.right)
                    res.append(node.data)
                    
                elif node.left:
                    
                    printRight(node.left)
                    res.append(node.data)
                
                
        
        def printLeaves(node):
            
            if node:
            
                printLeaves(node.left)
                
                if not node.left and not node.right:
                    res.append(root.data)
                
                printLeaves(node.right)
        
        printleft(root.left)
        
        printLeaves(root.left)
        printLeaves(root.right)
        
        printRight(root.right)
        
        return res
-

=========================================================================================================


-- find the middle element in linked list


-- https://www.geeksforgeeks.org/problems/finding-middle-element-in-a-linked-list/1?page=1&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        
        slow = head
        fast = head
        
        while fast and fast.next:
            
            slow = slow.next
            fast = fast.next.next
            

        return slow.data
--


===========================================================================================================


-- Maximum of all subarray


-- https://www.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1?page=2&company=Flipkart&sortBy=submissions
--

--
from collections import deque

class Solution:
    
    #Function to find maximum of each subarray of size k.
    def max_of_subarrays(self,arr,n,k):
        
        #code here
        q = deque()
        j = 0

        res = []
        
        i = 0
        j = 0
        
        while j < n:
            
            # check the queue if it is in decreasing order else pop the elements
            # since we want the next greater after popping the max element
            
            
            while q and q[-1] < arr[j]:
                q.pop()
            
            q.append(arr[j])
            

            
            if j - i + 1 < k:
                j += 1
            
            elif j - i + 1 == k:
                res.append(q[0])
                
                # get the answer and slide the window which mean i and j will be moved
                
                if arr[i] == q[0]:
                    q.popleft()
                
                i += 1
                j += 1
            
        return res
            
--


============================================================================================================

-- Anagrams


-- https://www.geeksforgeeks.org/problems/anagram-1587115620/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    
    #Function is to check whether two strings are anagram of each other or not.
    def isAnagram(self,a,b):
        #code here
        
        if len(a) != len(b):
            return False
        
        A = [0] * 26
        B = [0] * 26
        
        
        for i in range(len(a)):
            A[ord(a[i]) - ord("a")] += 1
            B[ord(b[i]) - ord("a")] += 1
        
        if A == B:
            return True
        return False
        
--


======================================================================================================

-- Spirally traversing a matrix


-- https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=BJnMZNwUk1M


--
class Solution:
    
    #Function to return a list of integers denoting spiral traversal of matrix.
    def spirallyTraverse(self,matrix, r, c): 
        # code here 
        
        left = 0
        right = c - 1
        top = 0
        bottom = r - 1
        res = []
        
        while left <= right and top <= bottom:
            
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            
            top += 1
            
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            
            right -= 1
            
            if top <= bottom:
                for i in range(right, left - 1, -1):
                    res.append(matrix[bottom][i])
                    
                bottom -= 1
            
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    res.append(matrix[i][left])
                
                left += 1
        
        return res
--


===================================================================================================================

-- Determine if two trees are identical


-- https://www.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to check if two trees are identical.
    def isIdentical(self,root1, root2):
        # Code here
        
        def dfs(node1, node2):
            if not node1 and not node2:
                return True
            
            if node1 and node2:
                if node1.data == node2.data and dfs(node1.left, node2.left) and dfs(node1.right, node2.right):
                    return True
            
            return False
        
        return 1 if dfs(root1, root2) else 0 
--

==============================================================================================================

-- Key pair


-- https://www.geeksforgeeks.org/problems/key-pair5616/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
	def hasArrayTwoCandidates1(self,arr, n, x):
		# code here
		m = {}
		
		for i in range(n):
		    m[arr[i]] = 1
		   
        
        for i in range(n):
            if abs(x - arr[i]) in m:
                return True
        
        return False
    
    def hasArrayTwoCandidates(self, arr, n, x):
        hashmap = {}

        for i in range(n):
            temp = x-arr[i]
            if (temp in hashmap):
                return 1
            hashmap[arr[i]] = i
        return 0
--



==============================================================================================================

-- Wave array 


-- https://www.geeksforgeeks.org/problems/wave-array-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/sort-array-wave-form-2/


--
from typing import List


class Solution:
    def convertToWave(self, n : int, arr : List[int]) -> None:
        # code here
        
        # Traverse all even elements
        for i in range(0, n - 1, 2):
     
            # If current even element is smaller than previous
            if (i > 0 and arr[i] < arr[i-1]):
                arr[i], arr[i-1] = arr[i-1], arr[i]
     
            # If current even element is smaller than next
            if (i < n-1 and arr[i] < arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                
        return arr
--


======================================================================================================


-- Add two numbers represented by linked lists


-- https://www.geeksforgeeks.org/problems/add-two-numbers-represented-by-linked-lists/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, num1, num2):
        # code here
        # return head of sum list
        
        carry = 0
        dummy = Node(0)
        temp = dummy
        
        z = True
        
        def reverse(node):
            if not node:
                return node
            
            cur = node
            prev = None
            nxt = node
            
            while cur:
                
                nxt = cur.next
                cur.next = prev
                prev = cur
                cur = nxt
            
            return prev
            
        num1 = reverse(num1)
        num2 = reverse(num2)        
        
        
        while num1 or num2 or carry:
            v1 = num1.data if num1 else 0
            v2 = num2.data if num2 else 0
            
            # calculate sum and carry
            csum = carry + v1 + v2
            carry = csum // 10
            
            if csum % 10 != 0 and z:
                z = False
            
            # create new node with the sum mod 10
            temp.next = Node(csum % 10)
            temp = temp.next
            
            # move to next nodes
            if num1:
                num1 = num1.next
            if num2:
                num2 = num2.next
        
        reversedHead = reverse(dummy.next)
        
    
        if z:
            return Node(0)
        
        while reversedHead and reversedHead.data == 0:
            reversedHead = reversedHead.next
        return reversedHead
        

        return reversedHead
--


===================================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=CiiXBvrX-5A&t=352s


--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
            
--


================================================================================================================

-- N meetings in one room


-- https://www.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1?page=2&company=Flipkart&sortBy=submissions
-- 

Get the number of meetinfs can fit in one room

--
class Solution:
    
    #Function to find the maximum number of meetings that can
    #be performed in a meeting room.
    def maximumMeetings(self,n,start,end):
        # code here
        
        meetings = []
        
        for i in range(n):
            meetings.append((start[i], end[i]))
        
        meetings.sort(key= lambda x:x[1])
        
        prev = meetings[0][1]
        cnt = 1
        for i in range(1, n):
            if meetings[i][0] > prev:
                cnt += 1
                prev = meetings[i][1]
        
        return cnt
--


====================================================================================================================

-- Get minimum element from stack


-- https://www.geeksforgeeks.org/problems/get-minimum-element-from-stack/1?page=2&company=Flipkart&sortBy=submissions
--


--
class stack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        if not self.stack:
            return -1
        popped = self.stack.pop()
        if popped == self.min_stack[-1]:
            self.min_stack.pop()
        return popped

    def getMin(self):
        if not self.min_stack:
            return -1
        return self.min_stack[-1]
--


===========================================================================================================================


-- Stickler theif ( House Robber )

-- https://www.geeksforgeeks.org/problems/stickler-theif-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=Rp7I15rKNxs

--
class Solution:  
    
    #Function to find the maximum money the thief can get.
    def FindMaxSum1(self,arr, n):
        
        # code here
        
        dp = [-1 for i in range(n + 1)]
        
        if len(arr) == 1:
            return arr[0]
        
        if len(arr) == 2:
            return max(arr[0], arr[1])
        
        
        def dfs(index):
            
            if index >= n:
                return 0
                
            if dp[index] != -1:
                return dp[index]
                
            withd = dfs(index + 2) + arr[index]
            without = dfs(index + 1)
            
            dp[index] = max(withd, without)
            
            return dp[index]
        
        return dfs(0)
        
        
    
    def FindMaxSum(self,arr, n):
        
        dp = [0 for i in range(n + 1)]
        
        dp[0] = arr[0]
        dp[1] = max(arr[0], arr[1])

        
        for i in range(2, n):
            
            dp[i] = max(arr[i] + dp[i - 2], dp[i - 1])
        
        
        return dp[n - 1]
--


==========================================================================================================


-- Top view of the binary tree


-- https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1
-- https://www.youtube.com/watch?v=JMBFm__krXw
-- https://www.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/1?page=3&company=Flipkart&sortBy=submissions


--
from collections import defaultdict, deque

# Tree Node
# class Node:
#     def __init__(self, val):
#         self.right = None
#         self.data = val
#         self.left = None

class Solution:
    
    #Function to return a list of nodes visible from the top view 
    #from left to right in Binary Tree.
    def topView(self,root):
        
        # code here
        
        # go in the level order and get the horizontal distance of the tree node from the root
        
        # if going towards left then -1 else +1
        
        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            if not m[hd]:
                res.append((hd, node.data))
                m[hd] = 1
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.cright, hd + 1))
        
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


============================================================================================================

-- Bottom view of the binary tree


-- https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=JMBFm__krXw


--
class Solution:
    def bottomView(self, root):
        # code here

        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            m[hd] = (hd, node.data)
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.right, hd + 1))
        
        for i in m:
            res.append(m[i])
            
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


=======================================================================================================================


-- Median of 2 sorted arrays


-- https://www.geeksforgeeks.org/problems/median-of-2-sorted-arrays-of-different-sizes/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
-- https://leetcode.com/problems/median-of-two-sorted-arrays/


--class Solution:
    def MedianOfArrays(self, a, b):
        
        # get the l1 l2 and r1 r2 from the ends of the partition of the array
        
        # get the hight end from the lower length array
        
        n1 = len(a)
        n2 = len(b)
        
        if n1 > n2: return self.MedianOfArrays(b, a)
        
        low = 0
        high = n1
        n = n1 + n2
        
        totalLength = (n1 + n2 + 1) // 2
        
        while low <= high:
            
            mid1 = (high + low) >> 1
            mid2 = totalLength - mid1
            
            l1 = float("-inf")
            l2 = float("-inf")
            r1 = float("inf")
            r2 = float("inf")
            
            if mid1 < n1: r1 = a[mid1]
            
            if mid2 < n2: r2 = b[mid2]
            
            if mid1 - 1 >= 0: l1 = a[mid1 - 1]
            if mid2 - 1 >= 0: l2 = b[mid2 - 1]
            
            if l1 <= r2 and l2 <= r1:
                if n % 2 == 0: return ((max(l1, l2) + min(r1, r2)) / 2)
                else:
                    return max(l1, l2)
            elif l1 > r2:
                high = mid1 -1
            
            else:
                low = mid1 + 1
                
        
        return 0
--

====================================================================================================================

-- Level order traversal in spiral form (zig zag traversal)


-- https://www.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/1?page=2&company=Flipkart&sortBy=submissions
--


--
from collections import deque
'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''        

def findSpiral(root):
    # Code here
    
    res = []
    q = deque([root])
    
    leftToRight = tRUE
    
    while q:
        
        size = len(q)
        row = [0 for _ in range(size)]
        
        for i in range(size):
            
            node = q.popleft()
            
            index = i if leftToRight else size - i - 1 
            
            row[index] = node.data
            
            if node.left:
                q.append(node.left)
            
            if node.right:
                q.append(node.right)
                
        
        for i in row:
            res.append(i)
            
        lefToRight = not leftToRight
                    
        
    return res
--

==========================================================================================================

-- Multiply two numbers


-- https://www.geeksforgeeks.org/problems/multiply-two-strings/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=1vZswirL8Y8


--
class Solution:
    def multiplyStrings(self,s1,s2):
        # code here
        # return the product string
        
        if "0" in s1 or "0" in s2:
            return '0'
            
        i1 = len(s1)
        i2 = len(s2)
        
        # if "0" == s1[0]:
        #     t = True
            
        #     for i in range(s1):
                
                
                
                
            
        # if s1[0] == '-':
        #     flag = 1 - flag
        
        i1 = len(s1)
        i2 = len(s2)
            
        res = [0 for _ in range(i1 + i2)]
        
        s1 = s1[::-1]
        s2 = s2[::-1]
        
        for i in range(len(s1)):
            for j in range(len(s2)):
                
                digit = int(s1[i]) * int(s2[j])
                
                res[i + j] += digit
                
                res[i + j + 1] += res[i + j] // 10 
                res[i + j] = res[i + j] % 10
        
        res = res[::-1]
        beg = 0
        
        while beg < len(res) and res[beg] == 0:
            beg += 1
            
        res = map(str, res[beg:])
        
        return "".join(res)
--


=======================================================================================================

-- Square root


-- https://www.geeksforgeeks.org/problems/square-root/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def floorSqrt(self, n): 
    #Your code here
    
        res = 0
        
        if n <= 1:
            return n
        for i in range(n):
            if i * i <= n:
                res = i
            elif i * i > n:
                break
        
        return res
--


===================================================================================================================

-- Coin change


-- https://www.geeksforgeeks.org/problems/coin-change2448/1?page=2&company=Flipkart&sortBy=submissions
--

--
class Solution:
    def count1(self, coins, n, Sum):
        # code here 
        dp = [[-1 for _ in range(Sum + 1)] for _ in range(n + 1)]
        
        cnt = 0
        def dfs(index, s):
            if s == 0:
                return 1
                
            if dp[index][s] != -1:
                return dp[index][s]
                
            if index >= n:
                return 0
                
            if s < 0:
                return 0
            
            con = 0
            if s - coins[index] >= 0:
                con = dfs(index, s - coins[index]) 
                
            dcon = dfs(index + 1, s)
            
            dp[index][s] = con + dcon
            return con + dcon
        
        return dfs(0, Sum)
        
    
                
    def count(self, coins, n, Sum):
        
        dp = [[0 for _ in range(Sum + 1)] for _ in range(n + 1)]
        
        for i in range(n + 1):
            dp[i][0] = 1
            
        for i in range(1, n + 1):
            for j in range(1, Sum + 1):
                
                if coins[i - 1] <= j:
                    dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j]
                
                else:
                    dp[i][j] = dp[i - 1][j]
            
        return dp[n][Sum]
        
--

============================================================================================================


-- First non repeating character


-- https://www.geeksforgeeks.org/problems/first-non-repeating-character-in-a-stream1216/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-first-non-repeating-character-stream-characters/

--
class Solution:
	def FirstNonRepeating(self, A):
		# Code here
	    list = [] 
        mp = {}
        ans = ''
 
        for ch in A:
            if ch not in mp:  # new character visited first time
                list.append(ch)
                mp[ch] = 1
            else:
                # any repeated character encountered
                if ch in list:
                    list.remove(ch)
            ans += list[0] if list else '#'
 
        return ans
--


=======================================================================================================

-- Lowest common ancester


-- https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-binary-tree/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to return the lowest common ancestor in a Binary Tree.
    def lca(self,root, n1, n2):
        # Code here
        
        def dfs(node):
            
            if not node:
                return None
            
            if n1 == node.data:
                return node
            elif n2 == node.data:
                return node
            
            left_lca = dfs(node.left)
            right_lca = dfs(node.right)
            
            if left_lca and right_lca:
                return node
            
            return left_lca if left_lca else right_lca
            
        
        return dfs(root)
--


=================================================================================================

-- Circular tour


-- https://www.geeksforgeeks.org/problems/circular-tour-1587115620/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/problems/circular-tour-1587115620/1?page=3&company=Flipkart&sortBy=submissions


--
class Solution:
    
    #Function to find starting point where the truck can start to get through
    #the complete circle without exhausting its petrol in between.
    def tour(self,lis, n):
        #Code here
        
        diff = 0
        possible_index = 0
        ans = 0
        
        gas_sum = 0
        cost_sum = 0
        for i in range(n):
            gas_sum += lis[i][0]
            cost_sum += lis[i][1]
            
        if cost_sum > gas_sum:
            return -1
        
        for i in range(n):
            
            diff += lis[i][0] - lis[i][1]
            
            if diff < 0:
                ans = i + 1
                diff = 0
        
        return ans
--


========================================================================================================

-- Bipartite graph

-- https://www.geeksforgeeks.org/problems/bipartite-graph/1?page=3&company=Flipkart&sortBy=submissions
--

-
from collections import deque

class Solution:
	def isBipartite(self, V, adj):
		#code here
		color = [-1] * V
		
		def check(start, color):
    		q = deque()
    		q.append(start)
    		
    		
    		color[start] = 0
    		
            
            while q:
                node = q.popleft()
                
                for i in adj[node]:
                    
                    # if the node is not coloured then color it with the opposite color of the neighbour
                    if color[i] == -1:
                        color[i] = 1 - color[node]
                        q.append(i)
                        
                    # if the color is present then check for the color with neighbour if it is same then return false
                    elif color[node] == color[i]:
                        return False
                        
            return True
            
        for i in range(V):
            if color[i] == -1:
                if not check(i, color):
                    return False
        
        return True
        
-

=====================================================================================================================================

-- Pivot in k rotated array


-- https://www.geeksforgeeks.org/problems/rotation4723/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def findKRotation(self, arr, n):
        # code here
        
        low = 0
        high = n - 1
        res = 0
        while low <= high:
            mid = (high + low) // 2
            
            if arr[mid] > arr[high]:
                low = mid + 1
                
            else:
                high = mid - 1
                
        
        return low

--


====================================================================================================

-- Bipartite graph


-- https://www.geeksforgeeks.org/problems/bipartite-graph/1?page=3&company=Flipkart&sortBy=submissions
--


--
from collections import deque

class Solution:
	def isBipartite(self, V, adj):
		#code here
		color = [-1] * V
		
		def check(start, color):
    		q = deque()
    		q.append(start)
    		
    		
    		color[start] = 0
    		
            
            while q:
                node = q.popleft()
                
                for i in adj[node]:
                    
                    # if the node is not coloured then color it with the opposite color of the neighbour
                    if color[i] == -1:
                        color[i] = 1 - color[node]
                        q.append(i)
                        
                    # if the color is present then check for the color with neighbour if it is same then return false
                    elif color[node] == color[i]:
                        return False
                        
            return True
            
        for i in range(V):
            if color[i] == -1:
                if not check(i, color):
                    return False
        
        return True
--


=======================================================================]=====================================

-- Product array puzzles


-- https://www.geeksforgeeks.org/problems/product-array-puzzle4525/1?page=3&company=Flipkart&sortBy=submissions
-- https://takeuforward.org/arrays/product-of-array-except-itself/


--
class Solution:
    def productExceptSelf(self, nums, n):
        prefix = [1] * n
        suffix = [1] * n

        # Calculate prefix products
        for i in range(1, n):
            prefix[i] = prefix[i - 1] * nums[i - 1]

        # Calculate suffix products
        for i in range(n - 2, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i + 1]

        # Combine prefix and suffix products to get the result
        res = [prefix[i] * suffix[i] for i in range(n)]
        
        return res
--


=========================================================================================================

-- Kth element of the two sorted array


-- https://www.geeksforgeeks.org/problems/k-th-element-of-two-sorted-array1317/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def kthElement(self, a, b, n, m, k):
        
        n1 = len(a)
        n2 = len(b)
        
        if n1 > n2: return self.kthElement(b, a, n, m, k)
        
        low = max(0, k - n2)
        high = min(k, n1)
        n = n1 + n2
        
        totalLength = (n1 + n2 + 1) // 2
        
        while low <= high:
            
            mid1 = (high + low) >> 1
            mid2 = totalLength - mid1
            
            l1 = float("-inf")
            l2 = float("-inf")
            r1 = float("inf")
            r2 = float("inf")
            
            if mid1 < n1: r1 = a[mid1]
            
            if mid2 < n2: r2 = b[mid2]
            
            if mid1 - 1 >= 0: l1 = a[mid1 - 1]
            if mid2 - 1 >= 0: l2 = b[mid2 - 1]
            
            if l1 <= r2 and l2 <= r1:
                return max(l1, l2)
            elif l1 > r2:
                high = mid1 -1
            
            else:
                low = mid1 + 1
                
        
        return 0
--


======================================================================================================

-- Stock buy nd sell 2


-- https://www.geeksforgeeks.org/problems/stock-buy-and-sell2615/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
--


--

from typing import List


class Solution1:
    def stockBuyAndSell(self, n : int, A) -> int:
        # code here
        
		
		dp = [[-1 for _ in range(2)] for _ in range(n + 1)]
		
		def dfs(index, buy):
		    
		    if index >= n:
		        return 0
		        
		    if dp[index][buy] != -1:
		        return dp[index][buy]
		    
		    if buy:
		        profit = max(- A[index] + dfs(index + 1, 0), dfs(index + 1, 1))
		    else:
		        profit = max(A[index] + dfs(index + 1, 1), dfs(index + 1, 0))
		    
		    dp[index][buy] = profit
		    return profit
        
        return dfs(0, 1)
        
        
class Solution:
    def stockBuyAndSell(self, n: int, A) -> int:
        # Initialize a dp array with size (n+1) x 2
        dp = [[0 for _ in range(2)] for _ in range(n + 1)]

        # Iterate over the days in reverse order
        for index in range(n - 1, -1, -1):
            for buy in range(2):
                if buy:
                    dp[index][buy] = max(-A[index] + dp[index + 1][0], dp[index + 1][1])
                else:
                    dp[index][buy] = max(A[index] + dp[index + 1][1], dp[index + 1][0])

        # The result will be the maximum profit starting from day 0 with the option to buy
        return dp[0][1]
--


========================================================================================================

-- Buy stocks and sell 


-- https://www.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/stock-buy-sell/


--
Find the local minima and maxima for every iteration
--

--
class Solution:
    #Function to find the days of buying and selling stock for max profit.
	def stockBuySell(self, price, n):
	    res = []
		#code here
		
        if (n == 1): 
            return
      
        # Traverse through given price array 
        i = 0
        while (i < (n - 1)): 
      
            # Find Local Minima 
            # Note that the limit is (n-2) as we are 
            # comparing present element to the next element 
            while ((i < (n - 1)) and
                    (price[i + 1] <= price[i])): 
                i += 1
      
            # If we reached the end, break 
            # as no further solution possible 
            if (i == n - 1): 
                break
      
            # Store the index of minima 
            buy = i 
            i += 1
      
            # Find Local Maxima 
            # Note that the limit is (n-1) as we are 
            # comparing to previous element 
            while ((i < n) and (price[i] >= price[i - 1])): 
                i += 1
      
            # Store the index of maxima 
            sell = i - 1
            
            res.append((buy, sell))
    
        return res
      
--


======================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions

--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
--

========================================================================================================


-- Chocolate distribution problem


-- 
--

--
class Solution:

    def findMinDiff(self, A,N,M):
        # code here
        
        A.sort()
        min_diff = float('inf')
        
        for i in range(len(A) - M + 1):
            if i + M - 1 < N and (A[i + M - 1] - A[i]) < min_diff :
                min_diff = A[i + M - 1] - A[i] 
                
        return min_diff
--


=============================================================================================================================

-- Job sequencing


-- https://www.geeksforgeeks.org/problems/job-sequencing-problem-1587115620/1?page=3&company=Flipkart&sortBy=submissions
--


--
import heapq

class Solution:
    
    #Function to find the maximum profit and the number of jobs done.
    def JobScheduling(self,a,n):
        
        # code here
        
        
        arr = []
        
        for obj in a:
            arr.append((obj.id, obj.deadline, obj.profit))
            
        n = len(arr)
     
        arr.sort(key=lambda x:x[1])
     
        # initialise the result array and maxHeap
        maxHeap = []
        jobs_done = 0
        profit = 0
        
     
        # starting the iteration from the end
        for i in range(n - 1, -1, -1):
     
            # calculate slots between two deadlines
            if i == 0:
                slots_available = arr[i][1]
            else:
                slots_available = arr[i][1] - arr[i - 1][1]
     
            # include the profit of job(as priority), deadline
            # and job_id in maxHeap
            # note we push negative value in maxHeap to convert
            # min heap to max heap in python
            heapq.heappush(maxHeap, (-arr[i][2], arr[i][1], arr[i][0]))
     
            while slots_available and maxHeap:
     
                # get the job with max_profit
                profits, deadline, job_id = heapq.heappop(maxHeap)
     
                # reduce the slots
                slots_available -= 1
                profit += (-1 * profits)
                jobs_done += 1
     
        # jobs included might be shuffled
        res = []
        res.append(jobs_done)
        res.append(profit)
        
        return res
--

====================================================================================================================

 
-- Search in the roated array


-- https://www.geeksforgeeks.org/problems/search-in-a-rotated-array4618/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=5qGrJbHhqFs


--
class Solution:
    def search(self, a : list, l : int, h : int, key : int):
        # l: The starting index
        # h: The ending index, you have to search the key in this range
        # Complete this function
        
        
        
        
        # first check the number match 
        # second check which part of the array is soretd which is either left or right
        
        # third if the left or right part is sorted check for the element is it lies in that range or not within left and mid
        # or withiin right and mif
        
        
        while l <= h:
            mid = (l + h) // 2
            
            if a[mid] == key:
                return mid
            
            elif a[l] <= a[mid]:
                # left is sorted 
                
                if key >= a[l] and a[mid] >= key:
                    # that means the number can be present in that sorted part
                    h = mid - 1
                else:
                    l = mid + 1
            else:
                if key <= a[h] and a[mid] <= key:
                    l = mid + 1
                else:
                    h = mid - 1
        
        return -1
--


==========================================================================================================================

-- Count ways to reach the nth stairs


-- https://www.geeksforgeeks.org/problems/count-ways-to-reach-the-nth-stair-1587115620/1?page=3&company=Flipkart&sortBy=submissions
--


--

class Solution:
    # Function to count number of ways to reach the nth stair.
    def countWays1(self, n):
        # Initializing dp array with -1
        dp = [-1 for _ in range(n + 1)]
        
        # Helper function to perform DFS with memoization
        def dfs(step):
            if step == n:
                return 1
            if step > n:
                return 0
            if dp[step] != -1:
                return dp[step]
            dp[step] = dfs(step + 1) + dfs(step + 2)
            return (dp[step])
        
        # Starting DFS from 0th step
        return dfs(0)
        
    def countWays2(self, n):
        # Initializing dp array with 1 for the base cases
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1  # There is 1 way to reach the 0th and 1st stairs
        
        # Iteratively filling dp array
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # Returning the number of ways to reach the nth stair
        return (dp[n]) % 1000000007
        
    
    def countWays3(self, n):
        # declaring  two variables to store the count
        prev = 1
        prev2 = 1
        # Running for loop to count all possible ways
        for i in range(2, n+1):
            curr = prev + prev2
            prev2 = prev
            prev = curr
        return prev
        
    
    def countWays(self, n):
        
        dp = [-1 for _ in range(n)]
        def dfs(step):
            if step == n:
                return 1
            
            if step > n:
                return 0
            
            if dp[step] != -1:
                return dp[step]
            
            dp[step] = dfs(step+ 1) + dfs(step + 2)
            return dp[step]
    
        return dfs(0) % 1000000007
--

===========================================================================================================================


-- Find the number of islands


-- https://www.geeksforgeeks.org/problems/find-the-number-of-islands/1?page=3&company=Flipkart&sortBy=submissions
--


--
import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        #code here
        
        def is_valid(r, c, row, col, grid):
            if r >= row or c >= col or r < 0 or c < 0 or grid[r][c] == 0:
                return False
            return True
        
        def dfs(r, c, row, col, grid):
            
            grid[r][c] = 0
            
            dx = [-1, 1, 0, 0, -1, -1, 1, 1]
            dy = [0, 0, -1, 1, -1, 1, -1, 1]
            
            for i in range(len(dx)):
                new_x = r + dx[i]
                new_y = c + dy[i]
                
                if is_valid(new_x, new_y, row, col, grid):
                    dfs(new_x, new_y, row, col, grid)
            
            
        cnt = 0
        row = len(grid)
        col = len(grid[0])
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    cnt += 1
                    dfs(i, j, row, col, grid)
            
        return cnt
--


==============================================================================================================================

-- Tower of Hanoi


-- https://www.geeksforgeeks.org/problems/tower-of-hanoi-1587115621/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=V5vNq2WOPGE


--
class Solution:
    def toh(self, N, fromm, to, aux):
        # Your code here
        
        def toh_cal(n, src, des, helping):
            if n == 1:
                print("move disk {} from rod {} to rod {}".format(n, src, des))
                return 
            
            toh_cal(n - 1, src, helping, des)
            print("move disk {} from rod {} to rod {}".format(n, src, des))
            toh_cal(n - 1, helping, des, src)
            
        toh_cal(N, fromm, to, aux)
        return pow(2, N) - 1
--


===========================================================================================================================


-- Reverse the level order traverssal


-- https://www.youtube.com/watch?v=t6IwIr8mPz0
-- https://www.geeksforgeeks.org/problems/reverse-level-order-traversal/1?page=4&company=Flipkart&sortBy=submissions



-
from collections import deque
def reverseLevelOrder(root):
    # code here
    if not root:
        return root
    
    q = deque()
    q.append(root)
    
    res = []
    
    while q:
        node = q.popleft()
        
        res.append(node.data)
        
        if node.right:
            q.append(node.right)
        
        if node.left:
            q.append(node.left)
        
    return res[::-1]
-


=============================================================================================================================


-- Smallest window in a string containing all the characters of another string


-- https://www.geeksforgeeks.org/problems/smallest-window-in-a-string-containing-all-the-characters-of-another-string-1587115621/1?page=4&company=Flipkart&sortBy=submissions
--



--
from collections import defaultdict

class Solution:
    
    #Function to find the smallest window in the string s consisting
    #of all the characters of string p.
    def smallestWindow(self, s, p):
        #code here
        
        res = ""
        m = defaultdict(int)
        
        for i in p:
            m[i] += 1
        
        i = 0
        j = 0
        n = len(s)
        
        cnt = len(m)
        min_len = float('inf')
        
        while j < n:
            if s[j] in m:
                m[s[j]] -= 1
                
                if m[s[j]] == 0:
                    cnt -= 1
                
            while cnt == 0:
                if j - i + 1 < min_len:
                    min_len = j - i + 1
                    res = s[i:j+1]
                
                if s[i] in m:
                    m[s[i]] += 1
                    if m[s[i]] > 0:
                        cnt += 1
                i += 1

            j += 1
        
        return res if res else -1
--


========================================================================================================================

-- Count Possible Decodings of a given Digit Sequence


-- https://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/
-- https://www.youtube.com/watch?v=dikmR3LaOFk


--
class Solution:
    def CountWays1(self, string):
        n = len(string)
        dp = [-1 for _ in range(n)]
        
        def dfs(index):
            if index >= n:
                return 1
            elif index == n - 1:
                return 1 if string[index] != '0' else 0
            elif string[index] == '0':
                return 0
            elif dp[index] != -1:
                return dp[index]
            else:
                if string[index] == '1' or (string[index] == '2' and string[index + 1] in '0123456'):
                    dp[index] = (dfs(index + 1) % 1000000007 + dfs(index + 2) % 1000000007)
                else:
                    dp[index] = dfs(index + 1) % 1000000007
                return dp[index]
        
        return dfs(0)
        
    
    def CountWays(self, string):
        n = len(string)
        
        if n == 0 or string[0] == '0':
            return 0
        
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        
        for i in range(2, n + 1):
            if string[i - 1] != '0':
                dp[i] = (dp[i - 1])
            
            two_digit = int(string[i - 2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i - 2] % 1000000007
                
        
        return dp[n] % 1000000007
--


===============================================================================================================================

-- Next permutation

-- https://www.geeksforgeeks.org/problems/next-permutation5226/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=LuLCLgMElus


--
class Solution:
    def nextPermutation(self, N, A):
        
        # Find the inflation point from the end of the array
        # then for that index number find the number which is next greater than that from the end of the array
        # then swap them and from inflation point reverse the array numbers

        if N == 0 or N == 1:
            return
        
        def swap(a, b):
            A[a], A[b] = A[b], A[a]

        def reverse(i, j):
            while i < j:
                swap(i, j)
                i += 1
                j -= 1
        
        # Step 1: Find the first decreasing element from the end
        i = N - 2
        while i >= 0 and A[i] >= A[i + 1]:
            i -= 1
        
        # Step 2: If we found a valid 'i', find the smallest element greater than A[i] to the right of 'i'
        if i >= 0:
            j = N - 1
            while A[j] <= A[i]:
                j -= 1
            # Step 3: Swap the elements at 'i' and 'j'
            swap(i, j)
            
        # Step 4: Reverse the elements from 'i + 1' to the end of the array
        reverse(i + 1, N - 1)
        
        return A
            
--


============================================================================================================================


-- Activity Selction


-- https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/
-- https://www.geeksforgeeks.org/problems/activity-selection-1587115620/1?page=4&company=Flipkart&sortBy=submissions


--
class Solution:
    
    #Function to find the maximum number of activities that can
    #be performed by a single person.
    def activitySelection(self,n,start,end):
        
        # code here
        arr = []
        
        # Creating a list of tuples (start, end)
        for i in range(n):
            arr.append((start[i], end[i]))
        
        # Sorting activities based on their end time first and start time second
        arr.sort(key=lambda x: (x[1], x[0]))
        
        # The first activity is always selected
        prev_end = arr[0][1]
        cnt = 1
        
        # Iterate over the remaining activities
        for i in range(1, n):
            # If the start time of the current activity is greater or equal
            # to the end time of the previously selected activity
            if arr[i][0] > prev_end:
                cnt += 1
                prev_end = arr[i][1]
        
        return cnt
--


==============================================================================================================================

-- Bitonic point


-- https://www.geeksforgeeks.org/problems/maximum-value-in-a-bitonic-array3001/1?page=4&company=Flipkart&sortBy=submissions


--
class Solution:

	def findMaximum(self,arr, n):
		# code here
		
		high = n - 1
		low = 0
		
		while low <= high:
		    mid = low + (high - low) // 2
		    
		    if(arr[mid] > arr[mid - 1] and (mid + 1 < n and arr[mid] > arr[mid + 1])): 
                return arr[mid] 
            # move to the right part 
            elif mid + 1 < n and (arr[mid] < arr[mid + 1]): 
                low = mid + 1
                  
            # move to the right part 
            else: 
                high = mid - 1
		   
	    return n
--


============================================================================================================================

