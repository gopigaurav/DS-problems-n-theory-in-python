
-- FInd the missing number


-- https://www.geeksforgeeks.org/problems/missing-number-in-array1416/1?page=1&company=Flipkart&sortBy=submissions
-- 

--
class Solution:
    def missingNumber(self,a,n):
        # code here
        
        total = n * (n + 1) // 2
        
        dif = total - sum(a)
        return dif
--


======================================================================================


-- jump game


-- https://leetcode.com/problems/jump-game/submissions/1240898979/
-- https://www.youtube.com/watch?v=EgMPjWliYGY

--
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        # We can do this in dp but also we can do this with greedy
        index = len(nums) - 1
        for i in range(len(nums) - 1, -1, -1):
            # plus index becoz u need to check with respect to index
            if nums[i] + i >= index:
                index = i

        if index == 0:
            return True
        return False
--


=======================================================================================

-- Min number of jumps to reach the end (Jump game 2)


-- https://www.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

--
#User function Template for python3
class Solution:
	def minJumps(self, arr, n):
	    #code here
	    
        # greedy approach
        
        farthest = 0
        cur = 0
        jumps = 0
        
        for i in range(n - 1):
            
            if arr[i] + i > farthest:
                farthest = arr[i] + i
            
            if i == cur:
                if farthest == cur:
                    return -1
                cur = farthest
                jumps += 1
            
        
            
        if len(arr) == 1:
            return 0
        
        if arr[0] == 0:
            return -1
        

        return jumps
--


==========================================================================================================

-- Find duplicates in array for O(N)

-- https://www.geeksforgeeks.org/problems/find-duplicates-in-an-array/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/


--
class Solution:
    def duplicates(self, arr, n): 
    	# code here
    	
    	result = []

        # Step 1: Iterate through the array to mark frequencies
        for i in range(len(arr)):
            # Calculate the index where the frequency needs to be stored
            index = arr[i] % len(arr)
            # Increment the value at the calculated index by n, marking the frequency
            arr[index] += len(arr)
        
        # Step 2: Traverse the modified array to find duplicate elements
        found = False
        for i in range(len(arr)):
            # Calculate the frequency of the current element
            if arr[i] // len(arr) > 1:
                # If frequency is greater than 1, add the index to the result list
                result.append(i)
                found = True
    
        # Step 3: If no duplicates found, add -1 to the result
        if not found:
            result.append(-1)
    
        return result
--

==================================================================================================================

-- Parenthesis Checker

-- https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

--
class Solution:
    
    #Function to check if brackets are balanced or not.
    def ispar(self,x):
        # code here
        
        possible_combination = { '}': '{', ']': '[', ')': '('}
        
        stack = []
        
        for i in range(len(x)):
            if x[i] in ['(', '[', '{']:
                stack.append(x[i])
            else:
                if stack and stack[-1] == possible_combination.get(x[i], 0):
                    stack.pop()
                else:
                    return False
        
        if not stack:
            return True
        return False
--

===============================================================================================================================

-- Check for BST


-- https://www.geeksforgeeks.org/problems/check-for-bst/1?page=1&company=Flipkart&sortBy=submissions
-- https://geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

--
class Solution:
    
    #Function to check whether a Binary Tree is BST or not.
    def isBST(self, root):
        #code here
        
        def dfs(node, mx_v, mi_v):
            
            if not node:
                return True
                
            if mi_v > node.data:
                return False
            
            if mx_v < node.data:
                return False
                
            return dfs(node.left, node.data - 1, mi_v) and dfs(node.right, mx_v, node.data - 1)
    
            
        
        return dfs(root, float("inf"), float("-inf"))
--


=======================================================================================================================================


-- Left view of the binary tree


-- https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-- Check the level of the and then input

--
def LeftView(root):
    
    # code here
    
    res = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(res):
            res.append(node.data)
        
        if node.left:
            dfs(node.left, level + 1)
        if node.right:
            dfs(node.right, level + 1)
        
        
    dfs(root, 0)
    return res
--


==========================================================================================================================================

-- Trapping water


-- https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=m18Hntz4go8


--
class Solution:
    def trappingWater(self, arr,n):
        #Code here
        
        # the logic is get the left most greater one which is greater than the current number
        # get the right most greater one which is greater than the current number
        
        # min(left[i], right[i]) - arr[i]
        
        # for this the better approach is to get the prefix array from left side and suffix array from right side
        
        # the optimal solution is using two pointer approach
        
        left = 0
        right = n - 1
        max_left = 0
        max_right = 0
        res = 0
        
        while left <= right:
            
            if arr[left] <= arr[right]:
                if arr[left] > max_left:
                    max_left = arr[left]
                    
                else:
                    res += max_left - arr[left]
                
                left += 1
                    
            else:
                if arr[right] > max_right:
                    max_right = arr[right]
                
                else:
                    res += max_right - arr[right]
                
                right += 1
        
        return res
--


======================================================================================================================

-- 
