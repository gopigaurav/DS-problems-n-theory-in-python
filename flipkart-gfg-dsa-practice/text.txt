
-- FInd the missing number


-- https://www.geeksforgeeks.org/problems/missing-number-in-array1416/1?page=1&company=Flipkart&sortBy=submissions
-- 

--
class Solution:
    def missingNumber(self,a,n):
        # code here
        
        total = n * (n + 1) // 2
        
        dif = total - sum(a)
        return dif
--


======================================================================================


-- jump game


-- https://leetcode.com/problems/jump-game/submissions/1240898979/
-- https://www.youtube.com/watch?v=EgMPjWliYGY

--
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        # We can do this in dp but also we can do this with greedy
        index = len(nums) - 1
        for i in range(len(nums) - 1, -1, -1):
            # plus index becoz u need to check with respect to index
            if nums[i] + i >= index:
                index = i

        if index == 0:
            return True
        return False
--


=======================================================================================

-- Min number of jumps to reach the end (Jump game 2)


-- https://www.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

--
#User function Template for python3
class Solution:
	def minJumps(self, arr, n):
	    #code here
	    
        # greedy approach
        
        farthest = 0
        cur = 0
        jumps = 0
        
        for i in range(n - 1):
            
            if arr[i] + i > farthest:
                farthest = arr[i] + i
            
            if i == cur:
                if farthest == cur:
                    return -1
                cur = farthest
                jumps += 1
            
        
            
        if len(arr) == 1:
            return 0
        
        if arr[0] == 0:
            return -1
        

        return jumps
--


==========================================================================================================

-- Find duplicates in array for O(N)

-- https://www.geeksforgeeks.org/problems/find-duplicates-in-an-array/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/


--
class Solution:
    def duplicates(self, arr, n): 
    	# code here
    	
    	result = []

        # Step 1: Iterate through the array to mark frequencies
        for i in range(len(arr)):
            # Calculate the index where the frequency needs to be stored
            index = arr[i] % len(arr)
            # Increment the value at the calculated index by n, marking the frequency
            arr[index] += len(arr)
        
        # Step 2: Traverse the modified array to find duplicate elements
        found = False
        for i in range(len(arr)):
            # Calculate the frequency of the current element
            if arr[i] // len(arr) > 1:
                # If frequency is greater than 1, add the index to the result list
                result.append(i)
                found = True
    
        # Step 3: If no duplicates found, add -1 to the result
        if not found:
            result.append(-1)
    
        return result
--

==================================================================================================================

-- Parenthesis Checker

-- https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

--
class Solution:
    
    #Function to check if brackets are balanced or not.
    def ispar(self,x):
        # code here
        
        possible_combination = { '}': '{', ']': '[', ')': '('}
        
        stack = []
        
        for i in range(len(x)):
            if x[i] in ['(', '[', '{']:
                stack.append(x[i])
            else:
                if stack and stack[-1] == possible_combination.get(x[i], 0):
                    stack.pop()
                else:
                    return False
        
        if not stack:
            return True
        return False
--

===============================================================================================================================

-- Check for BST


-- https://www.geeksforgeeks.org/problems/check-for-bst/1?page=1&company=Flipkart&sortBy=submissions
-- https://geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

--
class Solution:
    
    #Function to check whether a Binary Tree is BST or not.
    def isBST(self, root):
        #code here
        
        def dfs(node, mx_v, mi_v):
            
            if not node:
                return True
                
            if mi_v > node.data:
                return False
            
            if mx_v < node.data:
                return False
                
            return dfs(node.left, node.data - 1, mi_v) and dfs(node.right, mx_v, node.data - 1)
    
            
        
        return dfs(root, float("inf"), float("-inf"))
--


=======================================================================================================================================


-- Left view of the binary tree


-- https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-- Check the level of the and then input

--
def LeftView(root):
    
    # code here
    
    res = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(res):
            res.append(node.data)
        
        if node.left:
            dfs(node.left, level + 1)
        if node.right:
            dfs(node.right, level + 1)
        
        
    dfs(root, 0)
    return res
--


==========================================================================================================================================

-- Trapping water


-- https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=m18Hntz4go8


--
class Solution:
    def trappingWater(self, arr,n):
        #Code here
        
        # the logic is get the left most greater one which is greater than the current number
        # get the right most greater one which is greater than the current number
        
        # min(left[i], right[i]) - arr[i]
        
        # for this the better approach is to get the prefix array from left side and suffix array from right side
        
        # the optimal solution is using two pointer approach
        
        left = 0
        right = n - 1
        max_left = 0
        max_right = 0
        res = 0
        
        while left <= right:
            
            if arr[left] <= arr[right]:
                if arr[left] > max_left:
                    max_left = arr[left]
                    
                else:
                    res += max_left - arr[left]
                
                left += 1
                    
            else:
                if arr[right] > max_right:
                    max_right = arr[right]
                
                else:
                    res += max_right - arr[right]
                
                right += 1
        
        return res
--


======================================================================================================================

--  Count pairs of given sum


-- https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1?page=1&company=Flipkart&sortBy=submissions
--


--
from collections import defaultdict
class Solution:
    def getPairsCount(self, arr, n, sum):
        # code here

        unordered_map = {}
        count = 0
        for i in range(n):
            if sum - arr[i] in unordered_map:
                count += unordered_map[sum - arr[i]]
            if arr[i] in unordered_map:
                unordered_map[arr[i]] += 1
            else:
                unordered_map[arr[i]] = 1
        return count
--


===============================================================================================================================

-- boundary traversal of the binary tree


-- https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-
from collections import defaultdict

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def printBoundaryView(self, root):
        # Code here
        
        # method 1
        
        # Using recursion
        
        # first print left tree view excluding leaf
        # second print all the leaves
        # third print the right from bottom up approach
        res = [root.data]
        
        def printleft(node):
            
            if node:
            
                if node.left:
                    # only add it into the res if the either of the child is present
                    
                    res.append(node.data)
                    
                    printleft(node.left)
                    
                elif node.right:
                    
                    res.append(node.data)
                    
                    printleft(node.right)
        
        def printRight(node):
            
            if node:
                
                if node.right:
                    printRight(node.right)
                    res.append(node.data)
                    
                elif node.left:
                    
                    printRight(node.left)
                    res.append(node.data)
                
                
        
        def printLeaves(node):
            
            if node:
            
                printLeaves(node.left)
                
                if not node.left and not node.right:
                    res.append(root.data)
                
                printLeaves(node.right)
        
        printleft(root.left)
        
        printLeaves(root.left)
        printLeaves(root.right)
        
        printRight(root.right)
        
        return res
-

=========================================================================================================


-- find the middle element in linked list


-- https://www.geeksforgeeks.org/problems/finding-middle-element-in-a-linked-list/1?page=1&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        
        slow = head
        fast = head
        
        while fast and fast.next:
            
            slow = slow.next
            fast = fast.next.next
            

        return slow.data
--


===========================================================================================================


-- Maximum of all subarray


-- https://www.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1?page=2&company=Flipkart&sortBy=submissions
--

--
from collections import deque

class Solution:
    
    #Function to find maximum of each subarray of size k.
    def max_of_subarrays(self,arr,n,k):
        
        #code here
        q = deque()
        j = 0

        res = []
        
        i = 0
        j = 0
        
        while j < n:
            
            # check the queue if it is in decreasing order else pop the elements
            # since we want the next greater after popping the max element
            
            
            while q and q[-1] < arr[j]:
                q.pop()
            
            q.append(arr[j])
            

            
            if j - i + 1 < k:
                j += 1
            
            elif j - i + 1 == k:
                res.append(q[0])
                
                # get the answer and slide the window which mean i and j will be moved
                
                if arr[i] == q[0]:
                    q.popleft()
                
                i += 1
                j += 1
            
        return res
            
--


============================================================================================================

-- Anagrams


-- https://www.geeksforgeeks.org/problems/anagram-1587115620/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    
    #Function is to check whether two strings are anagram of each other or not.
    def isAnagram(self,a,b):
        #code here
        
        if len(a) != len(b):
            return False
        
        A = [0] * 26
        B = [0] * 26
        
        
        for i in range(len(a)):
            A[ord(a[i]) - ord("a")] += 1
            B[ord(b[i]) - ord("a")] += 1
        
        if A == B:
            return True
        return False
        
--


======================================================================================================

-- Spirally traversing a matrix


-- https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=BJnMZNwUk1M


--
class Solution:
    
    #Function to return a list of integers denoting spiral traversal of matrix.
    def spirallyTraverse(self,matrix, r, c): 
        # code here 
        
        left = 0
        right = c - 1
        top = 0
        bottom = r - 1
        res = []
        
        while left <= right and top <= bottom:
            
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            
            top += 1
            
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            
            right -= 1
            
            if top <= bottom:
                for i in range(right, left - 1, -1):
                    res.append(matrix[bottom][i])
                    
                bottom -= 1
            
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    res.append(matrix[i][left])
                
                left += 1
        
        return res
--


===================================================================================================================

-- Determine if two trees are identical


-- https://www.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to check if two trees are identical.
    def isIdentical(self,root1, root2):
        # Code here
        
        def dfs(node1, node2):
            if not node1 and not node2:
                return True
            
            if node1 and node2:
                if node1.data == node2.data and dfs(node1.left, node2.left) and dfs(node1.right, node2.right):
                    return True
            
            return False
        
        return 1 if dfs(root1, root2) else 0 
--

==============================================================================================================

-- Key pair


-- https://www.geeksforgeeks.org/problems/key-pair5616/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
	def hasArrayTwoCandidates1(self,arr, n, x):
		# code here
		m = {}
		
		for i in range(n):
		    m[arr[i]] = 1
		   
        
        for i in range(n):
            if abs(x - arr[i]) in m:
                return True
        
        return False
    
    def hasArrayTwoCandidates(self, arr, n, x):
        hashmap = {}

        for i in range(n):
            temp = x-arr[i]
            if (temp in hashmap):
                return 1
            hashmap[arr[i]] = i
        return 0
--



==============================================================================================================

-- Wave array 


-- https://www.geeksforgeeks.org/problems/wave-array-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/sort-array-wave-form-2/


--
from typing import List


class Solution:
    def convertToWave(self, n : int, arr : List[int]) -> None:
        # code here
        
        # Traverse all even elements
        for i in range(0, n - 1, 2):
     
            # If current even element is smaller than previous
            if (i > 0 and arr[i] < arr[i-1]):
                arr[i], arr[i-1] = arr[i-1], arr[i]
     
            # If current even element is smaller than next
            if (i < n-1 and arr[i] < arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                
        return arr
--


======================================================================================================


-- Add two numbers represented by linked lists


-- https://www.geeksforgeeks.org/problems/add-two-numbers-represented-by-linked-lists/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, num1, num2):
        # code here
        # return head of sum list
        
        carry = 0
        dummy = Node(0)
        temp = dummy
        
        z = True
        
        def reverse(node):
            if not node:
                return node
            
            cur = node
            prev = None
            nxt = node
            
            while cur:
                
                nxt = cur.next
                cur.next = prev
                prev = cur
                cur = nxt
            
            return prev
            
        num1 = reverse(num1)
        num2 = reverse(num2)        
        
        
        while num1 or num2 or carry:
            v1 = num1.data if num1 else 0
            v2 = num2.data if num2 else 0
            
            # calculate sum and carry
            csum = carry + v1 + v2
            carry = csum // 10
            
            if csum % 10 != 0 and z:
                z = False
            
            # create new node with the sum mod 10
            temp.next = Node(csum % 10)
            temp = temp.next
            
            # move to next nodes
            if num1:
                num1 = num1.next
            if num2:
                num2 = num2.next
        
        reversedHead = reverse(dummy.next)
        
    
        if z:
            return Node(0)
        
        while reversedHead and reversedHead.data == 0:
            reversedHead = reversedHead.next
        return reversedHead
        

        return reversedHead
--


===================================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=CiiXBvrX-5A&t=352s


--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
            
--


================================================================================================================

-- N meetings in one room


-- https://www.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1?page=2&company=Flipkart&sortBy=submissions
-- 

Get the number of meetinfs can fit in one room

--
class Solution:
    
    #Function to find the maximum number of meetings that can
    #be performed in a meeting room.
    def maximumMeetings(self,n,start,end):
        # code here
        
        meetings = []
        
        for i in range(n):
            meetings.append((start[i], end[i]))
        
        meetings.sort(key= lambda x:x[1])
        
        prev = meetings[0][1]
        cnt = 1
        for i in range(1, n):
            if meetings[i][0] > prev:
                cnt += 1
                prev = meetings[i][1]
        
        return cnt
--


====================================================================================================================

-- Get minimum element from stack


-- https://www.geeksforgeeks.org/problems/get-minimum-element-from-stack/1?page=2&company=Flipkart&sortBy=submissions
--


--
class stack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        if not self.stack:
            return -1
        popped = self.stack.pop()
        if popped == self.min_stack[-1]:
            self.min_stack.pop()
        return popped

    def getMin(self):
        if not self.min_stack:
            return -1
        return self.min_stack[-1]
--


===========================================================================================================================


-- Stickler theif ( House Robber )

-- https://www.geeksforgeeks.org/problems/stickler-theif-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=Rp7I15rKNxs

--
class Solution:  
    
    #Function to find the maximum money the thief can get.
    def FindMaxSum1(self,arr, n):
        
        # code here
        
        dp = [-1 for i in range(n + 1)]
        
        if len(arr) == 1:
            return arr[0]
        
        if len(arr) == 2:
            return max(arr[0], arr[1])
        
        
        def dfs(index):
            
            if index >= n:
                return 0
                
            if dp[index] != -1:
                return dp[index]
                
            withd = dfs(index + 2) + arr[index]
            without = dfs(index + 1)
            
            dp[index] = max(withd, without)
            
            return dp[index]
        
        return dfs(0)
        
        
    
    def FindMaxSum(self,arr, n):
        
        dp = [0 for i in range(n + 1)]
        
        dp[0] = arr[0]
        dp[1] = max(arr[0], arr[1])

        
        for i in range(2, n):
            
            dp[i] = max(arr[i] + dp[i - 2], dp[i - 1])
        
        
        return dp[n - 1]
--


==========================================================================================================


-- Top view of the binary tree


-- https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1
-- https://www.youtube.com/watch?v=JMBFm__krXw
-- https://www.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/1?page=3&company=Flipkart&sortBy=submissions


--
from collections import defaultdict, deque

# Tree Node
# class Node:
#     def __init__(self, val):
#         self.right = None
#         self.data = val
#         self.left = None

class Solution:
    
    #Function to return a list of nodes visible from the top view 
    #from left to right in Binary Tree.
    def topView(self,root):
        
        # code here
        
        # go in the level order and get the horizontal distance of the tree node from the root
        
        # if going towards left then -1 else +1
        
        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            if not m[hd]:
                res.append((hd, node.data))
                m[hd] = 1
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.cright, hd + 1))
        
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


============================================================================================================

-- Bottom view of the binary tree


-- https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=JMBFm__krXw


--
class Solution:
    def bottomView(self, root):
        # code here

        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            m[hd] = (hd, node.data)
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.right, hd + 1))
        
        for i in m:
            res.append(m[i])
            
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


=======================================================================================================================


-- Median of 2 sorted arrays


-- https://www.geeksforgeeks.org/problems/median-of-2-sorted-arrays-of-different-sizes/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
-- https://leetcode.com/problems/median-of-two-sorted-arrays/


--class Solution:
    def MedianOfArrays(self, a, b):
        
        # get the l1 l2 and r1 r2 from the ends of the partition of the array
        
        # get the hight end from the lower length array
        
        n1 = len(a)
        n2 = len(b)
        
        if n1 > n2: return self.MedianOfArrays(b, a)
        
        low = 0
        high = n1
        n = n1 + n2
        
        totalLength = (n1 + n2 + 1) // 2
        
        while low <= high:
            
            mid1 = (high + low) >> 1
            mid2 = totalLength - mid1
            
            l1 = float("-inf")
            l2 = float("-inf")
            r1 = float("inf")
            r2 = float("inf")
            
            if mid1 < n1: r1 = a[mid1]
            
            if mid2 < n2: r2 = b[mid2]
            
            if mid1 - 1 >= 0: l1 = a[mid1 - 1]
            if mid2 - 1 >= 0: l2 = b[mid2 - 1]
            
            if l1 <= r2 and l2 <= r1:
                if n % 2 == 0: return ((max(l1, l2) + min(r1, r2)) / 2)
                else:
                    return max(l1, l2)
            elif l1 > r2:
                high = mid1 -1
            
            else:
                low = mid1 + 1
                
        
        return 0
--

====================================================================================================================

-- Level order traversal in spiral form (zig zag traversal)


-- https://www.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/1?page=2&company=Flipkart&sortBy=submissions
--


--
from collections import deque
'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''        

def findSpiral(root):
    # Code here
    
    res = []
    q = deque([root])
    
    leftToRight = tRUE
    
    while q:
        
        size = len(q)
        row = [0 for _ in range(size)]
        
        for i in range(size):
            
            node = q.popleft()
            
            index = i if leftToRight else size - i - 1 
            
            row[index] = node.data
            
            if node.left:
                q.append(node.left)
            
            if node.right:
                q.append(node.right)
                
        
        for i in row:
            res.append(i)
            
        lefToRight = not leftToRight
                    
        
    return res
--

==========================================================================================================

-- Multiply two numbers


-- https://www.geeksforgeeks.org/problems/multiply-two-strings/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=1vZswirL8Y8


--
class Solution:
    def multiplyStrings(self,s1,s2):
        # code here
        # return the product string
        
        if "0" in s1 or "0" in s2:
            return '0'
            
        i1 = len(s1)
        i2 = len(s2)
        
        # if "0" == s1[0]:
        #     t = True
            
        #     for i in range(s1):
                
                
                
                
            
        # if s1[0] == '-':
        #     flag = 1 - flag
        
        i1 = len(s1)
        i2 = len(s2)
            
        res = [0 for _ in range(i1 + i2)]
        
        s1 = s1[::-1]
        s2 = s2[::-1]
        
        for i in range(len(s1)):
            for j in range(len(s2)):
                
                digit = int(s1[i]) * int(s2[j])
                
                res[i + j] += digit
                
                res[i + j + 1] += res[i + j] // 10 
                res[i + j] = res[i + j] % 10
        
        res = res[::-1]
        beg = 0
        
        while beg < len(res) and res[beg] == 0:
            beg += 1
            
        res = map(str, res[beg:])
        
        return "".join(res)
--


=======================================================================================================

-- Square root


-- https://www.geeksforgeeks.org/problems/square-root/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def floorSqrt(self, n): 
    #Your code here
    
        res = 0
        
        if n <= 1:
            return n
        for i in range(n):
            if i * i <= n:
                res = i
            elif i * i > n:
                break
        
        return res
--


===================================================================================================================

-- Coin change


-- https://www.geeksforgeeks.org/problems/coin-change2448/1?page=2&company=Flipkart&sortBy=submissions
--

--
class Solution:
    def count1(self, coins, n, Sum):
        # code here 
        dp = [[-1 for _ in range(Sum + 1)] for _ in range(n + 1)]
        
        cnt = 0
        def dfs(index, s):
            if s == 0:
                return 1
                
            if dp[index][s] != -1:
                return dp[index][s]
                
            if index >= n:
                return 0
                
            if s < 0:
                return 0
            
            con = 0
            if s - coins[index] >= 0:
                con = dfs(index, s - coins[index]) 
                
            dcon = dfs(index + 1, s)
            
            dp[index][s] = con + dcon
            return con + dcon
        
        return dfs(0, Sum)
        
    
                
    def count(self, coins, n, Sum):
        
        dp = [[0 for _ in range(Sum + 1)] for _ in range(n + 1)]
        
        for i in range(n + 1):
            dp[i][0] = 1
            
        for i in range(1, n + 1):
            for j in range(1, Sum + 1):
                
                if coins[i - 1] <= j:
                    dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j]
                
                else:
                    dp[i][j] = dp[i - 1][j]
            
        return dp[n][Sum]
        
--

============================================================================================================


-- First non repeating character


-- https://www.geeksforgeeks.org/problems/first-non-repeating-character-in-a-stream1216/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-first-non-repeating-character-stream-characters/

--
class Solution:
	def FirstNonRepeating(self, A):
		# Code here
	    list = [] 
        mp = {}
        ans = ''
 
        for ch in A:
            if ch not in mp:  # new character visited first time
                list.append(ch)
                mp[ch] = 1
            else:
                # any repeated character encountered
                if ch in list:
                    list.remove(ch)
            ans += list[0] if list else '#'
 
        return ans
--


=======================================================================================================

-- Lowest common ancester


-- https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-binary-tree/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to return the lowest common ancestor in a Binary Tree.
    def lca(self,root, n1, n2):
        # Code here
        
        def dfs(node):
            
            if not node:
                return None
            
            if n1 == node.data:
                return node
            elif n2 == node.data:
                return node
            
            left_lca = dfs(node.left)
            right_lca = dfs(node.right)
            
            if left_lca and right_lca:
                return node
            
            return left_lca if left_lca else right_lca
            
        
        return dfs(root)
--


=================================================================================================

-- Circular tour


-- https://www.geeksforgeeks.org/problems/circular-tour-1587115620/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/problems/circular-tour-1587115620/1?page=3&company=Flipkart&sortBy=submissions


--
class Solution:
    
    #Function to find starting point where the truck can start to get through
    #the complete circle without exhausting its petrol in between.
    def tour(self,lis, n):
        #Code here
        
        diff = 0
        possible_index = 0
        ans = 0
        
        gas_sum = 0
        cost_sum = 0
        for i in range(n):
            gas_sum += lis[i][0]
            cost_sum += lis[i][1]
            
        if cost_sum > gas_sum:
            return -1
        
        for i in range(n):
            
            diff += lis[i][0] - lis[i][1]
            
            if diff < 0:
                ans = i + 1
                diff = 0
        
        return ans
--


========================================================================================================

-- Bipartite graph

-- https://www.geeksforgeeks.org/problems/bipartite-graph/1?page=3&company=Flipkart&sortBy=submissions
--

-
from collections import deque

class Solution:
	def isBipartite(self, V, adj):
		#code here
		color = [-1] * V
		
		def check(start, color):
    		q = deque()
    		q.append(start)
    		
    		
    		color[start] = 0
    		
            
            while q:
                node = q.popleft()
                
                for i in adj[node]:
                    
                    # if the node is not coloured then color it with the opposite color of the neighbour
                    if color[i] == -1:
                        color[i] = 1 - color[node]
                        q.append(i)
                        
                    # if the color is present then check for the color with neighbour if it is same then return false
                    elif color[node] == color[i]:
                        return False
                        
            return True
            
        for i in range(V):
            if color[i] == -1:
                if not check(i, color):
                    return False
        
        return True
        
-

=====================================================================================================================================

-- Pivot in k rotated array


-- https://www.geeksforgeeks.org/problems/rotation4723/1?page=3&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def findKRotation(self, arr, n):
        # code here
        
        low = 0
        high = n - 1
        res = 0
        while low <= high:
            mid = (high + low) // 2
            
            if arr[mid] > arr[high]:
                low = mid + 1
                
            else:
                high = mid - 1
                
        
        return low

--


====================================================================================================

-- Bipartite graph


-- https://www.geeksforgeeks.org/problems/bipartite-graph/1?page=3&company=Flipkart&sortBy=submissions
--


--
from collections import deque

class Solution:
	def isBipartite(self, V, adj):
		#code here
		color = [-1] * V
		
		def check(start, color):
    		q = deque()
    		q.append(start)
    		
    		
    		color[start] = 0
    		
            
            while q:
                node = q.popleft()
                
                for i in adj[node]:
                    
                    # if the node is not coloured then color it with the opposite color of the neighbour
                    if color[i] == -1:
                        color[i] = 1 - color[node]
                        q.append(i)
                        
                    # if the color is present then check for the color with neighbour if it is same then return false
                    elif color[node] == color[i]:
                        return False
                        
            return True
            
        for i in range(V):
            if color[i] == -1:
                if not check(i, color):
                    return False
        
        return True
--


=======================================================================]=====================================

-- Product array puzzles


-- https://www.geeksforgeeks.org/problems/product-array-puzzle4525/1?page=3&company=Flipkart&sortBy=submissions
-- https://takeuforward.org/arrays/product-of-array-except-itself/


--
class Solution:
    def productExceptSelf(self, nums, n):
        prefix = [1] * n
        suffix = [1] * n

        # Calculate prefix products
        for i in range(1, n):
            prefix[i] = prefix[i - 1] * nums[i - 1]

        # Calculate suffix products
        for i in range(n - 2, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i + 1]

        # Combine prefix and suffix products to get the result
        res = [prefix[i] * suffix[i] for i in range(n)]
        
        return res
--


=========================================================================================================

-- Kth element of the two sorted array


-- https://www.geeksforgeeks.org/problems/k-th-element-of-two-sorted-array1317/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def kthElement(self, a, b, n, m, k):
        
        n1 = len(a)
        n2 = len(b)
        
        if n1 > n2: return self.kthElement(b, a, n, m, k)
        
        low = max(0, k - n2)
        high = min(k, n1)
        n = n1 + n2
        
        totalLength = (n1 + n2 + 1) // 2
        
        while low <= high:
            
            mid1 = (high + low) >> 1
            mid2 = totalLength - mid1
            
            l1 = float("-inf")
            l2 = float("-inf")
            r1 = float("inf")
            r2 = float("inf")
            
            if mid1 < n1: r1 = a[mid1]
            
            if mid2 < n2: r2 = b[mid2]
            
            if mid1 - 1 >= 0: l1 = a[mid1 - 1]
            if mid2 - 1 >= 0: l2 = b[mid2 - 1]
            
            if l1 <= r2 and l2 <= r1:
                return max(l1, l2)
            elif l1 > r2:
                high = mid1 -1
            
            else:
                low = mid1 + 1
                
        
        return 0
--


======================================================================================================

-- Stock buy nd sell 2


-- https://www.geeksforgeeks.org/problems/stock-buy-and-sell2615/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
--


--

from typing import List


class Solution1:
    def stockBuyAndSell(self, n : int, A) -> int:
        # code here
        
		
		dp = [[-1 for _ in range(2)] for _ in range(n + 1)]
		
		def dfs(index, buy):
		    
		    if index >= n:
		        return 0
		        
		    if dp[index][buy] != -1:
		        return dp[index][buy]
		    
		    if buy:
		        profit = max(- A[index] + dfs(index + 1, 0), dfs(index + 1, 1))
		    else:
		        profit = max(A[index] + dfs(index + 1, 1), dfs(index + 1, 0))
		    
		    dp[index][buy] = profit
		    return profit
        
        return dfs(0, 1)
        
        
class Solution:
    def stockBuyAndSell(self, n: int, A) -> int:
        # Initialize a dp array with size (n+1) x 2
        dp = [[0 for _ in range(2)] for _ in range(n + 1)]

        # Iterate over the days in reverse order
        for index in range(n - 1, -1, -1):
            for buy in range(2):
                if buy:
                    dp[index][buy] = max(-A[index] + dp[index + 1][0], dp[index + 1][1])
                else:
                    dp[index][buy] = max(A[index] + dp[index + 1][1], dp[index + 1][0])

        # The result will be the maximum profit starting from day 0 with the option to buy
        return dp[0][1]
--


========================================================================================================

-- Buy stocks and sell 


-- https://www.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/stock-buy-sell/


--
Find the local minima and maxima for every iteration
--

--
class Solution:
    #Function to find the days of buying and selling stock for max profit.
	def stockBuySell(self, price, n):
	    res = []
		#code here
		
        if (n == 1): 
            return
      
        # Traverse through given price array 
        i = 0
        while (i < (n - 1)): 
      
            # Find Local Minima 
            # Note that the limit is (n-2) as we are 
            # comparing present element to the next element 
            while ((i < (n - 1)) and
                    (price[i + 1] <= price[i])): 
                i += 1
      
            # If we reached the end, break 
            # as no further solution possible 
            if (i == n - 1): 
                break
      
            # Store the index of minima 
            buy = i 
            i += 1
      
            # Find Local Maxima 
            # Note that the limit is (n-1) as we are 
            # comparing to previous element 
            while ((i < n) and (price[i] >= price[i - 1])): 
                i += 1
      
            # Store the index of maxima 
            sell = i - 1
            
            res.append((buy, sell))
    
        return res
      
--


======================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions

--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
--

========================================================================================================


-- Chocolate distribution problem


-- 
--

--
class Solution:

    def findMinDiff(self, A,N,M):
        # code here
        
        A.sort()
        min_diff = float('inf')
        
        for i in range(len(A) - M + 1):
            if i + M - 1 < N and (A[i + M - 1] - A[i]) < min_diff :
                min_diff = A[i + M - 1] - A[i] 
                
        return min_diff
--


=============================================================================================================================

-- Job sequencing


-- https://www.geeksforgeeks.org/problems/job-sequencing-problem-1587115620/1?page=3&company=Flipkart&sortBy=submissions
--


--
import heapq

class Solution:
    
    #Function to find the maximum profit and the number of jobs done.
    def JobScheduling(self,a,n):
        
        # code here
        
        
        arr = []
        
        for obj in a:
            arr.append((obj.id, obj.deadline, obj.profit))
            
        n = len(arr)
     
        arr.sort(key=lambda x:x[1])
     
        # initialise the result array and maxHeap
        maxHeap = []
        jobs_done = 0
        profit = 0
        
     
        # starting the iteration from the end
        for i in range(n - 1, -1, -1):
     
            # calculate slots between two deadlines
            if i == 0:
                slots_available = arr[i][1]
            else:
                slots_available = arr[i][1] - arr[i - 1][1]
     
            # include the profit of job(as priority), deadline
            # and job_id in maxHeap
            # note we push negative value in maxHeap to convert
            # min heap to max heap in python
            heapq.heappush(maxHeap, (-arr[i][2], arr[i][1], arr[i][0]))
     
            while slots_available and maxHeap:
     
                # get the job with max_profit
                profits, deadline, job_id = heapq.heappop(maxHeap)
     
                # reduce the slots
                slots_available -= 1
                profit += (-1 * profits)
                jobs_done += 1
     
        # jobs included might be shuffled
        res = []
        res.append(jobs_done)
        res.append(profit)
        
        return res
--

====================================================================================================================

 
-- Search in the roated array


-- https://www.geeksforgeeks.org/problems/search-in-a-rotated-array4618/1?page=3&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=5qGrJbHhqFs


--
class Solution:
    def search(self, a : list, l : int, h : int, key : int):
        # l: The starting index
        # h: The ending index, you have to search the key in this range
        # Complete this function
        
        
        
        
        # first check the number match 
        # second check which part of the array is soretd which is either left or right
        
        # third if the left or right part is sorted check for the element is it lies in that range or not within left and mid
        # or withiin right and mif
        
        
        while l <= h:
            mid = (l + h) // 2
            
            if a[mid] == key:
                return mid
            
            elif a[l] <= a[mid]:
                # left is sorted 
                
                if key >= a[l] and a[mid] >= key:
                    # that means the number can be present in that sorted part
                    h = mid - 1
                else:
                    l = mid + 1
            else:
                if key <= a[h] and a[mid] <= key:
                    l = mid + 1
                else:
                    h = mid - 1
        
        return -1
--


==========================================================================================================================

-- Count ways to reach the nth stairs


-- https://www.geeksforgeeks.org/problems/count-ways-to-reach-the-nth-stair-1587115620/1?page=3&company=Flipkart&sortBy=submissions
--


--

class Solution:
    # Function to count number of ways to reach the nth stair.
    def countWays1(self, n):
        # Initializing dp array with -1
        dp = [-1 for _ in range(n + 1)]
        
        # Helper function to perform DFS with memoization
        def dfs(step):
            if step == n:
                return 1
            if step > n:
                return 0
            if dp[step] != -1:
                return dp[step]
            dp[step] = dfs(step + 1) + dfs(step + 2)
            return (dp[step])
        
        # Starting DFS from 0th step
        return dfs(0)
        
    def countWays2(self, n):
        # Initializing dp array with 1 for the base cases
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1  # There is 1 way to reach the 0th and 1st stairs
        
        # Iteratively filling dp array
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # Returning the number of ways to reach the nth stair
        return (dp[n]) % 1000000007
        
    
    def countWays3(self, n):
        # declaring  two variables to store the count
        prev = 1
        prev2 = 1
        # Running for loop to count all possible ways
        for i in range(2, n+1):
            curr = prev + prev2
            prev2 = prev
            prev = curr
        return prev
        
    
    def countWays(self, n):
        
        dp = [-1 for _ in range(n)]
        def dfs(step):
            if step == n:
                return 1
            
            if step > n:
                return 0
            
            if dp[step] != -1:
                return dp[step]
            
            dp[step] = dfs(step+ 1) + dfs(step + 2)
            return dp[step]
    
        return dfs(0) % 1000000007
--

===========================================================================================================================


-- Find the number of islands


-- https://www.geeksforgeeks.org/problems/find-the-number-of-islands/1?page=3&company=Flipkart&sortBy=submissions
--


--
import sys
sys.setrecursionlimit(10**8)
class Solution:
    def numIslands(self,grid):
        #code here
        
        def is_valid(r, c, row, col, grid):
            if r >= row or c >= col or r < 0 or c < 0 or grid[r][c] == 0:
                return False
            return True
        
        def dfs(r, c, row, col, grid):
            
            grid[r][c] = 0
            
            dx = [-1, 1, 0, 0, -1, -1, 1, 1]
            dy = [0, 0, -1, 1, -1, 1, -1, 1]
            
            for i in range(len(dx)):
                new_x = r + dx[i]
                new_y = c + dy[i]
                
                if is_valid(new_x, new_y, row, col, grid):
                    dfs(new_x, new_y, row, col, grid)
            
            
        cnt = 0
        row = len(grid)
        col = len(grid[0])
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]:
                    cnt += 1
                    dfs(i, j, row, col, grid)
            
        return cnt
--


==============================================================================================================================

-- Tower of Hanoi


-- https://www.geeksforgeeks.org/problems/tower-of-hanoi-1587115621/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=V5vNq2WOPGE


--
class Solution:
    def toh(self, N, fromm, to, aux):
        # Your code here
        
        def toh_cal(n, src, des, helping):
            if n == 1:
                print("move disk {} from rod {} to rod {}".format(n, src, des))
                return 
            
            toh_cal(n - 1, src, helping, des)
            print("move disk {} from rod {} to rod {}".format(n, src, des))
            toh_cal(n - 1, helping, des, src)
            
        toh_cal(N, fromm, to, aux)
        return pow(2, N) - 1
--


===========================================================================================================================


-- Reverse the level order traverssal


-- https://www.youtube.com/watch?v=t6IwIr8mPz0
-- https://www.geeksforgeeks.org/problems/reverse-level-order-traversal/1?page=4&company=Flipkart&sortBy=submissions



-
from collections import deque
def reverseLevelOrder(root):
    # code here
    if not root:
        return root
    
    q = deque()
    q.append(root)
    
    res = []
    
    while q:
        node = q.popleft()
        
        res.append(node.data)
        
        if node.right:
            q.append(node.right)
        
        if node.left:
            q.append(node.left)
        
    return res[::-1]
-


=============================================================================================================================


-- Smallest window in a string containing all the characters of another string


-- https://www.geeksforgeeks.org/problems/smallest-window-in-a-string-containing-all-the-characters-of-another-string-1587115621/1?page=4&company=Flipkart&sortBy=submissions
--



--
from collections import defaultdict

class Solution:
    
    #Function to find the smallest window in the string s consisting
    #of all the characters of string p.
    def smallestWindow(self, s, p):
        #code here
        
        res = ""
        m = defaultdict(int)
        
        for i in p:
            m[i] += 1
        
        i = 0
        j = 0
        n = len(s)
        
        cnt = len(m)
        min_len = float('inf')
        
        while j < n:
            if s[j] in m:
                m[s[j]] -= 1
                
                if m[s[j]] == 0:
                    cnt -= 1
                
            while cnt == 0:
                if j - i + 1 < min_len:
                    min_len = j - i + 1
                    res = s[i:j+1]
                
                if s[i] in m:
                    m[s[i]] += 1
                    if m[s[i]] > 0:
                        cnt += 1
                i += 1

            j += 1
        
        return res if res else -1
--


========================================================================================================================

-- Count Possible Decodings of a given Digit Sequence


-- https://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/
-- https://www.youtube.com/watch?v=dikmR3LaOFk


--
class Solution:
    def CountWays1(self, string):
        n = len(string)
        dp = [-1 for _ in range(n)]
        
        def dfs(index):
            if index >= n:
                return 1
            elif index == n - 1:
                return 1 if string[index] != '0' else 0
            elif string[index] == '0':
                return 0
            elif dp[index] != -1:
                return dp[index]
            else:
                if string[index] == '1' or (string[index] == '2' and string[index + 1] in '0123456'):
                    dp[index] = (dfs(index + 1) % 1000000007 + dfs(index + 2) % 1000000007)
                else:
                    dp[index] = dfs(index + 1) % 1000000007
                return dp[index]
        
        return dfs(0)
        
    
    def CountWays(self, string):
        n = len(string)
        
        if n == 0 or string[0] == '0':
            return 0
        
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        
        for i in range(2, n + 1):
            if string[i - 1] != '0':
                dp[i] = (dp[i - 1])
            
            two_digit = int(string[i - 2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i - 2] % 1000000007
                
        
        return dp[n] % 1000000007
--


===============================================================================================================================

-- Next permutation

-- https://www.geeksforgeeks.org/problems/next-permutation5226/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=LuLCLgMElus


--
class Solution:
    def nextPermutation(self, N, A):
        
        # Find the inflation point from the end of the array
        # then for that index number find the number which is next greater than that from the end of the array
        # then swap them and from inflation point reverse the array numbers

        if N == 0 or N == 1:
            return
        
        def swap(a, b):
            A[a], A[b] = A[b], A[a]

        def reverse(i, j):
            while i < j:
                swap(i, j)
                i += 1
                j -= 1
        
        # Step 1: Find the first decreasing element from the end
        i = N - 2
        while i >= 0 and A[i] >= A[i + 1]:
            i -= 1
        
        # Step 2: If we found a valid 'i', find the smallest element greater than A[i] to the right of 'i'
        if i >= 0:
            j = N - 1
            while A[j] <= A[i]:
                j -= 1
            # Step 3: Swap the elements at 'i' and 'j'
            swap(i, j)
            
        # Step 4: Reverse the elements from 'i + 1' to the end of the array
        reverse(i + 1, N - 1)
        
        return A
            
--


============================================================================================================================


-- Activity Selction


-- https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/
-- https://www.geeksforgeeks.org/problems/activity-selection-1587115620/1?page=4&company=Flipkart&sortBy=submissions


--
class Solution:
    
    #Function to find the maximum number of activities that can
    #be performed by a single person.
    def activitySelection(self,n,start,end):
        
        # code here
        arr = []
        
        # Creating a list of tuples (start, end)
        for i in range(n):
            arr.append((start[i], end[i]))
        
        # Sorting activities based on their end time first and start time second
        arr.sort(key=lambda x: (x[1], x[0]))
        
        # The first activity is always selected
        prev_end = arr[0][1]
        cnt = 1
        
        # Iterate over the remaining activities
        for i in range(1, n):
            # If the start time of the current activity is greater or equal
            # to the end time of the previously selected activity
            if arr[i][0] > prev_end:
                cnt += 1
                prev_end = arr[i][1]
        
        return cnt
--


==============================================================================================================================

-- Bitonic point


-- https://www.geeksforgeeks.org/problems/maximum-value-in-a-bitonic-array3001/1?page=4&company=Flipkart&sortBy=submissions


--
class Solution:

	def findMaximum(self,arr, n):
		# code here
		
		high = n - 1
		low = 0
		
		while low <= high:
		    mid = low + (high - low) // 2
		    
		    if(arr[mid] > arr[mid - 1] and (mid + 1 < n and arr[mid] > arr[mid + 1])): 
                return arr[mid] 
            # move to the right part 
            elif mid + 1 < n and (arr[mid] < arr[mid + 1]): 
                low = mid + 1
                  
            # move to the right part 
            else: 
                high = mid - 1
		   
	    return n
--


============================================================================================================================

-- Merge two sorted linked lists


-- https://www.geeksforgeeks.org/problems/merge-two-sorted-linked-lists/1?page=4&company=Flipkart&sortBy=submissions
--


--
def sortedMerge(head1, head2):
    # code here
    
    pt1 = head1
    pt2 = head2
    dummy = Node(0)
    temp = dummy
    
    
    while pt1 and pt2:
        if pt1.data < pt2.data:
            temp.next = pt1
            pt1 = pt1.next
        else:
            temp.next = pt2
            pt2 = pt2.next
        
        temp = temp.next
        
    if pt1:
        temp.next = pt1
    
    if pt2:
        temp.next = pt2
    
    
    return dummy.next
    
    
def sortedMerge2(head1, head2):
    # Dummy node to provide a starting point for the merged list
    dummy = Node(0)
    # Tail pointer to build the new list
    tail = dummy
    
    # Pointers to traverse the input lists
    pt1 = head1
    pt2 = head2
    
    # Traverse both lists and append the smaller value to the merged list
    while pt1 and pt2:
        if pt1.data < pt2.data:
            tail.next = pt1
            pt1 = pt1.next
        else:
            tail.next = pt2
            pt2 = pt2.next
        tail = tail.next
    
    # If there are remaining nodes in either list, append them
    if pt1:
        tail.next = pt1
    elif pt2:
        tail.next = pt2
    
    # Return the next node of the dummy node, which is the head of the merged list
    return dummy.next
--


==========================================================================================================

-- Lowesr common ancestor in a bst


-- https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-bst/1?page=4&company=Flipkart&sortBy=submissions
--


--
def LCA1(root, n1, n2):
    #code here.
    
    def dfs(node):
        
        if not node:
            return None
            
            
        if node.data == n1 or node.data == n2:
            return node
            
        left = dfs(node.left)
        right = dfs(node.right)
        
        if left and right:
            return node
        
        if left:
            return left
            
        else:
            return right
    
    return dfs(root)
    

def LCA(node, n1, n2):
    
    def lowest_common_ancestor(root, p, q):
        if not root or root.data == p or root.data == q:
            return root
     
        left_lca = lowest_common_ancestor(root.left, p, q)
        right_lca = lowest_common_ancestor(root.right, p, q)
     
        if left_lca and right_lca:
            return root
     
        return left_lca if left_lca else right_lca
    
    return lowest_common_ancestor(node, n1, n2)
--


==================================================================================================================


-- Flattening a Linked list


-- https://www.geeksforgeeks.org/problems/flattening-a-linked-list/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=ysytSSXpAI0


--
def flatten(root):
    #Your code here
    
    
    def mergell(a, b):
        
        dummy = Node(0)
        temp = dummy
        
        while a and b:
            if a.data < b.data:
                temp.bottom = a
                a = a.bottom
            else:
                temp.bottom = b
                b = b.bottom
            temp = temp.bottom
        
        if a:
            temp.bottom = a
        else:
            temp.bottom = b
        
        return dummy.bottom
    
    
    if not root or not root.next:
        return root
    
    root.next = flatten(root.next)
    
    # traverse till the end and merge the last two recursively 
    root = mergell(root, root.next)
    
    return root
--


=============================================================================================================================

-- Word Break


-- https://www.youtube.com/watch?v=Sx9NNgInc3A
-- https://www.geeksforgeeks.org/problems/word-break1352/1?page=4&company=Flipkart&sortBy=submissions


--
class Solution:
    def wordBreak1(self, n, s, dictionary):
        # Complete this function
        
        word_set = set(dictionary)
    
        # Initialize the dp array
        dp = [False] * (len(s) + 1)
        dp[0] = True  # Empty string can be segmented
        
        # Fill the dp array
        for i in range(1, len(s) + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break
        
        # The answer is whether the entire string can be segmented
        return 1 if dp[len(s)] else 0
                
            
    
    def wordBreak(self, n, s, dic):
        
        dp = [False] * (len(s) + 1)
        
        dp[len(s)] = True
        
        
        for i in range(len(s) - 1, -1, -1):
            for w in dic:
                
                if len(w) + i <= len(s) and s[i : i + len(w)] == w:
                    dp[i] = dp[i + len(w)]
                if dp[i]:
                    break
        
        return dp[0]
--


==============================================================================================================================

-- Delete middle of linked list


-- https://www.geeksforgeeks.org/problems/delete-middle-of-linked-list/1?page=4&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def deleteMid(self,head):
        '''
        head:  head of given linkedList
        return: head of resultant llist
        '''
        
        #code here
        
        fast = head
        slow = head
        
        if not head:
            return head
        
    
        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
            
        # delete the second midd
            
        prev.next = slow.next
            
        return head
--


====================================================================================================================

-- Maximum sum path in matrix


-- https://www.geeksforgeeks.org/problems/path-in-matrix3805/1
-- https://www.geeksforgeeks.org/maximum-path-sum-matrix/


--
class Solution:
    def maximumPath(self, N, mat):
        # code here
        
        n = len(mat)
        m = len(mat[0])
        
        if n == 1:
            return max(mat[0])
        
        for i in range(1, n):
            res = -1
            for j in range(m):
                
                if j > 0 and j < m - 1:
                    mat[i][j] += max(mat[i - 1][j], mat[i - 1][j - 1], mat[i - 1][j + 1])
                
                elif j == 0:
                    mat[i][j] += max(mat[i - 1][j], mat[i - 1][j + 1])
                
                elif j == m - 1:
                    mat[i][j] += max(mat[i - 1][j - 1], mat[i - 1][j])
                    
                res = max(mat[i][j], res)
        
        return res
--


==========================================================================================================================


-- Gold mine problem


-- https://www.geeksforgeeks.org/problems/gold-mine-problem2608/1?page=4&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def maxGold(self, n, m, mat):
        # code here
        
        n = len(mat)
        m = len(mat[0])
        
        if n == 1:
            result = 0
            for i in range(1, m):
                mat[0][i] += mat[0][i - 1]
                result = max(mat[0][i], result)
            return result
        
        
        if n == 1:
            return max(mat[0])
        
        for j in range(1, m):
            res = -1
            for i in range(n):
                
                if i > 0 and i < n - 1:
                    mat[i][j] += max(mat[i][j - 1], mat[i - 1][j - 1], mat[i + 1][j - 1])
                
                elif i == 0:
                    mat[i][j] += max(mat[i][j - 1], mat[i + 1][j - 1])
                
                elif i == n - 1:
                    mat[i][j] += max(mat[i][j - 1], mat[i - 1][j - 1])
                    
                res = max(mat[i][j], res)
        
        return res
--


================================================================================================================


-- Largest Bst


-- https://www.geeksforgeeks.org/problems/largest-bst/1?page=4&company=Flipkart&sortBy=submissions
--



--
class Solution:
    # Return the size of the largest sub-tree which is also a BST
    def largestBst(self, root):
        #code here
        
        # return [len, min, max] for the node where len is the length of the longest bst
        
        def bst(node):
            if not node:
                # send length, minimumVslue, maximumValue
                return [0, float('inf'), float('-inf')]
                
            left = bst(node.left)
            right = bst(node.right)
            
            # if the current node is greater than max of left subtree and less than min of right subtree 
            
            if node.data < right[1] and node.data > left[2]:
                return [left[0] + right[0] + 1, min(node.data, left[1]), max(node.data, right[2])]
            
            return [max(left[0], right[0]), float('-inf'), float('inf')]
        
        result = bst(root)
        return result[0]
--


===================================================================================================================

-- Minimum spanning tree


-- https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=mJcZjjKzeqk&t=889s

--
from heapq import heappop, heappush
from collections import defaultdict

class Solution:
    
    #Function to find sum of weights of edges of the Minimum Spanning Tree.
    def spanningTree(self, V, adj):
        #code here
        
        # take the min heap and put (weight, node) in it
        
        # Creating a graph as a default dictionary of lists
        g = defaultdict(list)
        
        # Filling the adjacency list
        for u in range(V):
            for v, w in adj[u]:
                g[u].append((w, v))
                g[v].append((w, u))  # Assuming undirected graph

        # Initializing the min heap and the visited list
        heap = []
        vis = [False] * V
        
        # Pushing the starting node (0) with weight 0
        heappush(heap, (0, 0))
        mst_weight = 0

        while heap:
            # Popping the smallest weight edge
            wt, node = heappop(heap)
            
            # If the node is already visited, continue to the next
            if vis[node]:
                continue
            
            # Mark the node as visited
            vis[node] = True
            
            # Add the edge weight to the MST total weight
            mst_weight += wt
            
            # Examine all adjacent nodes
            for weight, neighbor in g[node]:
                if not vis[neighbor]:
                    heappush(heap, (weight, neighbor))

        return mst_weight
--


======================================================================================================================

-- Maximum Occuring character


-- https://geeksforgeeks.org/problems/maximum-occuring-character-1587115620/1?page=5&company=Flipkart&sortBy=submissions
--

-
from collections import defaultdict

class Solution:
    
    #Function to find the maximum occurring character in a string.
    def getMaxOccurringChar(self,s):
        #code here
        mp = defaultdict(int)
        n = len(s)
        ans = ''
     
        # to check count of answer character is less or greater
        # than another elements count
        cnt = 0
     
        # traverse the string
        for i in range(n):
            # push element into dictionary and increase its frequency
            if s[i] in mp:
                mp[s[i]] += 1
            else:
                mp[s[i]] = 1
     
            # update answer and count
            if cnt < mp[s[i]]:
                ans = s[i]
                cnt = mp[s[i]]
            elif cnt == mp[s[i]]:
                upChar = ord(s[i]) - ord('a')
                preChar = ord(ans) - ord('a')
                
                if upChar < preChar:
                    ans = s[i]
     
        return ans
-


==============================================================================================================================


-- K sum paths in Binary tree (using hashmaps)


-- https://www.geeksforgeeks.org/problems/k-sum-paths/1?page=5&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def sumK(self,root,target):
        # code here
        
        #  calculate the current sum
        # if sum - k in hashmap increase the count to `
        # this approach is used event for the subtree which equals this sum and not only from the root
        
        mp = defaultdict(int)
        mp[0] = 1
        global ans
        ans = 0
        
        def dfs(node, csum, k):
            global ans
            
            if not node:
                return 0
                
            csum += node.data
            
            if csum - k in mp:
                ans += mp[csum - k]
            mp[csum] += 1
            
            dfs(node.left, csum, k)
            dfs(node.right, csum, k)
            mp[csum] -= 1
        
        dfs(root, 0, target)
        return ans
--


==============================================================================================================================

-- Largest Rectangle in Historgram


-- https://www.geeksforgeeks.org/problems/maximum-rectangular-area-in-a-histogram-1587115620/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
-- https://www.youtube.com/watch?v=X0X6G-eWgQ8&t=1038s
-- https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/


--
class Solution:
    
    #Function to find largest rectangular area possible in a given histogram.
    def getMaxArea(self,arr):
        #code here
        
        # find the smaller left and smaller right for all the array elements
        
        # then use this formula a[i] * (left_small[i] - right_small[i] + 1) to get the area
        n = len(arr)
        s = []
        
        left_smaller = [0] * n
        right_smaller = [n - 1] * n
        
        for i in range(n):
            while s and arr[s[-1]] >= arr[i]:
                s.pop()
                
            if s:
                left_smaller[i] = s[-1] + 1
            s.append(i)
        
        s = []
        
        for i in range(n - 1, -1, -1):
            while s and arr[s[-1]] >= arr[i]:
                s.pop()

            if s:
                right_smaller[i] = s[-1] - 1
            s.append(i)
            
        
        res = float("-inf")
        ans = []
        
        
        for i in range(n):
            ans.append(arr[i] * (right_smaller[i] - left_smaller[i] + 1))
            res = max(res, ans[i])
        
        return res
--


======================================================================================================================

-- Alien Dictionary 


-- https://www.geeksforgeeks.org/problems/alien-dictionary/1?page=5&company=Flipkart&sortBy=submissions
--


--
#User function Template for python3

from collections import defaultdict, deque

class Solution:
    def findOrder(self,d, N, K):
    # code here
    
        
    # here for the order and all we use topological sort
    # but first we need to get the order of it right
    # so traverse throught the array and check for the nodes 
    # which appears in increasing order
        
        def topoSort(V, adj):
        
            ind = [0] * V
            g = defaultdict(list)
            
            for i in range(V):
                for node in adj[i]:
                    g[i].append(node)
                    ind[node] += 1
                
            q = deque()
            
            for i in range(V):
                if ind[i] == 0:
                    q.append(i)
                    
            
            
            res = []
            while q:
                
                node = q.popleft()
                res.append(node)
                
                for i in g[node]:
                    ind[i] -= 1
                    
                    if ind[i] == 0:
                        q.append(i)
            
            return res
            
            
        g = defaultdict(list)
        
        for i in range(N - 1):
            s1 = d[i]
            s2 = d[i + 1]
            
            for i in range(min(len(s1), len(s2))):
                if s1[i] != s2[i]:
                    g[ord(s1[i]) - ord('a')].append(ord(s2[i]) - ord('a'))
                    break
        
        result = topoSort(K, g)
        
        res = ""
        
        for i in range(len(result)):
            res += chr(ord('a') + result[i])
            
        return res
--


================================================================================================================================

-- Shortest direction


--
-- https://www.geeksforgeeks.org/problems/shortest-direction4201/1?page=9&company=Flipkart&sortBy=submissions


--
class Solution:
    def shortestPath(self, s):
        # code here
        
        
        x = 0
        y = 0
        
        for i in s:
            if i == 'S': y -= 1
            if i == 'N': y += 1
            if i == 'W': x -= 1
            if i == 'E':
                x += 1
        
        res = ""
        if x > 0: 
            for i in range(abs(x)): 
                res += "E"
                x -= 1
                
        if y > 0: 
            for i in range(abs(y)): 
                res += "N"
                y -= 1
                
        if y < 0: 
            for i in range(abs(y)): 
                res += "S"
                y += 1

        if x < 0: 
            for i in range(abs(x)): 
                res += "W"
                x += 1
                
        return res
        
--


============================================================================================================================

-- Largest rectangle in histogram


-- https://leetcode.com/problems/largest-rectangle-in-histogram/
--


--
    def largestRectangleArea(self, arr):

        stack = []

        ans = 0
        n = len(arr)

        for i in range(n + 1):
            while stack and (i == n or arr[stack[-1]] >= arr[i]):
                temp = arr[stack.pop()]

                if not stack:
                    width = i
                else: width = i - stack[-1] - 1
                ans = max(ans, width * temp)

            stack.append(i)

        return ans
--


=============================================================================================================================

-- Max Rectangle


-- https://www.geeksforgeeks.org/problems/max-rectangle/1?page=5&company=Flipkart&sortBy=submissions
--


--
class Solution:
    def maxArea(self,M, N, m):
        # code here
        
        res = 0
        def largestRectangleArea(arr):

            stack = []
    
            ans = 0
            n = len(arr)
    
            for i in range(n + 1):
                while stack and (i == n or arr[stack[-1]] >= arr[i]):
                    temp = arr[stack.pop()]
    
                    if not stack:
                        width = i
                    else: width = i - stack[-1] - 1
                    ans = max(ans, width * temp)
    
                stack.append(i)
    
            return ans
            
        
        h = [0] * m
        
        for i in range(N):
            for j in range(m):
                if M[i][j] == 1:
                    h[j] += 1
                else:
                    h[j] = 0
        
            res = max(res, largestRectangleArea(h))
        
        return res
--


========================================================================================================================

-- Solve the sudoku

 
-- https://www.geeksforgeeks.org/problems/solve-the-sudoku-1587115621/1?page=5&company=Flipkart&sortBy=submissions
--


--
class Solution:

    # Function to find a solved Sudoku.
    def SolveSudoku(self, grid):
        n = len(grid)
        m = len(grid[0])

        def isvalid(mat, r, c, k):
            # Check the row
            for i in range(9):
                if mat[r][i] == k:
                    return False
            # Check the column
            for i in range(9):
                if mat[i][c] == k:
                    return False
            # Check the 3x3 subgrid
            startRow = r - r % 3
            startCol = c - c % 3
            for i in range(3):
                for j in range(3):
                    if mat[i + startRow][j + startCol] == k:
                        return False
            return True

        def solve(mat):
            for i in range(n):
                for j in range(m):
                    if mat[i][j] == 0:
                        for k in range(1, 10):
                            if isvalid(mat, i, j, k):
                                mat[i][j] = k
                                if solve(mat):
                                    return True
                                mat[i][j] = 0
                        return False
            return True

        return solve(grid)

    # Function to print grids of the Sudoku.
    def printGrid(self, arr):
        res = []
        for row in range(len(arr)):
            for col in range(len(arr[row])):
                res.append(str(arr[row][col]))

        print(" ".join(res))
--


===============================================================================================================================

-- Find median in a stream


-- https://www.geeksforgeeks.org/problems/find-median-in-a-stream-1587115620/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=cjQNm2eS6Lw

--
from heapq import heappop, heappush

class Solution:
    # h1 is the max heap to keep all the smaller half
    # h2 is the min heap to keep all the greater half
    h1 = []
    h2 = []    
    # take two heaps where in the one is max heap and another is min heap
    def balanceHeaps(self):
        # Balance the two heaps size , such that difference is not more than one.
        # code here
        pass
        
        
        
        
        
        
    '''    
    You don't need to call getMedian it will be called itself by driver code
    for more info see drivers code below.
    '''
    
    def getMedian(self):
        # return the median of the data received till now.
        # code here
        if len(self.h1) == len(self.h2):
            return (self.h1[0] + self.h2[0])//2
        else:
            return - self.h1[0]
        
        
    def insertHeaps(self,x):
        #:param x: value to be inserted
        #:return: None
        # code here
        
        if not len(self.h1):
            heappush(self.h1, -x)
        
        if len(self.h1) > len(self.h2):
            if self.h1[0] > x:
                temp = heappop(self.h1)
                heappush(self.h1, x)
                heappush(self.h2, -temp)
            else:
                heappush(self.h2, x)
        else:
            if self.h1[0] > x:
                heappush(self.h1, x)
            else:
                heappush(self.h2, x)
                temp2 = heappop(self.h2)
                heappush(self.h1, -1 * temp2)
            
--


===============================================================================================================================

-- Matrix chain multiplication


-- https://www.geeksforgeeks.org/problems/matrix-chain-multiplication0303/1?page=4&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=pDCXsbAw5Cg


--
class Solution:
    def matrixMultiplication1(self, N, arr):
        # code here
        
        def loop(i, j):
            if i == j:
                return 0
                
            if dp[i][j] != -1:
                return dp[i][j]
            
            mini = float("inf")
            
            for k in range(i, j):
                res = arr[i - 1] * arr[k] * arr[j] + loop(i, k) + loop(k + 1, j)
                mini = min(res, mini)
            
            dp[i][j] = mini
            return mini
                
        
        dp = [[-1 for _ in range(N + 1)] for _ in range(N + 1)]
        
        return loop(1, N - 1)
    
    
    def matrixMultiplication(self, N, arr):
        
        dp = [[0 for _ in range(N)] for _ in range(N)]
        
        for i in range(N):
            dp[i][i] = 0
        
        for i in range(N - 1, 0, -1):
            for j in range(i + 1, N):
                mini = float("inf")
                
                for k in range(i, j):
                    steps = arr[i - 1] * arr[k] * arr[j] + dp[i][k] + dp[k + 1][j]
                    mini = min(steps, mini)
                
                dp[i][j] = mini
        
        return dp[1][N - 1]
--

==============================================================================================================================

-- Minimum cost to cut a stick


-- https://leetcode.com/problems/minimum-cost-to-cut-a-stick/
-- https://www.youtube.com/watch?v=xwomavsC86c


--
class Solution(object):
    def minCost1(self, n, cuts):
        """
        :type n: int
        :type cuts: List[int]
        :rtype: int
        """
        cuts.append(n)
        cuts.insert(0, 0)
        cuts.sort()

        dp = [[-1 for _ in range(len(cuts))] for _ in range(len(cuts))]

        def loop(i, j):
            if i > j:
                return 0

            if dp[i][j] != -1:
                return dp[i][j]

            mini = float("inf")


            for ind in range(i, j+1):
                cut = cuts[j + 1] - cuts[i - 1] + loop(i, ind - 1) + loop(ind + 1, j)
                mini = min(mini, cut)
            dp[i][j] = mini
            return mini

        return loop(1, len(cuts) - 2)

    def minCost(self, n, cuts):
        cuts.append(n)
        cuts.insert(0, 0)
        cuts.sort()

        dp = [[0 for _ in range(len(cuts) +2)] for _ in range(len(cuts) + 2)]

        for i in range(len(cuts), 0, -1):
            for j in range(1, len(cuts) + 1):
                if i > j:
                    continue

                mini = float("inf")

                for ind in range(i, j + 1):
                    cut = cuts[j + 1] - cuts[i - 1] + dp[i][ind - 1] + dp[ind + 1][j]
                    mini = min(mini, cut)

                dp[i][j] = mini
        
        return dp[1][len(cuts)]

--


=================================================================================================================================

-- Steps for knight


-- https://geeksforgeeks.org/problems/steps-by-knight5927/1?page=5&company=Flipkart&sortBy=submissions
--


--
class Solution:

    # Function to find out minimum steps Knight needs to reach target position.
    def minStepToReachTarget(self, KnightPos, TargetPos, N):
        # Code here
        
        vis = [[0 for _ in range(N)] for _ in range(N)]
        
        def is_valid(r, c, row, col):
            if r < 0 or c < 0 or vis[r][c] or r >= row or c >= col:
                return 0
            return 1
        
        def dfs(r, c, row, col, des, steps):
            
            if not is_valid(r, c, row, col):
                return float('inf')
            
            if r == des[0] and c == des[1]:
                return steps
               
            min_steps = float('inf')
            next_steps = [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (1, -2), (-1, 2), (1, 2)]
            
            vis[r][c] = 1
            
            for i, j in next_steps:
                nr = r + i
                nc = c + j
                
                min_steps = min(min_steps, dfs(nr, nc, row, col, des, steps + 1))
                
            vis[r][c] = 0
            
            return min_steps
        
        result = dfs(KnightPos[0] - 1, KnightPos[1] - 1, N, N, (TargetPos[0] - 1, TargetPos[1] - 1), 0)
        return result if result != float('inf') else -1
--


==================================================================================================================================

-- Max sum without adjacents


-- https://www.geeksforgeeks.org/problems/max-sum-without-adjacents2430/1?page=5&company=Flipkart&sortBy=submissions
--



--
class Solution:
	
	def findMaxSum1(self,arr, n):
		# code here
		dp = [-1 for _ in range(n + 1)]
		
		def dfs(ind):
		    if ind < 0:
		        return 0
		        
		    if ind == 0:
		        return arr[ind]
		    
		    if dp[ind] != -1:
		        return dp[ind]
		        
		    within = arr[ind] + dfs(ind - 2)
		    without = dfs(ind - 1)
		    
		    dp[ind] = max(within, without)
		    
		    return max(within, without)
        
        return dfs(n - 1)
        
        
    def findMaxSum(self, arr, n):
        if n == 0:
            return 0
        if n == 1:
            return arr[0]
        
        dp = [0 for _ in range(n)]
        
        dp[0] = arr[0]
        dp[1] = max(arr[0], arr[1])
        
        for i in range(2, n):
            dp[i] = max(arr[i] + dp[i - 2], dp[i - 1])
        
        return dp[n - 1]
--


============================================================================================================================


-- Merge K Sorted Arrays

-- https://www.geeksforgeeks.org/problems/merge-k-sorted-arrays/1?page=5&company=Flipkart&sortBy=submissions
--


-- Usual method
class Solution:
    #Function to merge k sorted arrays.
    def mergeKArrays(self, arr, K):
        # code here
        # return merged list
        n = len(arr)
        m = len(arr[0])
        
        a = []
        
        for i in range(n):
            for j in range(m):
                a.append(arr[i][j])
        
        a.sort()
        return a
--


==============================================================================================================================


-- Connect Nodes at Same level


-- https://www.geeksforgeeks.org/problems/connect-nodes-at-same-level/1?page=5&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/connect-nodes-at-same-level/


--
import sys
sys.setrecursionlimit(50000)
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        self.nextRight = None
class Solution:
    #Function to connect nodes at same level.
    def connect(self, root):
        if root is None:
            return
     
        head = root
        # Create an empty queue like level order traversal
        queue = []
        queue.append(root)
        while len(queue) != 0:
     
            # size indicates no. of nodes at current level
            size = len(queue)
     
            # for keeping track of previous node
            prev = Node(None)
            for i in range(size):
                temp = queue.pop(0)
                if temp.left:
                    queue.append(temp.left)
                if temp.right:
                    queue.append(temp.right)
                if prev != None:
                    prev.nextRight = temp
                    prev = temp
            prev.nextRight = None
        
        return head
--


===================================================================================================================================


-- Nodes at given distance in binary tree


-- https://www.geeksforgeeks.org/problems/nodes-at-given-distance-in-binary-tree/1?page=5&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=i9ORlEy6EsI


--
from collections import defaultdict

# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

class Solution:
    def KDistanceNodes(self, root, target, k):
        if not root:
            return []

        # Dictionary to store parent pointers of binary tree nodes
        parent_track = defaultdict(lambda: None)
        
        # Function to mark the parent pointers in the tree
        def mark_parent(node, t):
            q = [node]
            target_node = None
            while q:
                temp = q.pop(0)
                if temp.data == t:
                    target_node = temp
                    
                if temp.left:
                    parent_track[temp.left] = temp
                    q.append(temp.left)
                if temp.right:
                    parent_track[temp.right] = temp
                    q.append(temp.right)
                
            return target_node

        target_node = mark_parent(root, target)
        
        if not target_node:
            return []
        
        # Start BFS from the target node
        q = [target_node]
        vis = defaultdict(bool)
        vis[target_node] = True
        current_level = 0
        
        while q:
            if current_level == k:
                break
            current_level += 1
            size = len(q)
            for i in range(size):
                temp = q.pop(0)
                
                # Check the left child
                if temp.left and not vis[temp.left]:
                    q.append(temp.left)
                    vis[temp.left] = True
                
                # Check the right child
                if temp.right and not vis[temp.right]:
                    q.append(temp.right)
                    vis[temp.right] = True
                    
                # Check the parent
                parent = parent_track[temp]
                if parent and not vis[parent]:
                    q.append(parent)
                    vis[parent] = True

        # Collect all nodes at distance k
        res = []
        while q:
            temp = q.pop(0)
            res.append(temp.data)
        
        return sorted(res)
--


===================================================================================================================================


-- Serialize and Deserialize Binary tree


-- https://www.geeksforgeeks.org/problems/serialize-and-deserialize-a-binary-tree/1?page=5&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=u4JAi2JJhI8


--
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    #Function to serialize a tree and return a list containing nodes of tree.
    def serialize(self, root):
        #code here
        
        res = []
        def dfs(node):
            if not node:
                res.append("N")
                return 
            
            res.append(node.data)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        
        return res
    
    #Function to deserialize a list and construct the tree.   
    def deSerialize(self, a):
        #code here
        
        self.i = 0
        
        def dfs():
            if a[self.i] == "N":
                return None
            
            node = Node(a[self.i])
            self.i += 1
            
            node.left = dfs()
            node.right = dfs()
            return node
            
        return dfs()
--


==================================================================================================================


-- kth largest element


-- https://www.geeksforgeeks.org/problems/kth-largest-element-in-a-stream2220/1?page=5&company=Flipkart&sortBy=submissions
--


--
import heapq

class Solution:
    def kthLargest(self, k, arr, n):
        queue = []
        ans = []

        for i in range(n):
            heapq.heappush(queue, arr[i])

            if len(queue) < k:
                ans.append(-1)
            else:
                while len(queue) > k:
                    heapq.heappop(queue)
                ans.append(queue[0])

        return ans
--


============================================================================================================================

-- Maximum width of the tree


-- https://www.geeksforgeeks.org/problems/maximum-width-of-tree/1?page=5&company=Flipkart&sortBy=submissions
--


--
'''
# Node Class:
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
'''
class Solution:
    #Function to get the maximum width of a binary tree.
    def getMaxWidth(self,root):
       
        #code here
        
        q = []
        
        q.append(root)
        res = 0
        while q:
            size = len(q)
            
            res = max(res, size)
            
            for i in range(size):
                temp = q.pop(0)
                
                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
        
        
        return res
--


============================================================================================================================


-- Find the string in the grid


--
-- https://www.geeksforgeeks.org/problems/find-the-string-in-grid0111/1?page=5&company=Flipkart&sortBy=submissions

--
class Solution:
	def searchWord(self, grid, word):
		# Code here
        n = len(grid)
        m = len(grid[0])
        word_len = len(word)
        
        # Define the 8 possible directions: (dx, dy)
        directions = [
            (-1, 0), (1, 0), (0, -1), (0, 1),  # up, down, left, right
            (-1, -1), (-1, 1), (1, -1), (1, 1)  # 4 diagonals
        ]
        
        def is_valid(x, y):
            return 0 <= x < n and 0 <= y < m
        
        def search_from(x, y, word):
            found_positions = []
            for dx, dy in directions:
                match = True
                for k in range(word_len):
                    nx, ny = x + k * dx, y + k * dy
                    if not is_valid(nx, ny) or grid[nx][ny] != word[k]:
                        match = False
                        break
                if match:
                    found_positions.append((x, y))
            return found_positions
        
        result = set()
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] == word[0]:
                    found_positions = search_from(i, j, word)
                    result.update(found_positions)
        
        result = sorted(result)  # Sort lexicographically
        return result
--


=============================================================================================================================


-- Binary strings


-- https://www.geeksforgeeks.org/problems/binary-string-1587115620/1?page=5&company=Flipkart&sortBy=submissions
--


--
class Solution:
    
    #Function to count the number of substrings that start and end with 1.
    def binarySubstring(self,n,S):
        #code here
        positions = [i for i, char in enumerate(S) if char == '1']
        
        # Calculate the number of such substrings
        n = len(positions)
        if n < 2:
            return 0  # If less than 2 '1's, no such substrings
        
        # Number of substrings that start and end with '1'
        num_substrings = (n * (n - 1)) // 2
        
        return num_substrings
--


=================================================================================================================================

-- Maximum digit formed by swapping only adjacents if the parity of them is same


-- https://www.geeksforgeeks.org/find-the-maximum-number-formed-by-swapping-digits-of-same-parity/
--


--
# Method to print maximum possible number
def max_number(s):
    # N stores the length of String
    n = len(s)

    # string ans to store the answer
    ans = ""
    freq = [0] * 10
    left = 0
    
    while left < n:
        
        right = left
        
        while right < n - 1 and int(s[right]) % 2 == int(s[right + 1]) % 2:
            freq[int(s[right])] += 1
            right += 1
        
        freq[int(s[right])] += 1
        
        for i in range(len(freq) - 1, -1, -1):
            while freq[i] > 0:
                ans += str(i)
                freq[i] -= 1
        
        left = right + 1
        
        
    print(ans)
    return ans
--


====================================================================================================================================

-- Largest Number by swapping any digits with same parity


-- https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/submissions/1343181117/
-- https://www.youtube.com/watch?v=QMFBm58tpHI&t=38s


--
class Solution(object):
    def largestInteger(self, num):
        """
        :type num: int
        :rtype: int
        """
        s = str(num)

        evens = []
        odds = []

        for i in s:
            if int(i) % 2:
                odds.append(int(i))
            
            else:
                evens.append(int(i))
        
        evens.sort(reverse=True)
        odds.sort(reverse=True)
        
        ans = ""
        for i in s:
            if int(i) % 2:
                ans += str(odds.pop(0))
            else:
                ans += str(evens.pop(0))
        
        return int(ans)
--


=====================================================================================================================

-- Count the occurances of anagrams


-- https://www.geeksforgeeks.org/problems/count-occurences-of-anagrams5839/1?page=5&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=MW4lJ8Y0xXk


--
from collections import Counter
class Solution:

	
	def search1(self,pat, txt):
	    # code here
	    
	    n = len(pat)
	    
	    pat_map = [0] * 26
	    
	    cnt = 0
	    
	    for i in pat:
	        pat_map[ord(i) - ord('a')] += 1
	        
        i = 0
        
	    while i + n < len(txt) + 1:
	        if not pat_map[ord(txt[i]) - ord('a')]:
	            i += 1
	        
	        sentence = txt[i: i + n]
	        txt_map = [0] * 26
	                
	        for j in sentence:
	            txt_map[ord(j) - ord('a')] += 1 
	        
	        if pat_map == txt_map:
	            cnt += 1
	       
	        i += 1
	    
	    
	    return cnt
	    
    
    def search3(self,pat, txt):
        
        k = len(pat)
        d = {}
        t = {}
        
        # Populate dictionary d with character counts from pattern
        for i in pat:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
    
        i = 0
        cur_s = ""
        cnt = 0
    
        # Traverse through the text
        for j in range(len(txt)):
            # Add current character to t
            if txt[j] in t:
                t[txt[j]] += 1
            else:
                t[txt[j]] = 1
    
            # If the window size is less than k, continue forming the window
            if j - i + 1 < k:
                continue
            elif j - i + 1 == k:
                # If dictionaries are equal, pattern found
                if d == t:
                    print(d)
                    cnt += 1
            else:
                # Remove character at position i from t as window slides
                if txt[i] in t:
                    if t[txt[i]] == 0:
                        del t[txt[i]]
                    else:
                        t[txt[i]] -= 1
                i += 1
    
        return cnt
                    
    def search2(self, p, s):
        len_s, len_p = len(s), len(p)
        
        if len_p > len_s:
            return 0
        
        p_counter = Counter(p)
        window_counter = Counter(s[:len_p])
        
        count = 0
        if window_counter == p_counter:
            count += 1
        
        for i in range(len_p, len_s):
            start_char = s[i - len_p]
            end_char = s[i]
            
            window_counter[end_char] += 1
            window_counter[start_char] -= 1
            
            if window_counter[start_char] == 0:
                del window_counter[start_char]
            
            if window_counter == p_counter:
                count += 1
                
        return count
        
    
    def search(self, p, s):
        
        # better method, Use the sliding window to count the anagrams
        
        k = len(p)
        
        m = {}
        
        for i in p:
            if m.get(i):
                m[i] += 1
            else:
                m[i] = 1
                
        i = 0
        ans = 0
        j = 0
        
        count = len(m) # len of the unique characters in the string
        
        
        while j < len(s):
            
            if s[j] in m:
                m[s[j]] -= 1
                if m[s[j]] == 0:
                    count -= 1
            
            if j - i + 1 < k:
                j += 1
            
            elif j - i + 1 == k:
                
                if count == 0:
                    ans += 1
                
                if s[i] in m:
                    if m[s[i]] == 0:
                        count += 1
                    m[s[i]] += 1
                    
                i += 1
                j += 1
                
        
        return ans


        def search4(self, p, s):
            k = len(p)
            m = {}
        
            # Count the frequency of each character in p
            for char in p:
                if char in m:
                    m[char] += 1
                else:
                    m[char] = 1
        
            i = 0
            ans = 0
            count = len(m)  # Number of unique characters in p
        
            # Sliding window over s
            for j in range(len(s)):
                # Decrease the count for the current character
                if s[j] in m:
                    m[s[j]] -= 1
                    if m[s[j]] == 0:
                        count -= 1
        
                # If the window size is smaller than k, continue expanding
                if j - i + 1 < k:
                    continue
        
                # When window size equals k
                if j - i + 1 == k:
                    # Check the substring
                    if count == 0:
                        ans += 1
                        print(s[i: j + 1])
        
                    # Before sliding the window, restore the count of the leftmost character
                    if s[i] in m:
                        if m[s[i]] == 0:
                            count += 1
                        m[s[i]] += 1
        
                    i += 1
        
            return ans

--


===============================================================================================================================

-- Longest Subsequence such that the diff between adjacents is one


-- https://www.geeksforgeeks.org/problems/longest-subsequence-such-that-difference-between-adjacents-is-one4724/1?page=5&company=Flipkart&sortBy=submissions

-- https://www.youtube.com/watch?v=h-6HD5o-MR0


--

from typing import List
from collections import defaultdict


class Solution:
    def longestSubseq(self, n : int, a : List[int]) -> int:
        # code here
        
        m = defaultdict(int)
        ans = 0
        
        for i in range(n):
            m[a[i]] = max(m.get(a[i] - 1, 0), m.get(a[i] + 1, 0) if i < n else 0) + 1
            ans = max(ans, m[a[i]])
            
        return ans
            
--


====================================================================================================================================


-- Count the node at distance k from leaf


-- https://www.geeksforgeeks.org/problems/node-at-distance/1?page=6&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=rxcvNUcN_JQ


--
class Solution:
    #Function to return count of nodes at a given distance from leaf nodes.
    def printKDistantfromLeaf(self, root, k):
        #code here
        
        s = set()
        
        def dfs(node, path, k):
            
            if not node:
                return
            
            path.append(node.data)
            
            if not node.left and not node.right:
                if len(path) - 1 >= k:
                    s.add(path[len(path) - 1 - k])
                
        
            dfs(node.left, path, k)
            dfs(node.right, path, k)
            
            path.pop()
                
            return
        
        dfs(root, [], k)
        
        return len(s)
--


==================================================================================================================


