
-- FInd the missing number


-- https://www.geeksforgeeks.org/problems/missing-number-in-array1416/1?page=1&company=Flipkart&sortBy=submissions
-- 

--
class Solution:
    def missingNumber(self,a,n):
        # code here
        
        total = n * (n + 1) // 2
        
        dif = total - sum(a)
        return dif
--


======================================================================================


-- jump game


-- https://leetcode.com/problems/jump-game/submissions/1240898979/
-- https://www.youtube.com/watch?v=EgMPjWliYGY

--
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        # We can do this in dp but also we can do this with greedy
        index = len(nums) - 1
        for i in range(len(nums) - 1, -1, -1):
            # plus index becoz u need to check with respect to index
            if nums[i] + i >= index:
                index = i

        if index == 0:
            return True
        return False
--


=======================================================================================

-- Min number of jumps to reach the end (Jump game 2)


-- https://www.geeksforgeeks.org/problems/minimum-number-of-jumps-1587115620/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/

--
#User function Template for python3
class Solution:
	def minJumps(self, arr, n):
	    #code here
	    
        # greedy approach
        
        farthest = 0
        cur = 0
        jumps = 0
        
        for i in range(n - 1):
            
            if arr[i] + i > farthest:
                farthest = arr[i] + i
            
            if i == cur:
                if farthest == cur:
                    return -1
                cur = farthest
                jumps += 1
            
        
            
        if len(arr) == 1:
            return 0
        
        if arr[0] == 0:
            return -1
        

        return jumps
--


==========================================================================================================

-- Find duplicates in array for O(N)

-- https://www.geeksforgeeks.org/problems/find-duplicates-in-an-array/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/


--
class Solution:
    def duplicates(self, arr, n): 
    	# code here
    	
    	result = []

        # Step 1: Iterate through the array to mark frequencies
        for i in range(len(arr)):
            # Calculate the index where the frequency needs to be stored
            index = arr[i] % len(arr)
            # Increment the value at the calculated index by n, marking the frequency
            arr[index] += len(arr)
        
        # Step 2: Traverse the modified array to find duplicate elements
        found = False
        for i in range(len(arr)):
            # Calculate the frequency of the current element
            if arr[i] // len(arr) > 1:
                # If frequency is greater than 1, add the index to the result list
                result.append(i)
                found = True
    
        # Step 3: If no duplicates found, add -1 to the result
        if not found:
            result.append(-1)
    
        return result
--

==================================================================================================================

-- Parenthesis Checker

-- https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/

--
class Solution:
    
    #Function to check if brackets are balanced or not.
    def ispar(self,x):
        # code here
        
        possible_combination = { '}': '{', ']': '[', ')': '('}
        
        stack = []
        
        for i in range(len(x)):
            if x[i] in ['(', '[', '{']:
                stack.append(x[i])
            else:
                if stack and stack[-1] == possible_combination.get(x[i], 0):
                    stack.pop()
                else:
                    return False
        
        if not stack:
            return True
        return False
--

===============================================================================================================================

-- Check for BST


-- https://www.geeksforgeeks.org/problems/check-for-bst/1?page=1&company=Flipkart&sortBy=submissions
-- https://geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

--
class Solution:
    
    #Function to check whether a Binary Tree is BST or not.
    def isBST(self, root):
        #code here
        
        def dfs(node, mx_v, mi_v):
            
            if not node:
                return True
                
            if mi_v > node.data:
                return False
            
            if mx_v < node.data:
                return False
                
            return dfs(node.left, node.data - 1, mi_v) and dfs(node.right, mx_v, node.data - 1)
    
            
        
        return dfs(root, float("inf"), float("-inf"))
--


=======================================================================================================================================


-- Left view of the binary tree


-- https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-- Check the level of the and then input

--
def LeftView(root):
    
    # code here
    
    res = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(res):
            res.append(node.data)
        
        if node.left:
            dfs(node.left, level + 1)
        if node.right:
            dfs(node.right, level + 1)
        
        
    dfs(root, 0)
    return res
--


==========================================================================================================================================

-- Trapping water


-- https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1?page=1&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=m18Hntz4go8


--
class Solution:
    def trappingWater(self, arr,n):
        #Code here
        
        # the logic is get the left most greater one which is greater than the current number
        # get the right most greater one which is greater than the current number
        
        # min(left[i], right[i]) - arr[i]
        
        # for this the better approach is to get the prefix array from left side and suffix array from right side
        
        # the optimal solution is using two pointer approach
        
        left = 0
        right = n - 1
        max_left = 0
        max_right = 0
        res = 0
        
        while left <= right:
            
            if arr[left] <= arr[right]:
                if arr[left] > max_left:
                    max_left = arr[left]
                    
                else:
                    res += max_left - arr[left]
                
                left += 1
                    
            else:
                if arr[right] > max_right:
                    max_right = arr[right]
                
                else:
                    res += max_right - arr[right]
                
                right += 1
        
        return res
--


======================================================================================================================

--  Count pairs of given sum


-- https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1?page=1&company=Flipkart&sortBy=submissions
--


--
from collections import defaultdict
class Solution:
    def getPairsCount(self, arr, n, sum):
        # code here

        unordered_map = {}
        count = 0
        for i in range(n):
            if sum - arr[i] in unordered_map:
                count += unordered_map[sum - arr[i]]
            if arr[i] in unordered_map:
                unordered_map[arr[i]] += 1
            else:
                unordered_map[arr[i]] = 1
        return count
--


===============================================================================================================================

-- boundary traversal of the binary tree


-- https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1?page=1&company=Flipkart&sortBy=submissions
--

-
from collections import defaultdict

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def printBoundaryView(self, root):
        # Code here
        
        # method 1
        
        # Using recursion
        
        # first print left tree view excluding leaf
        # second print all the leaves
        # third print the right from bottom up approach
        res = [root.data]
        
        def printleft(node):
            
            if node:
            
                if node.left:
                    # only add it into the res if the either of the child is present
                    
                    res.append(node.data)
                    
                    printleft(node.left)
                    
                elif node.right:
                    
                    res.append(node.data)
                    
                    printleft(node.right)
        
        def printRight(node):
            
            if node:
                
                if node.right:
                    printRight(node.right)
                    res.append(node.data)
                    
                elif node.left:
                    
                    printRight(node.left)
                    res.append(node.data)
                
                
        
        def printLeaves(node):
            
            if node:
            
                printLeaves(node.left)
                
                if not node.left and not node.right:
                    res.append(root.data)
                
                printLeaves(node.right)
        
        printleft(root.left)
        
        printLeaves(root.left)
        printLeaves(root.right)
        
        printRight(root.right)
        
        return res
-

=========================================================================================================


-- find the middle element in linked list


-- https://www.geeksforgeeks.org/problems/finding-middle-element-in-a-linked-list/1?page=1&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        
        slow = head
        fast = head
        
        while fast and fast.next:
            
            slow = slow.next
            fast = fast.next.next
            

        return slow.data
--


===========================================================================================================


-- Maximum of all subarray


-- https://www.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1?page=2&company=Flipkart&sortBy=submissions
--

--
from collections import deque

class Solution:
    
    #Function to find maximum of each subarray of size k.
    def max_of_subarrays(self,arr,n,k):
        
        #code here
        q = deque()
        j = 0

        res = []
        
        i = 0
        j = 0
        
        while j < n:
            
            # check the queue if it is in decreasing order else pop the elements
            # since we want the next greater after popping the max element
            
            
            while q and q[-1] < arr[j]:
                q.pop()
            
            q.append(arr[j])
            

            
            if j - i + 1 < k:
                j += 1
            
            elif j - i + 1 == k:
                res.append(q[0])
                
                # get the answer and slide the window which mean i and j will be moved
                
                if arr[i] == q[0]:
                    q.popleft()
                
                i += 1
                j += 1
            
        return res
            
--


============================================================================================================

-- Anagrams


-- https://www.geeksforgeeks.org/problems/anagram-1587115620/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    
    #Function is to check whether two strings are anagram of each other or not.
    def isAnagram(self,a,b):
        #code here
        
        if len(a) != len(b):
            return False
        
        A = [0] * 26
        B = [0] * 26
        
        
        for i in range(len(a)):
            A[ord(a[i]) - ord("a")] += 1
            B[ord(b[i]) - ord("a")] += 1
        
        if A == B:
            return True
        return False
        
--


======================================================================================================

-- Spirally traversing a matrix


-- https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=BJnMZNwUk1M


--
class Solution:
    
    #Function to return a list of integers denoting spiral traversal of matrix.
    def spirallyTraverse(self,matrix, r, c): 
        # code here 
        
        left = 0
        right = c - 1
        top = 0
        bottom = r - 1
        res = []
        
        while left <= right and top <= bottom:
            
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            
            top += 1
            
            for i in range(top, bottom + 1):
                res.append(matrix[i][right])
            
            right -= 1
            
            if top <= bottom:
                for i in range(right, left - 1, -1):
                    res.append(matrix[bottom][i])
                    
                bottom -= 1
            
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    res.append(matrix[i][left])
                
                left += 1
        
        return res
--


===================================================================================================================

-- Determine if two trees are identical


-- https://www.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to check if two trees are identical.
    def isIdentical(self,root1, root2):
        # Code here
        
        def dfs(node1, node2):
            if not node1 and not node2:
                return True
            
            if node1 and node2:
                if node1.data == node2.data and dfs(node1.left, node2.left) and dfs(node1.right, node2.right):
                    return True
            
            return False
        
        return 1 if dfs(root1, root2) else 0 
--

==============================================================================================================

-- Key pair


-- https://www.geeksforgeeks.org/problems/key-pair5616/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
	def hasArrayTwoCandidates1(self,arr, n, x):
		# code here
		m = {}
		
		for i in range(n):
		    m[arr[i]] = 1
		   
        
        for i in range(n):
            if abs(x - arr[i]) in m:
                return True
        
        return False
    
    def hasArrayTwoCandidates(self, arr, n, x):
        hashmap = {}

        for i in range(n):
            temp = x-arr[i]
            if (temp in hashmap):
                return 1
            hashmap[arr[i]] = i
        return 0
--



==============================================================================================================

-- Wave array 


-- https://www.geeksforgeeks.org/problems/wave-array-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.geeksforgeeks.org/sort-array-wave-form-2/


--
from typing import List


class Solution:
    def convertToWave(self, n : int, arr : List[int]) -> None:
        # code here
        
        # Traverse all even elements
        for i in range(0, n - 1, 2):
     
            # If current even element is smaller than previous
            if (i > 0 and arr[i] < arr[i-1]):
                arr[i], arr[i-1] = arr[i-1], arr[i]
     
            # If current even element is smaller than next
            if (i < n-1 and arr[i] < arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                
        return arr
--


======================================================================================================


-- Add two numbers represented by linked lists


-- https://www.geeksforgeeks.org/problems/add-two-numbers-represented-by-linked-lists/1?page=2&company=Flipkart&sortBy=submissions
--


--
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, num1, num2):
        # code here
        # return head of sum list
        
        carry = 0
        dummy = Node(0)
        temp = dummy
        
        z = True
        
        def reverse(node):
            if not node:
                return node
            
            cur = node
            prev = None
            nxt = node
            
            while cur:
                
                nxt = cur.next
                cur.next = prev
                prev = cur
                cur = nxt
            
            return prev
            
        num1 = reverse(num1)
        num2 = reverse(num2)        
        
        
        while num1 or num2 or carry:
            v1 = num1.data if num1 else 0
            v2 = num2.data if num2 else 0
            
            # calculate sum and carry
            csum = carry + v1 + v2
            carry = csum // 10
            
            if csum % 10 != 0 and z:
                z = False
            
            # create new node with the sum mod 10
            temp.next = Node(csum % 10)
            temp = temp.next
            
            # move to next nodes
            if num1:
                num1 = num1.next
            if num2:
                num2 = num2.next
        
        reversedHead = reverse(dummy.next)
        
    
        if z:
            return Node(0)
        
        while reversedHead and reversedHead.data == 0:
            reversedHead = reversedHead.next
        return reversedHead
        

        return reversedHead
--


===================================================================================================================

-- The celebrity problem


-- https://www.geeksforgeeks.org/problems/the-celebrity-problem/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=CiiXBvrX-5A&t=352s


--
class Solution:
    
    #Function to find if there is a celebrity in the party or not.
    def celebrity(self, M, n):
        # code here 
        
        # you can use stacks for it
        
        # put all the 0 to n - 1 in stack
        # check for the first two elements in the stack of the attachments
        
        # if there is a edge between i and j that means i is kinda celebrity and not fully so do the same for all
        
        s = []
        
        for i in range(n):
            s.append(i)
        
        while len(s) >= 2: 
            v1 = s.pop()
            v2 = s.pop()
            
            if M[v1][v2]:
                s.append(v2)
            
            else:
                s.append(v1)
                
                
        # and after getting the last element check for the whole row if the particluar number n-knows anyone or not

        pos = s.pop()
        for i in range(n):
            if i == pos:
                if M[pos][i] == 1 or M[i][pos] == 0:
                    return -1
        return pos
            
--


================================================================================================================

-- N meetings in one room


-- https://www.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1?page=2&company=Flipkart&sortBy=submissions
-- 

Get the number of meetinfs can fit in one room

--
class Solution:
    
    #Function to find the maximum number of meetings that can
    #be performed in a meeting room.
    def maximumMeetings(self,n,start,end):
        # code here
        
        meetings = []
        
        for i in range(n):
            meetings.append((start[i], end[i]))
        
        meetings.sort(key= lambda x:x[1])
        
        prev = meetings[0][1]
        cnt = 1
        for i in range(1, n):
            if meetings[i][0] > prev:
                cnt += 1
                prev = meetings[i][1]
        
        return cnt
--


====================================================================================================================

-- Get minimum element from stack


-- https://www.geeksforgeeks.org/problems/get-minimum-element-from-stack/1?page=2&company=Flipkart&sortBy=submissions
--


--
class stack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        if not self.stack:
            return -1
        popped = self.stack.pop()
        if popped == self.min_stack[-1]:
            self.min_stack.pop()
        return popped

    def getMin(self):
        if not self.min_stack:
            return -1
        return self.min_stack[-1]
--


===========================================================================================================================


-- Stickler theif ( House Robber )

-- https://www.geeksforgeeks.org/problems/stickler-theif-1587115621/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=Rp7I15rKNxs

--
class Solution:  
    
    #Function to find the maximum money the thief can get.
    def FindMaxSum1(self,arr, n):
        
        # code here
        
        dp = [-1 for i in range(n + 1)]
        
        if len(arr) == 1:
            return arr[0]
        
        if len(arr) == 2:
            return max(arr[0], arr[1])
        
        
        def dfs(index):
            
            if index >= n:
                return 0
                
            if dp[index] != -1:
                return dp[index]
                
            withd = dfs(index + 2) + arr[index]
            without = dfs(index + 1)
            
            dp[index] = max(withd, without)
            
            return dp[index]
        
        return dfs(0)
        
        
    
    def FindMaxSum(self,arr, n):
        
        dp = [0 for i in range(n + 1)]
        
        dp[0] = arr[0]
        dp[1] = max(arr[0], arr[1])

        
        for i in range(2, n):
            
            dp[i] = max(arr[i] + dp[i - 2], dp[i - 1])
        
        
        return dp[n - 1]
--


==========================================================================================================


-- Top view of the binary tree


-- https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1
-- https://www.youtube.com/watch?v=JMBFm__krXw

--
from collections import defaultdict, deque

# Tree Node
# class Node:
#     def __init__(self, val):
#         self.right = None
#         self.data = val
#         self.left = None

class Solution:
    
    #Function to return a list of nodes visible from the top view 
    #from left to right in Binary Tree.
    def topView(self,root):
        
        # code here
        
        # go in the level order and get the horizontal distance of the tree node from the root
        
        # if going towards left then -1 else +1
        
        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            if not m[hd]:
                res.append((hd, node.data))
                m[hd] = 1
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.right, hd + 1))
        
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


============================================================================================================

-- Bottom view of the binary tree


-- https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=JMBFm__krXw


--
class Solution:
    def bottomView(self, root):
        # code here

        if not root:
            return root
        
        m = defaultdict(int)
        q = deque()
        q.append((root, 0))
        res = []
        
        while q:
            
            node, hd = q.popleft()
            
            m[hd] = (hd, node.data)
            
            if node.left:
                q.append((node.left, hd - 1))
            
            if node.right:
                q.append((node.right, hd + 1))
        
        for i in m:
            res.append(m[i])
            
        res.sort(key=lambda x: x[0])
        
        # Extract node values
        return [node[1] for node in res]
        
        return res
--


=======================================================================================================================


-- Median of 2 sorted arrays


-- https://www.geeksforgeeks.org/problems/median-of-2-sorted-arrays-of-different-sizes/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=bottom_sticky_on_article
-- 


--class Solution:
    def MedianOfArrays(self, a, b):
        
        # get the l1 l2 and r1 r2 from the ends of the partition of the array
        
        # get the hight end from the lower length array
        
        n1 = len(a)
        n2 = len(b)
        
        if n1 > n2: return self.MedianOfArrays(b, a)
        
        low = 0
        high = n1
        n = n1 + n2
        
        totalLength = (n1 + n2 + 1) // 2
        
        while low <= high:
            
            mid1 = (high + low) >> 1
            mid2 = totalLength - mid1
            
            l1 = float("-inf")
            l2 = float("-inf")
            r1 = float("inf")
            r2 = float("inf")
            
            if mid1 < n1: r1 = a[mid1]
            
            if mid2 < n2: r2 = b[mid2]
            
            if mid1 - 1 >= 0: l1 = a[mid1 - 1]
            if mid2 - 1 >= 0: l2 = b[mid2 - 1]
            
            if l1 <= r2 and l2 <= r1:
                if n % 2 == 0: return ((max(l1, l2) + min(r1, r2)) / 2)
                else:
                    return max(l1, l2)
            elif l1 > r2:
                high = mid1 -1
            
            else:
                low = mid1 + 1
                
        
        return 0
--

====================================================================================================================

-- Level order traversal in spiral form (zig zag traversal)


-- https://www.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/1?page=2&company=Flipkart&sortBy=submissions
--


--
from collections import deque
'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''        

def findSpiral(root):
    # Code here
    
    res = []
    q = deque([root])
    
    leftToRight = tRUE
    
    while q:
        
        size = len(q)
        row = [0 for _ in range(size)]
        
        for i in range(size):
            
            node = q.popleft()
            
            index = i if leftToRight else size - i - 1 
            
            row[index] = node.data
            
            if node.left:
                q.append(node.left)
            
            if node.right:
                q.append(node.right)
                
        
        for i in row:
            res.append(i)
            
        lefToRight = not leftToRight
                    
        
    return res
--

==========================================================================================================

-- Multiply two numbers


-- https://www.geeksforgeeks.org/problems/multiply-two-strings/1?page=2&company=Flipkart&sortBy=submissions
-- https://www.youtube.com/watch?v=1vZswirL8Y8


--
class Solution:
    def multiplyStrings(self,s1,s2):
        # code here
        # return the product string
        
        if "0" in s1 or "0" in s2:
            return '0'
            
        i1 = len(s1)
        i2 = len(s2)
        
        # if "0" == s1[0]:
        #     t = True
            
        #     for i in range(s1):
                
                
                
                
            
        # if s1[0] == '-':
        #     flag = 1 - flag
        
        i1 = len(s1)
        i2 = len(s2)
            
        res = [0 for _ in range(i1 + i2)]
        
        s1 = s1[::-1]
        s2 = s2[::-1]
        
        for i in range(len(s1)):
            for j in range(len(s2)):
                
                digit = int(s1[i]) * int(s2[j])
                
                res[i + j] += digit
                
                res[i + j + 1] += res[i + j] // 10 
                res[i + j] = res[i + j] % 10
        
        res = res[::-1]
        beg = 0
        
        while beg < len(res) and res[beg] == 0:
            beg += 1
            
        res = map(str, res[beg:])
        
        return "".join(res)
--


=======================================================================================================

-- 


