-- Min cost of ropes
-- https://www.youtube.com/watch?v=cL_IRO8Yzeo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=4
-- https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1

--
import heapq
class Solution:
    #Function to return the minimum cost of connecting the ropes.
    def minCost(self,arr,n) :
    
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            firstMinimumRope = heapq.heappop(arr)
            secondMinimumRope = heapq.heappop(arr)
            
            res += firstMinimumRope + secondMinimumRope
            heapq.heappush(arr, firstMinimumRope + secondMinimumRope)
            
        return res
--

################################################################################################################

-- Queries of matrix
-- https://www.youtube.com/watch?v=G2OBYDINXLU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=5
-- https://practice.geeksforgeeks.org/problems/queries-on-a-matrix0443/1

--
	def solveQueries(self, n, Queries):
	    matrix = [[0 for _ in range(n)] for _ in range(n)]
	    
	    for i in range(len(Queries)):
	        a = Queries[i][0]   # start row
	        b = Queries[i][1]   # start column
	        c = Queries[i][2]   # end row 
	        d = Queries[i][3]   # end column
	        
	        for j in range(a, c+1):
	            matrix[j][b] += 1
	            if d+1 < n:
	                matrix[j][d+1] -= 1
	    
	    for i in range(n):
	        for j in range(1, n):
	            matrix[i][j] += matrix[i][j-1]
	    return matrix

--

###############################################################################################################################

-- The bit game

-- https://practice.geeksforgeeks.org/problems/the-bit-game2313/1
-- https://www.youtube.com/watch?v=TB17AxGvAIA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=6

--
class Solution:
    def swapBitGame (self,N):
        # code here 
        # count the number of set bits first => and if the number is odd then player 1 won else player 2 won
        count = 0
        while N > 0:
            count += (N&1)
            N = N>>1
        if count % 2 == 0:
            return 2
        return 1
--

###########################################################################################################################################

-- Geek and number

-- https://practice.geeksforgeeks.org/problems/904237fa926d79126d42c437802b04287ea9d1c8/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

-- 
class Solution:
    def minLength(self, s, n):
        
        def expected(num):
            if num == '0':
                return '9'
            if num == '9':
                return '0'
            if int(num) % 2 == 0:
                return str(int(num) - 1)
            return str(int(num) + 1)
        stack = []
        for i in range(n):
            if len(stack) == 0:
                stack.append(s[i])
            elif stack[-1] == expected(s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return len(stack)
--

############################################################################################################################################

-- Tom and jerry 

-- https://practice.geeksforgeeks.org/problems/tom-and-jerry1325/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

--
class Solution:
    def numsGame(self, N):
        # code here
        # we cannot subtract the number with itself
        # for n = 1 => tom loses
        # for n = 2 => tom wins
        # for n = 3 => tom loses
        # for n = 4 => tom wins
        # 
        if N % 2 == 0:
            return 1
        else:
            return 0
--

########################################################################################################################################################

-- ipl 2021 same as => (Longest valid parenthesis) => stack problem

-- https://practice.geeksforgeeks.org/problems/3b47f0ad00f953dd514235ddec54e39fdc297dda/1
-- https://www.youtube.com/watch?v=G53_EUjUYcQ


--
class Solution:
    def findMaxLen(ob, S):
        stack = [-1]
        maximum = 0
        
        for i in range(len(S)):
            if S[i] == '(':
                stack.append(i)
            else:
                if len(stack) > 0:
                    stack.pop()
                    
                if len(stack) > 0:
                    maximum = max(maximum, abs(stack[-1]-i))
                else:
                    stack.append(i)
        return maximum  
--

########################################################################################################################################################


-- Smallest subset with greater sum

-- https://www.youtube.com/watch?v=x3xCSsCsc_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13
-- https://practice.geeksforgeeks.org/problems/smallest-subset-with-greater-sum/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
class Solution:
    def minSubset(self, A, N):
        maximumSum = 0
        for i in range(N):
            maximumSum += A[i]
        A.sort()
        res = 0
        for i in range(N):
            res += A[i] 
            maximumSum -= A[i] 
            if res>maximumSum:
                return i+1
        return N
--

########################################################################################################################################################


-- Maximum number of 2x2 sqaures

-- https://www.youtube.com/watch?v=7WrjdY08BSM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=12
-- https://practice.geeksforgeeks.org/problems/maximum-number-of-22-squares/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--

--


##################################################################################################################################################################

-- Smallest number on the left (nearest smaller to left) => using stack

--  https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1
-- youtube.com/watch?v=YRnI-HDQBSU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13

--
class Solution:
    def leftSmaller(self, n, a):
        stack = []
        ans = []
        for i in range(n):
            while stack and stack[-1] >= a[i]:
                stack.pop()
            if not stack:
                ans.append(-1)
            else:
                ans.append(stack[-1])
            stack.append(a[i])
        return ans
--

#################################################################################################################################################################


-- Composite and prime 

-- https://www.youtube.com/watch?v=vMu0chFRG7o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=14
-- https://practice.geeksforgeeks.org/problems/composite-and-prime0359/1

--
import math
class Solution:
	def Count(self, L, R):
		p = [True for _ in range(R+1)]
		p[0] = False
		p[1] = False
		for i in range(2, int(math.sqrt(R)) + 1):
		    if p[i] == False: continue
		    for j in range(i*i, R+1, i):
		        p[j] = False
		    
		prime = 0
		composite = 0
		for i in range(L, R+1):
		    if i == 1: continue
		    if p[i] == True: prime += 1
		    else:
		        composite+= 1
	    return composite - prime
--

##################################################################################################################################################################

-- Number of ways to arrive at destination

-- https://www.youtube.com/watch?v=EQ4sX6mxDsk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=15
-- https://practice.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1
-- https://www.youtube.com/watch?v=_-0mx0SmYxA


-- Incomplete solution
from collections import deque, defaultdict
from typing import List
from collections import defaultdict
import sys
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Dijkstra algo
        mod = 1e9+7
        ans = 0
        nw = 0
        graph = defaultdict(list)
        dis = [float('inf') for _ in range(n)]
        for s, d, w in roads:
            graph[s].append((d, w))
            graph[d].append((s, w))
        
        s = set([0])
        dis[0] = 0
        res = []
        while s:
            cur = s.pop()
            for node, weight in graph[cur]:
                nw = dis[cur] + weight
                if dis[cur] + weight < dis[node]:
                    dis[node] = dis[cur] + weight
                    if node == n - 1:
                        if dis[node] == nw:
                            ans = (ans + 1)%mod
                    s.add(node)
        return ans
--

#############################################################################################################################################################################

-- Minimum swaps (sheeps problem)

-- youtube.com/watch?v=6uSxQKVSP3o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=16
-- https://practice.geeksforgeeks.org/problems/minimum-swaps-1649134975/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- 
from typing import List
class Solution:
    def minimumSwaps(self,c : List[int], v : List[int],n : int,k : int,b : int, t : int) -> int:
        ans = 0
        ts = 0
        r = 0
        
        for i in range(n - 1, -1, -1):
            if r >= k:
                break
            d = v[i] * t
            if d >= (b - c[i]):
                ans += ts
                r += 1
            else:
                ts += 1
            
        if r >= k:
            return ans
        return -1
--

###################################################################################################################################################################################

-- Minimum swaps to sort 


-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://practice.geeksforgeeks.org/problems/minimum-swaps/1
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/


--
class Solution:
    
    #Function to find the minimum number of swaps required to sort the array.
	def minSwaps(self, nums):
		n = len(nums)
		for i in range(n):
		    nums[i] = [nums[i], i]
		nums.sort(key = lambda x: x[0])
		i = 0
		swap = 0
		while i < n:
		    element, index = nums[i] 
		    if index != i:
		        swap += 1
		        nums[i], nums[index] = nums[index], nums[i]
		    else:
		        i += 1
        return swap
--


###################################################################################################################################################################################

-- Convert Bst to min heap

-- https://www.youtube.com/watch?v=Y9Pu7nHpeFc
-- 

steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Preorder traversal on bst array and change the values of the trees

--

--
############################################################################################################################################################################


-- Convert Bst to max heap

-- https://www.youtube.com/watch?v=zWYmcwFWp1M&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=18
-- https://www.geeksforgeeks.org/convert-bst-to-max-heap/
-- https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1


steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Postorder traversal on bst array and change the values of the tree

--
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        
'''

class Solution:
    def convertToMaxHeapUtil(self, root):
        arr = []
        def inorder(node):
            if not node:
                return None
            inorder(node.left)
            arr.append(node.data)
            inorder(node.right)
        
        def postOrder(node):
            if not node:
                return None
                
            postOrder(node.left)
            postOrder(node.right)
            node.data = arr.pop()
        
        inorder(root)
        arr.reverse()
        postOrder(root)
        return root
--


########################################################################################################################################################################

-- Minimum exchange

-- https://www.youtube.com/watch?v=nXpmRnaZqdE&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=19
-- https://practice.geeksforgeeks.org/problems/distributing-question-papers2513/1


--

--


#####################################################################################################################################################################