-- Min cost of ropes
-- https://www.youtube.com/watch?v=cL_IRO8Yzeo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=4
-- https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1

--
import heapq
class Solution:
    #Function to return the minimum cost of connecting the ropes.
    def minCost(self,arr,n) :
    
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            firstMinimumRope = heapq.heappop(arr)
            secondMinimumRope = heapq.heappop(arr)
            
            res += firstMinimumRope + secondMinimumRope
            heapq.heappush(arr, firstMinimumRope + secondMinimumRope)
            
        return res
--

################################################################################################################

-- Queries of matrix
-- https://www.youtube.com/watch?v=G2OBYDINXLU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=5
-- https://practice.geeksforgeeks.org/problems/queries-on-a-matrix0443/1

--
	def solveQueries(self, n, Queries):
	    matrix = [[0 for _ in range(n)] for _ in range(n)]
	    
	    for i in range(len(Queries)):
	        a = Queries[i][0]   # start row
	        b = Queries[i][1]   # start column
	        c = Queries[i][2]   # end row 
	        d = Queries[i][3]   # end column
	        
	        for j in range(a, c+1):
	            matrix[j][b] += 1
	            if d+1 < n:
	                matrix[j][d+1] -= 1
	    
	    for i in range(n):
	        for j in range(1, n):
	            matrix[i][j] += matrix[i][j-1]
	    return matrix

--

###############################################################################################################################

-- The bit game

-- https://practice.geeksforgeeks.org/problems/the-bit-game2313/1
-- https://www.youtube.com/watch?v=TB17AxGvAIA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=6

--
class Solution:
    def swapBitGame (self,N):
        # code here 
        # count the number of set bits first => and if the number is odd then player 1 won else player 2 won
        count = 0
        while N > 0:
            count += (N&1)
            N = N>>1
        if count % 2 == 0:
            return 2
        return 1
--

###########################################################################################################################################

-- Geek and number

-- https://practice.geeksforgeeks.org/problems/904237fa926d79126d42c437802b04287ea9d1c8/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

-- 
class Solution:
    def minLength(self, s, n):
        
        def expected(num):
            if num == '0':
                return '9'
            if num == '9':
                return '0'
            if int(num) % 2 == 0:
                return str(int(num) - 1)
            return str(int(num) + 1)
        stack = []
        for i in range(n):
            if len(stack) == 0:
                stack.append(s[i])
            elif stack[-1] == expected(s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return len(stack)
--

############################################################################################################################################

-- Tom and jerry 

-- https://practice.geeksforgeeks.org/problems/tom-and-jerry1325/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

--
class Solution:
    def numsGame(self, N):
        # code here
        # we cannot subtract the number with itself
        # for n = 1 => tom loses
        # for n = 2 => tom wins
        # for n = 3 => tom loses
        # for n = 4 => tom wins
        # 
        if N % 2 == 0:
            return 1
        else:
            return 0
--

########################################################################################################################################################

-- ipl 2021 same as => (Longest valid parenthesis) => stack problem

-- https://practice.geeksforgeeks.org/problems/3b47f0ad00f953dd514235ddec54e39fdc297dda/1
-- https://www.youtube.com/watch?v=G53_EUjUYcQ


--
class Solution:
    def findMaxLen(ob, S):
        stack = [-1]
        maximum = 0
        
        for i in range(len(S)):
            if S[i] == '(':
                stack.append(i)
            else:
                if len(stack) > 0:
                    stack.pop()
                    
                if len(stack) > 0:
                    maximum = max(maximum, abs(stack[-1]-i))
                else:
                    stack.append(i)
        return maximum  
--

########################################################################################################################################################


-- Smallest subset with greater sum

-- https://www.youtube.com/watch?v=x3xCSsCsc_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13
-- https://practice.geeksforgeeks.org/problems/smallest-subset-with-greater-sum/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
class Solution:
    def minSubset(self, A, N):
        maximumSum = 0
        for i in range(N):
            maximumSum += A[i]
        A.sort()
        res = 0
        for i in range(N):
            res += A[i] 
            maximumSum -= A[i] 
            if res>maximumSum:
                return i+1
        return N
--

########################################################################################################################################################


-- Maximum number of 2x2 sqaures

-- https://www.youtube.com/watch?v=7WrjdY08BSM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=12
-- https://practice.geeksforgeeks.org/problems/maximum-number-of-22-squares/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--

--


##################################################################################################################################################################

-- Smallest number on the left (nearest smaller to left) => using stack

--  https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1
-- youtube.com/watch?v=YRnI-HDQBSU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13

--
class Solution:
    def leftSmaller(self, n, a):
        stack = []
        ans = []
        for i in range(n):
            while stack and stack[-1] >= a[i]:
                stack.pop()
            if not stack:
                ans.append(-1)
            else:
                ans.append(stack[-1])
            stack.append(a[i])
        return ans
--

#################################################################################################################################################################


-- Composite and prime 

-- https://www.youtube.com/watch?v=vMu0chFRG7o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=14
-- https://practice.geeksforgeeks.org/problems/composite-and-prime0359/1

--
import math
class Solution:
	def Count(self, L, R):
		p = [True for _ in range(R+1)]
		p[0] = False
		p[1] = False
		for i in range(2, int(math.sqrt(R)) + 1):
		    if p[i] == False: continue
		    for j in range(i*i, R+1, i):
		        p[j] = False
		    
		prime = 0
		composite = 0
		for i in range(L, R+1):
		    if i == 1: continue
		    if p[i] == True: prime += 1
		    else:
		        composite+= 1
	    return composite - prime
--

##################################################################################################################################################################

-- Number of ways to arrive at destination

-- https://www.youtube.com/watch?v=EQ4sX6mxDsk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=15
-- https://practice.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1
-- https://www.youtube.com/watch?v=_-0mx0SmYxA


-- Incomplete solution
from collections import deque, defaultdict
from typing import List
from collections import defaultdict
import sys
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Dijkstra algo
        mod = 1e9+7
        ans = 0
        nw = 0
        graph = defaultdict(list)
        dis = [float('inf') for _ in range(n)]
        for s, d, w in roads:
            graph[s].append((d, w))
            graph[d].append((s, w))
        
        s = set([0])
        dis[0] = 0
        res = []
        while s:
            cur = s.pop()
            for node, weight in graph[cur]:
                nw = dis[cur] + weight
                if dis[cur] + weight < dis[node]:
                    dis[node] = dis[cur] + weight
                    if node == n - 1:
                        if dis[node] == nw:
                            ans = (ans + 1)%mod
                    s.add(node)
        return ans
--

#############################################################################################################################################################################

-- Minimum swaps (sheeps problem)

-- youtube.com/watch?v=6uSxQKVSP3o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=16
-- https://practice.geeksforgeeks.org/problems/minimum-swaps-1649134975/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- 
from typing import List
class Solution:
    def minimumSwaps(self,c : List[int], v : List[int],n : int,k : int,b : int, t : int) -> int:
        ans = 0
        ts = 0
        r = 0
        
        for i in range(n - 1, -1, -1):
            if r >= k:
                break
            d = v[i] * t
            if d >= (b - c[i]):
                ans += ts
                r += 1
            else:
                ts += 1
            
        if r >= k:
            return ans
        return -1
--

###################################################################################################################################################################################

-- Minimum swaps to sort 


-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://practice.geeksforgeeks.org/problems/minimum-swaps/1
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/


--
class Solution:
    
    #Function to find the minimum number of swaps required to sort the array.
	def minSwaps(self, nums):
		n = len(nums)
		for i in range(n):
		    nums[i] = [nums[i], i]
		nums.sort(key = lambda x: x[0])
		i = 0
		swap = 0
		while i < n:
		    element, index = nums[i] 
		    if index != i:
		        swap += 1
		        nums[i], nums[index] = nums[index], nums[i]
		    else:
		        i += 1
        return swap
--


###################################################################################################################################################################################

-- Convert Bst to min heap

-- https://www.youtube.com/watch?v=Y9Pu7nHpeFc
-- 

steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Preorder traversal on bst array and change the values of the trees

--

--
############################################################################################################################################################################


-- Convert Bst to max heap

-- https://www.youtube.com/watch?v=zWYmcwFWp1M&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=18
-- https://www.geeksforgeeks.org/convert-bst-to-max-heap/
-- https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1


steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Postorder traversal on bst array and change the values of the tree

--
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        
'''

class Solution:
    def convertToMaxHeapUtil(self, root):
        arr = []
        def inorder(node):
            if not node:
                return None
            inorder(node.left)
            arr.append(node.data)
            inorder(node.right)
        
        def postOrder(node):
            if not node:
                return None
                
            postOrder(node.left)
            postOrder(node.right)
            node.data = arr.pop()
        
        inorder(root)
        arr.reverse()
        postOrder(root)
        return root
--


########################################################################################################################################################################

-- Minimum exchange

-- https://www.youtube.com/watch?v=nXpmRnaZqdE&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=19
-- https://practice.geeksforgeeks.org/problems/distributing-question-papers2513/1


--
class Solution:
	def MinimumExchange(self, matrix): 
	    n = len(matrix)
	    m = len(matrix[0])
	    c1 = 0
	    c2 = 0
	    for i in range(n):
	        for j in range(m):
	            element = matrix[i][j]
	            if (i + j) % 2 == 0:
	                if element == 'B':
	                    c1 += 1
	                if element == 'A':
	                    c2 += 1
	            else:
	                if element == 'B':
	                    c2 += 1
	                if element == 'A':
	                    c1 += 1
        return min(c1, c2)
--


#####################################################################################################################################################################

-- Ball coloring 

-- https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
-- https://practice.geeksforgeeks.org/problems/ball-coloring3450/1

--
class Solution:
    def noOfWays (self, n):
        # for n balls 2 + n(n - 1) ways
        # https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
        # for 0 touching => 2 ways
        # for 1 touching => ((n - 1) x 2) ways
        # for 2 tocuhing => (n - 1)(n - 2) ways
        # so total will be 2 + (n - 1) x 2 + (n - 1)(n - 2)
        
        return 2 + n * (n - 1)
-- 


#####################################################################################################################################################################

-- Count occurrences of a given word in a 2-d array

-- https://practice.geeksforgeeks.org/problems/count-occurences-of-a-given-word-in-a-2-d-array/1
-- https://www.youtube.com/watch?v=eCMiY-BUnOo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=21


--
class Solution:
    def findOccurrence(self,mat,target):
        n = len(mat)
        m = len(mat[0])
        queue = []
        def findword(mat, target, i, j, currentindex):
            if i < 0 or j < 0 or i >= n or j >= m:
                return 0
            curchar = mat[i][j]
            if target[currentindex] != curchar:
                return 0
            
            if currentindex == len(target) - 1:
                return 1
            
            mat[i][j] = '\0' # so that it wont repeat or consider the same character again
            
            count = 0
            count += findword(mat, target, i - 1, j, currentindex + 1)
            count += findword(mat, target, i + 1, j, currentindex + 1)
            count += findword(mat, target, i, j - 1, currentindex + 1)
            count += findword(mat, target, i, j + 1, currentindex + 1)
            
            mat[i][j] = curchar
            
            return count
            
        
        for i in range(n):
            for j in range(m):
                if mat[i][j] == target[0]:
                    queue.append((i, j))
                    
        
        cnt = 0            
        for i in range(n):
            for j in range(m):
                cnt += findword(mat, target, i, j, 0)
        return cnt
--

###########################################################################################################################################################################

-- Smallest number with sum of digits as N and divisible by 10 power 'N'

-- https://www.youtube.com/watch?v=B6AAvp_ba5I&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=22
-- https://practice.geeksforgeeks.org/problems/smallest-number-with-sum-of-digits-as-n-and-divisible-by-10n4032/1

--
class Solution:
	def digitsNum(self, N):
		s = ""
		if N % 9 != 0:
		    s = s + str(N % 9)
		
		for i in range(1, (N//9) + 1):
		    s += "9"
		
		for i in range(1, N + 1):
		    s+= "0"
	    return s
--

##############################################################################################################################################################################


-- Sum of k smallest elements in BST

-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/
-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=23


--

--


############################################################################################################################################################################

-- Kth smallest element in bst

-- https://practice.geeksforgeeks.org/problems/find-k-th-smallest-element-in-bst/1
-- https://leetcode.com/problems/kth-smallest-element-in-a-bst/

--
class Solution:
    # Return the Kth smallest element in the given BST 
    def KthSmallestElement(self, root, k): 
        #code here.
        count = 0
        ans = -1

        def sol(node, k):
            nonlocal count, ans
            if node is None:
                return
            sol(node.left, k)
            count += 1

            if count == k:
                ans = node.data
            sol(node.right, k)

        sol(root, k)
        return ans 
--

###############################################################################################################################################################################

-- Sum of k smallest elements in bst => O(k) complexity

-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/sum-of-k-smallest-elements-in-bst3029/1
-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/

--
# Node Class:
class Node:
    def __init__(self,val):
        self.key = val
        self.left = None
        self.right = None
'''

def summ(root, k):
    # code here
    count = 0
    ans = 0
    def sol(node, k):
        nonlocal count, ans
        if node is None:
            return 
        
        sol(node.left, k)
        
        count += 1
        if count <= k:
            ans += node.key
            
        else: return 
        
        sol(node.right, k)
        
    sol(root, k)
    return ans
--

##############################################################################################################################################################################


-- Stack permutations

-- https://www.youtube.com/watch?v=q4CbTMLogyk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=24
-- https://practice.geeksforgeeks.org/problems/stack-permutations/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
from typing import List
class Solution:
    def isStackPermutation(self, N : int, A : List[int], B : List[int]) -> int:
        # code here
        stack = []
        j = 0
        for i in range(N):
            stack.append(A[i])
            
            while len(stack) > 0 and stack[-1] == B[j]:
                stack.pop()
                j += 1
            
        if j == N and not stack:
            return 1
        return 0
-- 

###########################################################################################################################################################################

-- Minimum sum of absolute differences of pairs

-- https://www.youtube.com/watch?v=RZYkEj0iX3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/minimum-sum-of-absolute-differences-of-pairs/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def findMinSum(self, A,B,N):
        A.sort()
        B.sort()
        sum = 0
        for i in range(N):
            sum += abs(A[i] - B[i])
        return sum
--

####################################################################################################################################################################################################

-- Smallest sum contiguous subarray

-- https://www.youtube.com/watch?v=XTRFIfu2OUw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=26
-- https://practice.geeksforgeeks.org/problems/smallest-sum-contiguous-subarray/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def smallestSumSubarray(self, A, N):
        #Your code here
        minimum = float("inf")
        su = 0
        for i in range(N):
            su += A[i]
            if minimum > su:
                minimum = su
            if su > 0:
                su = 0
        
        return minimum
--

###################################################################################################################################################################################################################

-- Print the pattern 


-- https://www.geeksforgeeks.org/program-print-pattern-gfg/
-- https://www.youtube.com/watch?v=JttvX2HH7M0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=27

--

--


#########################################################################################################################################################################################################

-- Minimum cost to cut a board into squares

-- https://www.youtube.com/watch?v=j9Pxyfp8knU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=28
-- 

##########################################################################################################################################################################################################

-- Minimum time to fulfill all orders (Binary search hard question)
#### Important


-- https://practice.geeksforgeeks.org/problems/minimum-time-to-fulfil-all-orders/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=tfch4QSfRZc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=29


--

--


#####################################################################################################################################################################################################################################

-- Find the pairs with given sum in doubly linked list

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-pairs-with-given-sum-in-doubly-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def findPairsWithGivenSum(self, target : int, head : Optional['Node']) -> List[List[int]]:
        # two pointer method
        # code here
        
        l = head
        r = head
        ans = []
        while r.next != None:
            r = r.next
        #left is at start and right is at the end
        
        # condition also works for both even and odd elements
        while (l != r) and (r.next != l):
            csum = l.data + r.data
            if csum == target:
                ans.append((l.data, r.data))
                l = l.next
                r = r.next
            elif csum < target:
                l = l.next
            else:
                r = r.prev
        return ans
--

####################################################################################################################################################################################################################################

-- Find all distinct subset or subsequence

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-all-distinct-subset-or-subsequence-sums4424/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
	def DistinctSum(self, nums):
	    dp = [[0 for _ in range(10001)] for _ in range(len(nums))]
		# Code here
		s = set()
		def sol(i, arr, s, sum):
		    if i == len(arr):
		        s.add(sum)
		        return 
		    
		    if dp[i][sum]:
		        return
		    
		    sol(i + 1, arr, s, sum)
		    sol(i+ 1, arr, s, sum + arr[i])
		    dp[i][sum] = 1
		    
		sol(0, nums, s, 0)
		return sorted(s)
--

######################################################################################################################################################################################################


-- Merging Details


-- https://practice.geeksforgeeks.org/problems/merging-details/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=8-foSocrEV4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=32


--
--

##########################################################################################################################################################################################

-- Next right node

-- https://www.youtube.com/watch?v=5SPNg4blazc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=33
-- https://practice.geeksforgeeks.org/problems/next-right-node/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
from collections import deque
class Solution:
    def nextRight(self, root, key):
        #code here
        queue = [root]
        ans = Node(-1)
        while queue:
            n = len(queue)
            for i in range(n):
                curr = queue.pop(0)
                if curr.data == key and i != n-1:
                    return queue[0]
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
        return ans
            
--

####################################################################################################################################################################################################

-- Binary tree to DLL

-- https://www.youtube.com/watch?v=wSUCZpA1LKY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=34'
-- https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    head = None
    tail = None
    def bToDLL(self,root):
        if not root: return
        self.bToDLL(root.left)
        if not self.head: 
            self.head = root
        else:
            root.left = self.tail
            self.tail.right = root
        self.tail = root
        self.bToDLL(root.right)
        return self.head
--

#####################################################################################################################################################################################################

-- Alternate positive and negative numbers

-- https://www.youtube.com/watch?v=ntt_6CCXDqI&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=35
-- 


--
class Solution:
    def rearrange(self,arr, n):
        # code here
        pos = []
        neg = []
        ans = []
        for i in range(n):
            if arr[i] > 0:
                pos.append(arr[i])
            elif arr[i] < 0:
                neg.append(arr[i])
        
        
        i, j, k, = 0, 0, 0
        while i < len(pos) or j < len(neg):
            if pos[i]:
                ans.append(pos[i])
                i+= 1
            if neg[j]:
                ans.append(neg[j])
                j += 1
        return ans
--

###################################################################################################################################################################################################

-- Count palindromic sequence

-- https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
    def countPS(self,string):
        n = len(string)
        dp = [[-1 for _ in range(n+1)] for _ in range(n+1)]
        
        def sol(i, j, string, dp):
            mod = 1e9+7
            if i == j:
                return 1
            if i > j:
                return 0
            
            if dp[i][j] != -1:
                return dp[i][j]
            
            if string[i] == string[j]:
                dp[i][j] = (1 + sol(i+1, j, string, dp) + sol(i, j-1, string, dp))%mod
            else:
                dp[i][j] = ((sol(i+1, j, string, dp) + sol(i, j - 1, string, dp) - sol(i+1, j-1, string, dp))%mod + mod)%mod
            return dp[i][j]
        
        return int(sol(0, len(string)-1, string, dp))
--



#####################################################################################################################################################################################################

-- Counting elements in two arrays


-- https://practice.geeksforgeeks.org/problems/counting-elements-in-two-arrays/1
-- https://www.youtube.com/watch?v=uLyFwNUCfmw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=37


--
class Solution:
    def countEleLessThanOrEqual(self,arr1,n1,arr2,n2):
        #returns the required output
        res = []
        arr2.sort()
        def binary(target, n2):
            low = 0
            high = n2 - 1
            ans = 0
            while (low<=high):
                mid = low + ((high - low)//2)
                if arr2[mid] > target:
                    ans = mid
                    high = mid - 1
                else:
                    if mid + 1 >= n2:
                        ans = mid + 1
                    low = mid + 1
            return ans
        
        for i in range(n1):
            index = binary(arr1[i], n2)
            res.append(index)
        return res
--

####################################################################################################################################################################################


-- Generate IP address (recursion and backtracking)

-- https://www.youtube.com/watch?v=XU4inpwKt8A&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40
-- https://practice.geeksforgeeks.org/problems/generate-ip-addresses/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=61tN4YEdiTM


--
class Solution:
    def genIp(self, s):
        res = []
        if len(s) > 12:
            return ['-1']

        def sol(i, curStr, dots):
            if dots == 4 and i == len(s):
                res.append(curStr[:-1])
            
            if dots > 4:
                return

            for j in range(i, min(len(s), i+3)):
                if int(s[i: j+1]) < 256 and (i == j or s[i] != "0"):
                    sol(j+1, curStr + s[i: j+1] + '.', dots + 1)
            
        sol(0, '', 0)
        return res
        
        
        
    def valid(self,char):
        if len(char)==0 or len(char)>3 or (char[0]=='0' and len(char)>1) or  int(char)>255:
            return False
        else:
            return True

    def genIp2(self, s):
        n=len(s)
        if len(s)>12:return ['-1']
        ans=[]
        for i in range(1,n-2):
            for j in range(i+1,n-1):
                for k in range(j+1,n):
                    a=s[0:i]
                    b=s[i:j]
                    c=s[j:k]
                    d=s[k:n]
                    if self.valid(a) and self.valid(b) and self.valid(c) and self.valid(d):
                        ans.append(a+"."+b+"."+c+"."+d)
        return ans
--

######################################################################################################################################################

-- foldable tree (Similar to mirror of the tree)

-- https://practice.geeksforgeeks.org/problems/foldable-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=C87kVZOq9Sg&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=39

--
def IsFoldable(root):
    if not root:
        return True
        
    def sol(left, right):
        if not left and not right:
            return 1
        if not left or not right:
            return 0
        return (sol(left.right, right.left) and sol(left.left, right.right))
    
    if sol(root.left, root.right):
        return True
    return False
--


###########################################################################################################################################################

-- Immediate Smaller element

-- https://www.youtube.com/watch?v=75LH0gHa4dQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40 
-- https://practice.geeksforgeeks.org/problems/immediate-smaller-element1142/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
	def immediateSmaller(self,arr,n):
		for i in range(n - 1):
		    if arr[i] > arr[i + 1]:
		        arr[i] = arr[i + 1]
		    else:
		        arr[i] = -1
		arr[n - 1] = -1
		return arr
--


##########################################################################################################################################################

-- Game with nos

-- https://www.youtube.com/watch?v=q5jY1AeOs3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=41
-- 

--
Very easy code
--

#######################################################################################################################################################################

-- Sum of two large numbers

-- https://practice.geeksforgeeks.org/problems/sum-of-numbers-or-number1219/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=-ibOwx3dfaQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44

--
class Solution:
	def findSum(self, X, Y):
		x = X[::-1]
		y = Y[::-1]
		carry = 0
		if len(y) > len(x):
		    x, y = y, x
		    
		i = 0
		j = 0
		ans = ''
		while i<len(x) and j < len(y):
		    carry += int(x[i]) + int(y[j])
		    ans += str(carry%10)
		    carry = carry / 10
		    i += 1
		    j += 1
        while i < len(x):
            carry += int(x[i])
		    ans += str(carry%10)
		    carry = carry / 10
		    i+=1
	    
	    while carry:
	        ans += str(carry%10)
	        carry = carry / 10
	   
	    return ans[::-1]
--

############################################################################################################################################################################

-- Unit area of largest region of 1s (Similar to region in binary matrix)

-- https://www.youtube.com/watch?v=2fI49mrEYmM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=43
-- https://practice.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:

    #Function to find unit area of the largest region of 1s.
	def findMaxArea(self, grid):
		n = len(grid)
		m = len(grid[0])
		ans = 0
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 1:
		            count = self.count(i, j, grid, n, m)
		            ans = max(count, ans)
	    return ans
    
    def count(self, row, col, A, n, m):
        if any([row < 0, col < 0, row >= n, col >= m]):
            return 0
        if A[row][col] == 0:
            return 0
        count = 1
        
        A[row][col] = 0 # so that it wont repeat on loop
        
        for r in range(row - 1, row + 2):
            for c in range(col - 1, col + 2):
                count += self.count(r, c, A, n, m)
        
        return count
--



#########################################################################################################################################################################

-- Longest subarray with sum k (two pointer and sliding window)

-- https://www.youtube.com/watch?v=yDeNqw_dAU0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44
-- https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- method 1 ( works for both positive and negative values) ( use this method for all neg and pos numbers)

=> find prefix sum
=> check for sum - kin dict()

class Solution:
    def lenOfLongSubarr (self, arr, n, k) : 
        m = dict()
        m[0] = -1 # if k = 0 then it might differ like if subarray starts from 0
        l = 0
        curSum = 0
        for i in range(n):
            curSum += arr[i]
            
            if (curSum - k) in m:
                l = max(l, i - m[curSum - k])
            
            if curSum not in m:
                m[curSum] = i
        
        return l
--


-- method 2 ( does not work for negative values)

def max_length(s, k):
    current = []
    max_len = -1 # returns -1 if there is no subsequence that adds up to k.
    for i in s:
        current.append(i)
        while sum(current) > k: # Shrink the array from the left, until the sum is <= k.
           current = current[1:]
        if sum(current) == k:
            max_len = max(max_len, len(current))

    return max_len
--



##################################################################################################################################################################

-- Number of turns in binary tree

-- https://www.youtube.com/watch?v=qWrIMKA3Vm4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=45
-- https://practice.geeksforgeeks.org/problems/number-of-turns-in-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--  Incomplete code

class Solution:
    def NumberOFTurns(self, root, first, second):
        #return the number of turns required to go from first node to second node
        lca = self.lowestCommonAncestor(root, first, second)
        
        
        
    
    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root.data == p or root.data == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        
        if not right:
            return left
        
        else:
            return root
--

##############################################################################################################################################################################

 
-- Max length chain

-- 


--


--

####################################################################################################################################################################################

-- Subarrays sum equals k ( get the number of subarrays equal to k)

-- https://leetcode.com/problems/subarray-sum-equals-k/description/


--
class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:

		ans=0
		prefsum=0
		d={0:1}

		for num in nums:
			prefsum = prefsum + num

			if prefsum-k in d:
				ans = ans + d[prefsum-k]

			if prefsum not in d:
				d[prefsum] = 1
			else:
				d[prefsum] = d[prefsum]+1

		return ans
--


####################################################################################################################################################################

-- Max length chain (greedy)

-- https://practice.geeksforgeeks.org/problems/max-length-chain/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=UTOKMABq4Zs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=46

--
class Solution:
    def maxChainLen(self, Parr, n):
        Parr.sort(key=lambda x:x.b)
        
        result = 1
        end = Parr[0].b
        for pair in Parr:
            if pair.a > end:
                result+=1
                end = pair.b
        return result 
--


#############################################################################################################################################################################


-- Lowest Common Ancestor


-- https://www.youtube.com/watch?v=_-QHfMDde90
-- https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/926531691/


--
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        
        if not right:
            return left
        
        else:
            return root
--

##############################################################################################################################################################################


--  Case specific sorting of strings

-- https://www.youtube.com/watch?v=synFG_49iC0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=48
-- https://practice.geeksforgeeks.org/problems/case-specific-sorting-of-strings4845/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.geeksforgeeks.org/case-specific-sorting-of-strings/

--
class Solution:

    #Function to perform case-specific sorting of strings.
    def caseSort(self,s,n):
        #code here
        lower = [0 for _ in range(50)]
        upper = [0 for _ in range(50)]
        res = ''
        l = 0
        u = 0
        for character in s:
            if ord(character) >= ord('a') and ord(character) <= ord('z'):
                lower[abs(ord(character) - ord('a'))] += 1
            else:
                upper[abs(ord(character) - ord('A'))] += 1
        
        for i in range(n):
            if ord(s[i]) >= ord('a') and ord(s[i]) <= ord('z'):
                while lower[l] == 0:
                    l += 1
                
                res += (chr(ord('a') + l))
                lower[l] -= 1
            else:
                while upper[u] == 0:
                    u += 1
                
                res += chr(ord('A') + u)
                upper[u] -= 1
                
        return res
--

##############################################################################################################################################################################

-- knight walk

-- https://www.youtube.com/watch?v=n4RbVQxvEXc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=48
-- https://practice.geeksforgeeks.org/problems/knight-walk4521/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
	def minStepToReachTarget(self, KnightPos, TargetPos, N):
		#Code here
		
		vis = [[0 for i in range(N+1)] for _ in range(N+1)]
		queue = [(KnightPos[0], KnightPos[1], 0)]

        if KnightPos == TargetPos:
            return 0
        
        dx = [1, 1, -1, -1, 2, 2, -2, -2] # moves for knight in x direction
        dy = [2, -2, 2, -2, 1, -1, 1, -1] # moves for knight in y direction
        
        while queue:
            x, y, moves = queue.pop(0)
            
            if (x == TargetPos[0] and y == TargetPos[1]):
                return moves
            
            for k in range(8):
                nx = dx[k] + x 
                ny = dy[k] + y
                
                if nx >= 1 and ny >= 1 and ny <= N and nx <= N and vis[nx][ny] == 0:
                    vis[nx][ny] = 1
                    queue.append((nx, ny, moves + 1))
                    
                 
        return -1
--

====================================================================================================================================================================================

-- gcd  *****


-- https://www.programiz.com/python-programming/examples/hcf
-- https://www.youtube.com/watch?v=DePWIOK1STg


--
--

####################################################################################################################################################################################

-- Fact Digit Sum


-- https://www.youtube.com/watch?v=cAWhCK6s89w&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=49
-- https://practice.geeksforgeeks.org/problems/fact-digit-sum4125/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
	def FactDigit(self, N):
		# Code here
		
		f = [1 for _ in range(10)]
		ans = []
		
		for i in range(1, 10):
		    f[i] = f[i - 1] * i
		
	    for i in range(9, -1, -1):
	        while f[i] <= N:
	            N -= f[i]
	            ans.append(i)
	    
	    return ans[::-1]
--

#################################################################################################################################################################


-- Pots of Gold (Recursion with dp)


-- https://www.youtube.com/watch?v=lgu2KrAcoVY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=50
-- https://practice.geeksforgeeks.org/problems/pots-of-gold-game/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


Steps:

	can chosse from left side or right side
	if choose from left then  (l+1, r) will be left
	if choose from right then (l, r+1) will be left 
--
class Solution:
    def maxCoins(self,arr, n):
        # Code here
        
        d = [[-1 for _ in range(n)] for _ in range(n)]
        return self.recursion(0, n-1, arr, d)
        
    
    def recursion(self, l, r, arr, d):
        if l > r:
            return 0
        
        if d[l][r] != -1:
            return d[l][r]
        
        left = arr[l] + min(self.recursion(l+2, r, arr, d), self.recursion(l+1, r-1, arr, d))
        right = arr[r] + min(self.recursion(l+1, r-1, arr, d), self.recursion(l, r-2, arr, d))
        
        ans = max(left, right)
        d[l][r] = ans
        return ans
--


#####################################################################################################################################################################

-- M - coloring  (recursion and backtracking)

-- https://www.youtube.com/watch?v=W2UtRi2N1cg&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=51
-- https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--

-> try it with all possible ways
   
	--> recursion with backtracking

--



############################################################################################################################################################################################ 


-- Nine Divisors (Simple math)
 

-- https://www.youtube.com/watch?v=VyFxFoKi9_k&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=52

-- https://practice.geeksforgeeks.org/problems/nine-divisors3751/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
import math


#User function Template for python3
class Solution:
    def nineDivisors(self, N):
        # code here 
        
        # if we have a2 and b2 when both are prime then we have 7 combinations and plus for the 1 and number itself
        
        # a**2 x b**2  -> (p1**2 and p2**2) <= N
        # 1, p**8 -> prime number to the power 8
        
        # steps
        # find all prime <= sqrt(N)
        
        limit = math.sqrt(N) + 1
-- 

#########################################################################################################################

-- Josepheus problem (Recursion)

-- https://www.youtube.com/watch?v=HEQN_dejrbw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=53
-- https://practice.geeksforgeeks.org/problems/josephus-problem/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def josephus(self,n,k):
        #Your code here
        
        arr = [i+1 for i in range(n)]
        
        def rec(arr, index, k):
            if len(arr) == 1:
                return
        
            index = (index + k - 1 ) % len(arr)
            del arr[index]
            rec(arr, index, k)
        
        rec(arr, 0, k)
        return arr[0]
--


##############################################################################################################################

-- Quick sort on doubly linked list  (Lomuto and Hoares algorithmn)

-- https://www.youtube.com/watch?v=ms_rjPaUNqs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=55
-- https://practice.geeksforgeeks.org/problems/quicksort-on-doubly-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


Ways to partition the array

1. Naive
2. Lomuto
3. Hoares


--  Lomuto method used
class Solution:
    def partition(self, l, h):
        # Your code goes here
        
        
        # using the lomuto method
        
        
        # first assign high element to pivot and (low - 1) element to i
        
        # In loop Compare the j and pivot 
        
        pivot = h.data
        i = l.prev
        
        j = l
        
        while j != h:
            if j.data <= pivot:
                if i is not None:
                    i = i.next
                else:
                    i = l
                i.data, j.data = j.data, i.data
                
            j = j.next
            
        if i is not None:
            i = i.next
        else:
            i = l
        
        i.data, h.data = h.data, i.data 
        return i
--


############################################################################################################################################

-- X total shapes

-- https://www.youtube.com/watch?v=Hu1ahbUTBmk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=56
-- https://practice.geeksforgeeks.org/problems/x-total-shapes3617/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
    
    #Function to find the number of 'X' total shapes.
    def dfs(self, row, col, n, m, grid):
        if row < 0 or col < 0 or row >= n or col >= m or grid[row][col] == 'O':
            return
        
        grid[row][col] = 'O'
        
        self.dfs(row - 1, col, n, m, grid)
        self.dfs(row + 1, col, n, m, grid)
        self.dfs(row, col - 1, n, m, grid)
        self.dfs(row, col + 1, n, m, grid)
        
        
	def xShape(self, grid):
		#Code here
		n = len(grid)
		m = len(grid[0])
		count = 0
		
		
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 'X':
		            count += 1
		            self.dfs(i, j, n, m, grid)
	
	    return count
--



####################################################################################################################################################


-- PreOrder to BST


-- https://www.youtube.com/watch?v=-XnqvzYGQGs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=57
-- https://practice.geeksforgeeks.org/problems/preorder-to-postorder4423/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- Two method 
	1. build the BST by traversing the array one by one O(N**2)
	2. we need Preorder and Inorder traversal 
		-> Inorder traversal is the ascending order of the BST  O(logN) max
	3. have range for particular node in BST separately


--
#User function Template for python3

class Node:

    def __init__(self, data=0):
        self.data = data
        self.left = None
        self.right = None

#Function that constructs BST from its preorder traversal.
    

def rec(pre, n, i, mi, mx):
    
    if i >= n: 
        return None
    
    if mi > pre[i] or pre[i] > mx:
        return None
    
    root = Node(pre[i])
    
    i = i + 1
    
    root.left = rec(pre, n, i, mi, root.data - 1)
    root.right = rec(pre, n, i, root.data - 1, mx)
    
    return root
    

def post_order(pre, size) -> Node:
    #code here
    
    i = 0
    mi = float('-inf')
    mx = float('inf')
    
    root = rec(pre, size, i, mi, mx)
    
    return root
--



############################################################################################################################################

-- Complete Binary tree


-- For a complete binary tree 
	-> All the levels are filled except the lowest level
	-> filled from left

-- https://www.youtube.com/watch?v=eu0mbmfHgyM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=58
-- https://practice.geeksforgeeks.org/problems/complete-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--

class Solution():
    def isCompleteBT(self, root):
        #Add Code Here
        
        # first go to left to right if left child is not present then it is not complete binary tree
        
        # Use level order traversal
        # BFS (level order traversal) using queue
        
        
        if root is None:
            return 1
        
        ok = 0
        
        queue = [root]
        
        while len(queue)>0:
            node = queue.pop(0)
            
            if node.left:
                if ok:
                    return 0
                else:
                    queue.append(node.left)
            else:
                ok = 1
                
            if node.right:
                if ok:
                    return 0
                else:
                    queue.append(node.right)
            else:
                ok = 1
            
        return 1
--


######################################################################################################################################################


-- Delete nodes greater than k


-- https://www.youtube.com/watch?v=eu0mbmfHgyM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=58
-- https://practice.geeksforgeeks.org/problems/delete-nodes-greater-than-k/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    # your task is to complete this function
    # function should delete all the Nodes greater than or equal to k
    # function should return the new head to pointer
    def deleteNode(self, root, k):
        # Code here
        
        # use post order traversal
        
        if root is None:
            return None
            
        root.left = self.deleteNode(root.left, k)
        root.right = self.deleteNode(root.right, k)
        if root.data >= k:
            temp = root.left
            del root
            return temp
        return root
--


######################################################################################################################################################

-- Egg droping puzzle (dp and recursion)

-- https://www.youtube.com/watch?v=siViBAILDi8&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=60
-- https://practice.geeksforgeeks.org/problems/elements-in-the-range2834/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/


## Here u need to take the minimum of worst cases

--
class Solution:
    
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self,n, k):
        # code here
        
        
        # two chances if u drop from the floor
            # either egg breaks -> then n-1 and go down (i - 1, n - 1)
            # egg doesnot break -> then n and go up ( k - i, n)
            
        def rec(n, k, dp):
            if n == 1 or k == 0 or k == 1:
                return k
                
            if dp[n][k] != -1:
                return dp[n][k]
            
            
            ans = float('inf')
            
            for i in range(1, k + 1):
                
                c1 = rec(n - 1, i - 1, dp) # egg breaks
                c2 = rec(n, k - i, dp) # if egg does not break
                
                
                worst = 1 + max(c1, c2)
                ans = min(ans, worst)
                
            dp[n][k] = ans
            return dp[n][k]
                
                
        dp = [[-1 for x in range(k + 1)] for _ in range(n + 1)]
        return rec(n , k, dp)
--



########################################################################################################################################################


-- Elements in the range


-- https://www.youtube.com/watch?v=Ykp4ZIlBNfw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=61
-- https://practice.geeksforgeeks.org/problems/elements-in-the-range2834/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def check_elements(self, arr, n, A, B):
        # Your code goes here
        
        
        # for eg from 2 to 5 
        # to get the index of 4 in range 2 to 5 -> take 4 and substrat with 2
        # so the index of 4 is -> 4 - 2 => 2 
        # same goes for all others 
        
        
        # get the index and then if present make the index of the array neg
        # later traverse the array till the number of elements like 2 - 5 + 1 then check the neg elements array 
        
        
        ranges = B - A
        for i in range(n):
            
            if abs(arr[i]) <= B and abs(arr[i]) >= A:
                temp = abs(arr[i]) - A
                 
                if temp < n and arr[temp] > 0:
                    arr[temp] *= -1
                
        count = 0
        
        for i in range(0, ranges + 1):
            if i < n:
                if arr[i] > 0:
                    return False
                else:
                    count += 1
        
        return True if count == (ranges + 1) else False
--



#################################################################################################################################################################################

-- Repeated Character


-- https://practice.geeksforgeeks.org/problems/repeated-character2058/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=D0IQVwa5wOU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=62

--
class Solution:
    def firstRep(self, s):
        # code here
        
        # hashing
        
        # we need the array of 26 to hash the value a[26]
        
        n = len(s)
        a = [(n + 2) for _ in range(27)]
        pos = n + 1
        ans = "#"
        
        for i in range(n):
            if a[ord(s[i]) - ord("a")] < pos:
                pos = a[ord(s[i]) - ord("a")]
                ans = s[i]
            
            else:
                a[ord(s[i]) - ord("a")] = i
        return ans
        
--

########################################################################################################################################################

-- Geek and knots (DP) (Hard can be solved by pascals triangle)

--  https://www.youtube.com/watch?v=Nk2RLImBXCo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=63
-- https://practice.geeksforgeeks.org/problems/little-murph-and-knots0402/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day



--
class Solution:
    mod = 1000000007
    def ncr(self, n, r):
        if r == 0 or r == n:
            return 1
        
        return ncr(n-1, r-1) + ncr(n-1, r-1)
        
    def knots(self, M, N, K):
        # code here
        
        # try to use the pascals triangle method using permutation and combination
        
        # using dp
        
        dp = [[0 for _ in range(max(M, N)+1)] for _ in range(max(M, N) + 1)]
        
        for i in range(max(M, N) + 1):
            dp[i][0] = 1
            dp[i][i] = 1
            
            for j in range(1, i):
                dp[i][j] = (dp[i-1][j -1]%self.mod + dp[i-1][j]%self.mod)%self.mod
                
        ans = ((dp[N][K]%self.mod) * (dp[M][K]%self.mod) )%self.mod
        return int(ans)
            
--


###########################################################################################################################################################


-- Adding array elements 


-- https://www.youtube.com/watch?v=vxGqGEwqahY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=64
-- https://practice.geeksforgeeks.org/problems/adding-array-element4756/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
from heapq import heapify, heappush, heappop
class Solution:
    def minOperations(self, arr, n, k):
        # code here
        
        # you can use minheap
        heap = []
        heapify(heap)
        count = 0
        
        for i in range(n):
            heappush(heap, arr[i])
            
        if heap[0] > k:
            return 0
        
        while not len(heap) <= 1 and heap[0] < k:
            count += 1
            a = heappop(heap)
            b = heappop(heap)
            
            c = a + b
            heappush(heap, c)
            
        if heap[0] < k:
            return -1
        
        return count
--


###################################################################################################################################################


-- Length of Longest Palindrome 


-- https://practice.geeksforgeeks.org/problems/length-of-longest-palindrome-in-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=C-ji87LXc74&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=65


--
--



##################################################################################################################################################

-- Max Sum leaf to root 


-- https://practice.geeksforgeeks.org/problems/maximum-sum-leaf-to-root-path/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article
-- https://www.youtube.com/watch?v=SqYiGzF2IUI&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=67
-- https://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/

--
class Solution:
    def maxPathSum(self, root):
        #code here
        
        def dfs(node):
            
            if not node:
                return 0
                
            
            lsum = dfs(node.left)
            rsum = dfs(node.right)
            
            if(lsum==0 or rsum==0):
                stepmax = lsum+rsum     # this condition to also get the negative numbers
            else:
                stepmax = max(lsum,rsum)
            
            return node.data + stepmax
        
        return dfs(root)
--


########################################################################################################################################################

-- Levels of game


-- https://practice.geeksforgeeks.org/problems/levels-of-game/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=YLln1c75lO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=68

--
from typing import List


class Solution:
    def maxLevel(self, h:int,m:int) -> int:
        # code here
        
        # recursion (seems like greedy but watch the video to understand)
        # https://www.youtube.com/watch?v=YLln1c75lO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=68
        
        # p1 -> h+3, m+2
        # p2 -> h-5, m-10
        # p3 -> h-20, m+5
        
        # try all possible path except the previous path
        # 3d dp is required h, m, c
        dp = [[ [-1 for col in range(2020)] for col in range(2020)] for row in range(3)]
        dx = [3, -5, -20]
        dy = [2, 10, 5]
        
        def f(h, m, c):
            if h <= 0 or m <= 0:
                return -1
                
            if dp[h][m][c] != -1:
                return dp[h][m][c]
                
            res = 0
            
            for i in range(3):
                if(i != c):
                    res = max(res, f(h+dx[i], m+dy[i], i) + 1)
            
            dp[h][m][c] = res
            return res
            
        ans = 0
        
        for i in range(3):
            ans = max(ans, f(h, m, i))
        
        return ans    
--


####################################################################################################################################

-- Number of Provices (Connected components graph)

(Refer the leetcode)
-- https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/ 
-- https://www.youtube.com/watch?v=jwMT8U8acz0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=69
-- https://practice.geeksforgeeks.org/problems/number-of-provinces/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=ZGr5nX-Gi6Y


--
class Solution:
    def numProvinces(self, adj, V):
        # code here 
        
        
        # similar to connected components difference is just with the input format
        
        vis = [0]* V
        ans = 0
        
        def dfs(adj, V, node, vis):
            vis[node] = 1
            
            for i in range(V):
                if adj[node][i] == 1 and vis[i] == 0:
                    dfs(adj, V, i, vis)
        
        for i in range(V):
            if vis[i] == 0:
                ans += 1
                dfs(adj, V, i, vis)
        
        return ans
--

##################################################################################################################################


-- Get min at pop


-- https://practice.geeksforgeeks.org/problems/get-min-at-pop/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=8loqyMoxNfY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=70


--
def _push(a,n):
    st = []
    st.append(a[0])

    # code here
    for i in range(1, n):
        st.append(min(st[len(st) - 1], a[i]))
    
    return st


#Function to print minimum value in stack each time while popping.    
def _getMinAtPop(st):
    
    # code here
    
    # if stack is empty then push the element
    # if not, then push min(stack[0], arr[i])

        
    while st:
        temp = st.pop()
        print(temp, end= " ")
--

###############################################################################################################################################################


-- Form a palindrome (dp use LCS)

-- https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/
-- https://www.youtube.com/watch?v=FquxDjU1O4Q&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=71
-- https://practice.geeksforgeeks.org/problems/form-a-palindrome1455/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day




-- Code not completed

class Solution:
    def countMin(self, Str):
        # code here
        
        # you need to use the LCS 
        # where in LCS = (s1, reverse(S1))
        # then subtract it with length of the string
        
        
        # length(s) - LCS
        
        def lcs(X, Y, m, n, dp):
 
            if (m == 0 or n == 0):
                return 0
         
            if (dp[m][n] != -1):
                return dp[m][n]
         
            if X[m - 1] == Y[n - 1]:
                dp[m][n] = 1 + lcs(X, Y, m - 1, n - 1, dp)
                return dp[m][n]
         
            dp[m][n] = max(lcs(X, Y, m, n - 1, dp), lcs(X, Y, m - 1, n, dp))
            return dp[m][n]
--


#########################################################################################################################################################################

-- Count Smaller elements

-- https://www.youtube.com/watch?v=aqftBCqPu_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=72
--

--
 
-- 


####################################################################################################################################################################

-- Ceil in BST


-- https://www.youtube.com/watch?v=4_06GvIv9wY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=73
-- https://practice.geeksforgeeks.org/problems/implementing-ceil-in-bst/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- Two methods are there choose either one
class Solution:
    def findCeil1(self,root, inp):
        # code here
        
        global ans
        ans = float('inf')
        
        def bftdfs(node, key):
            global ans
            if not node:
                return
            
            if node.key >= key:
                ans = min(ans, node.key)
    
            if node.key >= key:
                bftdfs(node.left, key)
            else:
                bftdfs(node.right, key)
            
        bftdfs(root, inp)
        
        if (float('inf') == ans):
            return -1
        
        return ans
        
    
    def findCeil(self, root, inp):
        ans = -1
        curr = root
        
        while curr:
            if curr.key >= inp:
                ans = curr.key
                curr = curr.left
            else:
                curr = curr.right
        
        return ans
--


###################################################################################################################################################################

-- Binary Matrix with at most k 1s (Binary Search)


-- https://www.youtube.com/watch?v=SzLQVC7uFjw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=76
-- https://practice.geeksforgeeks.org/problems/largest-square-in-a-binary-matrix-with-at-most-k-1s-for-multiple-queries/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- Refer the video for clear understanding

class Solution:
    def largestSquare(self, M, R, C, k, Q, q_i, q_j):
        # code here 
        
        # we need to find prefix to find the number of 1s in array
        
        prefix = [[0 for _ in range(C)] for _ in range(R)]
        
        prefix[0][0] = M[0][0]
        res = []
        
        # first perform prefix sum on all rows and then on all columns => first vertical and then horizontal
        
        for i in range(1, R):
            prefix[i][0] = prefix[i - 1][0] + M[i][0]
            
        for j in range(1, C):
            prefix[0][j] = prefix[0][j - 1] + M[0][j]
            
        
        #  and then perform this equation to get prefix sum 
        
        for i in range(R):
            for j in range(C):
                prefix[i][j] = M[i][j] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i][j]
                
                
        
        # Now solve for the each given query
        
        for q in range(Q):
            i = q_i[q]
            j = q_j[q]
            
            # get the minimum square distance to find the maximum size of square
            
            # maximum size of the square is 2*m + 1
            
            min_dist = min(min(i, j), min(R - i - 1, C - j - 1))
            ans = -1
            
            # do to binary search
            l = 0
            u = min_dist
            
            while (l <= u):
                mid = (l + u)//2
                
                x1 = i - mid
                x2 = i + mid
                y1 = j - mid
                y2 = j + mid
                
                count = prefix[x2][y2]
                
                if x1 > 0:
                    count -= prefix[x1 - 1][y2]
                if x2 > 0:
                    count -= prefix[x2][y1 - 1]
                    
                if x1 > 0 and y1 > 0:
                    count += prefix[x1 - 1][y1 - 1]
                    
                
                if count <= k:
                    ans = 2 * mid + 1
                    l = mid + 1
                
                else: 
                    u = mid - 1
                
            
            if ans == -1:
                ans = 0
            res.append(ans)

--



############################################################################################################################################################################

-- Partition array to K subsets

-- Be it discontinuos but it should be in same order

-- https://www.youtube.com/watch?v=90R1xPMPayU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=75
-- https://practice.geeksforgeeks.org/problems/partition-array-to-k-subsets/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- Not fully completed check properly

class Solution:
    def isKPartitionPossible(self, array, k):
        #code here
        
        # recursion and backtracking
        # visited array to make sure no repeatation is there
        
        global arraySum 
        arraySum = sum(array) 
        
        if k > len(array) or arraySum % k != 0:
            return 0
            
        global ssum
            
        ssum = int(arraySum / k)
        print(ssum)
            
        visited = [False] * len(array)
        global count 
        count = 0
        
        def recursion(vis, a, curSum, k):
            global count
            global ssum
            
            if k == 1:
                return 1
                
            if curSum > ssum:
                return 0
            
            if curSum == sum:
                return recursion(vis, a, 0, k - 1)
                
            for i in range(len(a)):
                if not vis[i]:
                    vis[i] = True
                    if (recursion(vis, a, a[i] + curSum, k)):
                        return 1
                    vis[i] = False
            return 0
            
            
            
            
        
        return recursion(visited, array, 0, k)

--



############################################################################################################################################

-- Min sum formed by digits

-- https://practice.geeksforgeeks.org/problems/min-sum-formed-by-digits3551/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=_HmRD7Yzeic&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=76


-- 
class Solution:
    def minSum(self, arr, n):
        # Your code goes here
        
        arr.sort()
        s = 0
        b = 0
        
        for i in range(len(arr)):
            
            if i % 2 == 0: 
                s = s*10 + arr[i]
            else:
                b = b*10 + arr[i]
            
            
        return s + b
--


###################################################################################################################################################


-- BST to greater sum tree


-- https://www.youtube.com/watch?v=vE2mhSHwxmw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=77
-- https://practice.geeksforgeeks.org/problems/bst-to-greater-sum-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def transformTree(self, root):
        #code here
        
        # the output looks like in descending order and can use reverse inorder
        
        def rec(node, sum):
            if not node:
                return 
            
            rec(node.right, sum)
            
            temp = node.data
            node.data = sum
            sum += temp
            
            rec(node.left, sum)
            
        rec(root, 0)
        return
--

################################################################################################################################################

-- Assignment problem  (Hungarian algo.) (Very hard problem)

--  https://www.youtube.com/watch?v=-C6Om_Nv6MY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=78
--  https://practice.geeksforgeeks.org/problems/assignment-problem3016/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=E_xr_7R4rBQ

-- Hungarian algo.

   -> Subtract lowest value in each row from every element in the row 
   -> if a column doesnt contain a zero subtract the lowest value from every element in the column
   -> add the smallest uncovered value to elements that are covered by 2 lines and subtract it from all the uncovered elements
--

--

--

##################################################################################################################################################################

-- Reaching the heights

-- https://www.youtube.com/watch?v=Huwj9RBxdsA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=79
-- https://practice.geeksforgeeks.org/problems/reaching-the-heights1921/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
def reaching_height (n, arr) : 
    #Complete the function
    
    # sort in ascending order
    # using two pointers at two ends
    # for the even index use the high number and vice versa for odd index
    
    if n == 1:
        return arr
    
    arr.sort()
    
    if arr[0] == arr[n -1]:
        return [-1]
    
    i = 0
    j = n - 1
    flag = 0
    res = []
    
    while i <= j:
        if flag == 0:
            res.append(arr[j])
            j -= 1
            flag = 1
        else:
            res.append(arr[i])
            i += 1
            flag = 0
    
    return res
--


#########################################################################################################################################################################

-- Shortest Uncommon subsequence   (consider the last solution)

-- https://www.youtube.com/watch?v=tGlSd-hCCl8&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=80
-- https://practice.geeksforgeeks.org/problems/shortest-uncommon-subsequence5746/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://chat.openai.com/c/ea5e1a81-0a79-48f5-bbbf-61fa8fe34669

-- order for the string is maintained


class Solution2:
    def shortestUnSub(self, S, T):
        # code here 
        
        # done using recursion and dp
        # get the minimum of the length of uncommon subsequence
        n = len(S)
        m = len(T)
        
        dp = [[-1 for _ in range(501)] for _ in range(501)]
        
        global intmax 
        intmax = 501
        
        def rec(n, m, s, t):
            global intmax
            if n == 0:
                return 501
            if m == 0:
                return 1
                
            if dp[n][m] != -1:
                return dp[n][m]
            
            ans = intmax
            
            # loop apllied on string t 
            j = -1
            for k in range(m - 1, -1, -1):
                if t[k] == s[n - 1]:
                    j = k
                    break

                
            if j == -1:
                ans = 1
            else: 
                ans = min(rec(n - 1, m, s, t), rec(n - 1, j, s, t) + 1)
                
            dp[n][m] = ans
            
            return ans
        
        res = rec(n, m, S, T)
        if res >= intmax:
            return -1
        return res
        
        
class Solution3:
    def shortestUnSub(self, S, T):
        # code here 
        
        # done using recursion and dp
        # get the minimum of the length of uncommon subsequence
        n = len(S)
        m = len(T)
        
        dp = [[-1 for _ in range(501)] for _ in range(501)]
        
        global intmax 
        intmax = 501
        
        def rec(n, m, s, t):
            global intmax
            if n == 0:
                return 501
            if m == 0:
                return 1
                
            if dp[n][m] != -1:
                return dp[n][m]
            
            ans = intmax
            
            # loop applied on string t 
            j = -1
            for k in range(m - 1, -1, -1):
                if t[k] == s[n - 1]:
                    j = k
                    break
                
            if j == -1:
                ans = 1
            else: 
                ans = min(rec(n - 1, m, s, t), rec(n - 1, j, s, t) + 1)
                
            dp[n][m] = ans
            
            return ans
        
        # Convert strings to lists for mutability
        S_list = list(S)
        T_list = list(T)
        
        res = rec(n, m, S_list, T_list)
        
        # Convert lists back to strings if needed
        S_result = ''.join(S_list)
        T_result = ''.join(T_list)
        
        if res >= intmax:
            return -1
        return res

class Solution4:
    def rec(self, n, m, s, t, dp):
        if n == 0:
            return 501
        if m == 0:
            return 1
        
        if dp[n][m] != -1:
            return dp[n][m]
        
        ans = 501
        
        # Loop applied on string t
        j = -1
        for k in range(m - 1, -1, -1):
            if t[k] == s[n - 1]:
                j = k
                break
        
        if j == -1:
            ans = 1
        else:
            ans = min(self.rec(n - 1, m, s, t, dp), self.rec(n - 1, j, s, t, dp) + 1)
        
        dp[n][m] = ans
        
        return ans
    
    def shortestUnSub(self, S, T):
        n = len(S)
        m = len(T)
        
        dp = [[-1 for _ in range(501)] for _ in range(501)]
        
        intmax = 501
        
        res = self.rec(n, m, list(S), list(T), dp)
        
        S_result = ''.join(list(S))
        T_result = ''.join(list(T))
        
        if res >= intmax:
            return -1
        
        return res
        
        
class Solution5:
    def solve(self, s, t, i, j, dp):
        if i < 0:
            return 1000
        
        if j < 0:
            return 1
        
        if dp[i][j] != -1:
            return dp[i][j]
        
        k = j
        while k >= 0:
            if t[k] == s[i]:
                break
            k -= 1
        
        if k < 0:
            return 1  # this character is not present in t
        
        ans1 = self.solve(s, t, i - 1, j, dp)
        ans2 = 1 + self.solve(s, t, i - 1, k - 1, dp)
        
        dp[i][j] = min(ans1, ans2)
        return dp[i][j]
    
    def shortestUnSub(self, s, t):
        ssz = len(s)
        tsz = len(t)
        dp = [[-1 for _ in range(tsz)] for _ in range(ssz)]
        
        ans = self.solve(s, t, ssz - 1, tsz - 1, dp)
        
        if ans >= 1000:
            return -1
        
        return ans


class Solution6:
   def __init__(self):
       self.indices={} 
   def shortestUnSub(self, S, T):
       m= len(S)
       n= len(T)
       dp=[[0]*(n+1) for _ in range(m+1)]
       
       for i in range(n+1):
           dp[0][i]=501 
           
       for i in range(1, m+1):
           dp[i][0]= 1
           
       for i in range(1, m+1):
           for j in range(1, n+1):
               k=j-1
               ch= S[i-1]
               if(ch==T[k]):
                   self.indices[ch]=k
               elif(ch in self.indices):
                   k = self.indices[ch]
               else:
                   while(k>=0):
                       if(T[k]==S[i-1]): 
                           break
                       k-=1
                   self.indices[ch]=k
               if(k==-1): 
                   dp[i][j]=1
               
               else: 
                   dp[i][j]= min(dp[i-1][j], 1+dp[i-1][k])
               ans= dp[i][j]
               if ans>= 501:
                   ans=-1
       return ans
       
       
       
class Solution7:
    def __init__(self):
        self.indices = {}

    def shortestUnSub(self, S, T):
        m = len(S)
        n = len(T)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # Initialization of dp table
        for i in range(n + 1):
            dp[0][i] = 501

        for i in range(1, m + 1):
            dp[i][0] = 1

        # Main dynamic programming loop
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                k = j - 1
                ch = S[i - 1]

                # Updating the index of the current character in T
                if ch == T[k]:
                    self.indices[ch] = k
                elif ch in self.indices:
                    k = self.indices[ch]
                else:
                    while k >= 0:
                        if T[k] == S[i - 1]:
                            break
                        k -= 1
                    self.indices[ch] = k

                # Calculating dp value
                if k == -1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i - 1][j], 1 + dp[i - 1][k])

        # Final result calculation
        ans = dp[m][n]
        if ans >= 5
        01:
            ans = -1

        return ans
        
class Solution:
    def __init__(self):
        self.indices = {}

    def shortestUnSub(self, S, T):
        m = len(S)
        n = len(T)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # Initialization of dp table
        for i in range(n + 1):
            dp[0][i] = 501

        for i in range(1, m + 1):
            dp[i][0] = 1

        # Main dynamic programming loop
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                k = j - 1
                ch = S[i - 1]

                # Updating the index of the current character in T
                if ch == T[k]:
                    self.indices[ch] = k

                # Correcting the else block
                else:
                    k = self.indices.get(ch, -1)

                # Calculating dp value
                if k == -1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i - 1][j], 1 + dp[i - 1][k])

        # Final result calculation
        ans = dp[m][n]
        if ans >= 501:
            ans = -1

        return ans
-- 


######################################################################################################################################################

-- Find all possible paths from top to bottom

-- https://chat.openai.com/c/e1397214-6b3d-41d8-b6bc-9903bf6e7d1c
-- https://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/
-- https://www.youtube.com/watch?v=Jdctlrjp1YI&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=81

--
from typing import List
class Solution:
    def findAllPossiblePaths(self, n : int, m : int, grid : List[List[int]]) -> List[List[int]]:
        # code here
        ans = []
        
        def backtrack(grid, row, col, n, m, path):
           
            if row == n - 1 and col == m - 1:
                
                path.append(grid[row][col])
                ans.append(path[:])     # important ************
                path.pop()
                return 
    
            if row < 0 or row >= n or col >= m or col < 0:
                return 
            
            path.append(grid[row][col])
            
            backtrack(grid, row + 1, col, n, m, path)
            backtrack(grid, row, col + 1, n, m, path)
            
            path.pop()
        
        
        backtrack(grid, 0, 0, len(grid), len(grid[0]), [])
        return ans
--


##################################################################################################################################################### 

-- Polynomial addition

-- https://practice.geeksforgeeks.org/problems/polynomial-addition/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=BF3YD86PSVo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=82

--
'''
 class node:
    def __init__(self, coeff, pwr):
        self.coef = coeff
        self.next = None
        self.power = pwr
'''

class Solution:
    # return a linked list denoting the sum with decreasing value of power
    def addPolynomial(self, p1, p2):
        # Code here
        
        res = node(0, 0)
        prev = res
        
        while p1 and p2:
            if p1.power < p2.power:
                prev.next = p2
                p2 = p2.next
            
            elif p1.power > p2.power:
                prev.next = p1
                p1 = p1.next
            
            else:
                prev.coef = p1.coef + p2.coef
                prev.next = p1
                p1 = p1.next
                p2 = p2.next
            prev = prev.next
                
                
        if p1:
            prev.next = p1
        
        if p2:
            prev.next = p2
            
        return res.next
--

############################################################################################################################################

-- Brackets in Matrix chain multiplication

-- https://practice.geeksforgeeks.org/problems/brackets-in-matrix-chain-multiplication1024/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=8EnQPglnEVU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=83


--
class Solution:
    # for the minimum number
    def matrixChainOrder1(self, p, n):
        # code here
        dp = [[-1 for _ in range(n)] for _ in range(n)]
        global ans
        ans = float("inf")
        
        def recursion(i, j, p):
            global ans
            
            if i == j:
                
                return 0
            
            if dp[i][j] != 0:
                return dp[i][j]
            
            for k in range(i, j):
                ans = max(ans, p[i - 1] * p[k] * p[j] + recursion(i, k, p) + recursion(k + 1, j, p))
            
            dp[i][j] = ans
            return ans
        
        recursion(1, n - 1, p)
        return ans
        
    
    def matrixChainOrder(self, p, n):
        # code here
        # for the string output
        dp = [[("", -1) for _ in range(n)] for _ in range(n)]
        global ans
        ans = float("inf")
        
        def recursion(i, j, p):
            global ans
            
            if i == j:
                st = ""
                st += chr(ord('A') + i - 1)
                return (st, 0)
            
            if dp[i][j][1] != -1:
                return dp[i][j]
                
            m = float("inf")
            s = ""
            
            
            for k in range(i, j):
                p1 = recursion(i, k, p)  # left part
                p2 = recursion(k + 1, j, p)  # right part
                x = p1[1] + p2[1] + p[i - 1] * p[k] * p[j]
                s = "(" + p1[0] + p2[0] + ")"
                
                if (m > x):
                    m = x
                    sr = s
            
            dp[i][j] = (sr, m)
            return dp[i][j]
        
        res = recursion(1, n - 1, p)
        return res[0]
--

##########################################################################################################################################################

-- Brain Game 

-- https://www.youtube.com/watch?v=Nrvjwas1ctM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=84
-- https://practice.geeksforgeeks.org/problems/brain-game1742/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- giving tle check once
class Solution:
	def brainGame(self, nums):
		# Code here
		# similar to nim game
		
		# find the factors of numbers apart from 1, and number itself
		# actually get the nuumber of factors
		
		# Prime C
		
		# and calculate the number of primes and factors
		
		
		# max(a[j], a[i] + 1)
		
		a = [0] * 1001
		
		for i in range(2, 1001):
		    for j in range(4, 1001):
		        a[j] = max(a[j], a[i] + 1)
		        
        x = 0
        for i in range(len(nums)):
            x = x ^ a[nums[i]]
        
        if (x == 0):
            return False
        return True
--


########################################################################################################################################################################