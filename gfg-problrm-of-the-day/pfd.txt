-- Min cost of ropes
-- https://www.youtube.com/watch?v=cL_IRO8Yzeo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=4
-- https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1

--
import heapq
class Solution:
    #Function to return the minimum cost of connecting the ropes.
    def minCost(self,arr,n) :
    
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            firstMinimumRope = heapq.heappop(arr)
            secondMinimumRope = heapq.heappop(arr)
            
            res += firstMinimumRope + secondMinimumRope
            heapq.heappush(arr, firstMinimumRope + secondMinimumRope)
            
        return res
--

################################################################################################################

-- Queries of matrix
-- https://www.youtube.com/watch?v=G2OBYDINXLU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=5
-- https://practice.geeksforgeeks.org/problems/queries-on-a-matrix0443/1

--
	def solveQueries(self, n, Queries):
	    matrix = [[0 for _ in range(n)] for _ in range(n)]
	    
	    for i in range(len(Queries)):
	        a = Queries[i][0]   # start row
	        b = Queries[i][1]   # start column
	        c = Queries[i][2]   # end row 
	        d = Queries[i][3]   # end column
	        
	        for j in range(a, c+1):
	            matrix[j][b] += 1
	            if d+1 < n:
	                matrix[j][d+1] -= 1
	    
	    for i in range(n):
	        for j in range(1, n):
	            matrix[i][j] += matrix[i][j-1]
	    return matrix

--

###############################################################################################################################

-- The bit game

-- https://practice.geeksforgeeks.org/problems/the-bit-game2313/1
-- https://www.youtube.com/watch?v=TB17AxGvAIA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=6

--
class Solution:
    def swapBitGame (self,N):
        # code here 
        # count the number of set bits first => and if the number is odd then player 1 won else player 2 won
        count = 0
        while N > 0:
            count += (N&1)
            N = N>>1
        if count % 2 == 0:
            return 2
        return 1
--

###########################################################################################################################################

-- Geek and number

-- https://practice.geeksforgeeks.org/problems/904237fa926d79126d42c437802b04287ea9d1c8/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

-- 
class Solution:
    def minLength(self, s, n):
        
        def expected(num):
            if num == '0':
                return '9'
            if num == '9':
                return '0'
            if int(num) % 2 == 0:
                return str(int(num) - 1)
            return str(int(num) + 1)
        stack = []
        for i in range(n):
            if len(stack) == 0:
                stack.append(s[i])
            elif stack[-1] == expected(s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return len(stack)
--

############################################################################################################################################

-- Tom and jerry 

-- https://practice.geeksforgeeks.org/problems/tom-and-jerry1325/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

--
class Solution:
    def numsGame(self, N):
        # code here
        # we cannot subtract the number with itself
        # for n = 1 => tom loses
        # for n = 2 => tom wins
        # for n = 3 => tom loses
        # for n = 4 => tom wins
        # 
        if N % 2 == 0:
            return 1
        else:
            return 0
--

########################################################################################################################################################

-- ipl 2021 same as => (Longest valid parenthesis) => stack problem

-- https://practice.geeksforgeeks.org/problems/3b47f0ad00f953dd514235ddec54e39fdc297dda/1
-- https://www.youtube.com/watch?v=G53_EUjUYcQ


--
class Solution:
    def findMaxLen(ob, S):
        stack = [-1]
        maximum = 0
        
        for i in range(len(S)):
            if S[i] == '(':
                stack.append(i)
            else:
                if len(stack) > 0:
                    stack.pop()
                    
                if len(stack) > 0:
                    maximum = max(maximum, abs(stack[-1]-i))
                else:
                    stack.append(i)
        return maximum  
--

########################################################################################################################################################


-- Smallest subset with greater sum

-- https://www.youtube.com/watch?v=x3xCSsCsc_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13
-- https://practice.geeksforgeeks.org/problems/smallest-subset-with-greater-sum/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
class Solution:
    def minSubset(self, A, N):
        maximumSum = 0
        for i in range(N):
            maximumSum += A[i]
        A.sort()
        res = 0
        for i in range(N):
            res += A[i] 
            maximumSum -= A[i] 
            if res>maximumSum:
                return i+1
        return N
--

########################################################################################################################################################


-- Maximum number of 2x2 sqaures

-- https://www.youtube.com/watch?v=7WrjdY08BSM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=12
-- https://practice.geeksforgeeks.org/problems/maximum-number-of-22-squares/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--

--


##################################################################################################################################################################

-- Smallest number on the left (nearest smaller to left) => using stack

--  https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1
-- youtube.com/watch?v=YRnI-HDQBSU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13

--
class Solution:
    def leftSmaller(self, n, a):
        stack = []
        ans = []
        for i in range(n):
            while stack and stack[-1] >= a[i]:
                stack.pop()
            if not stack:
                ans.append(-1)
            else:
                ans.append(stack[-1])
            stack.append(a[i])
        return ans
--

#################################################################################################################################################################


-- Composite and prime 

-- https://www.youtube.com/watch?v=vMu0chFRG7o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=14
-- https://practice.geeksforgeeks.org/problems/composite-and-prime0359/1

--
import math
class Solution:
	def Count(self, L, R):
		p = [True for _ in range(R+1)]
		p[0] = False
		p[1] = False
		for i in range(2, int(math.sqrt(R)) + 1):
		    if p[i] == False: continue
		    for j in range(i*i, R+1, i):
		        p[j] = False
		    
		prime = 0
		composite = 0
		for i in range(L, R+1):
		    if i == 1: continue
		    if p[i] == True: prime += 1
		    else:
		        composite+= 1
	    return composite - prime
--

##################################################################################################################################################################

-- Number of ways to arrive at destination

-- https://www.youtube.com/watch?v=EQ4sX6mxDsk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=15
-- https://practice.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1
-- https://www.youtube.com/watch?v=_-0mx0SmYxA


-- Incomplete solution
from collections import deque, defaultdict
from typing import List
from collections import defaultdict
import sys
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Dijkstra algo
        mod = 1e9+7
        ans = 0
        nw = 0
        graph = defaultdict(list)
        dis = [float('inf') for _ in range(n)]
        for s, d, w in roads:
            graph[s].append((d, w))
            graph[d].append((s, w))
        
        s = set([0])
        dis[0] = 0
        res = []
        while s:
            cur = s.pop()
            for node, weight in graph[cur]:
                nw = dis[cur] + weight
                if dis[cur] + weight < dis[node]:
                    dis[node] = dis[cur] + weight
                    if node == n - 1:
                        if dis[node] == nw:
                            ans = (ans + 1)%mod
                    s.add(node)
        return ans
--

#############################################################################################################################################################################

-- Minimum swaps (sheeps problem)

-- youtube.com/watch?v=6uSxQKVSP3o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=16
-- https://practice.geeksforgeeks.org/problems/minimum-swaps-1649134975/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- 
from typing import List
class Solution:
    def minimumSwaps(self,c : List[int], v : List[int],n : int,k : int,b : int, t : int) -> int:
        ans = 0
        ts = 0
        r = 0
        
        for i in range(n - 1, -1, -1):
            if r >= k:
                break
            d = v[i] * t
            if d >= (b - c[i]):
                ans += ts
                r += 1
            else:
                ts += 1
            
        if r >= k:
            return ans
        return -1
--

###################################################################################################################################################################################

-- Minimum swaps to sort 


-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://practice.geeksforgeeks.org/problems/minimum-swaps/1
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/


--
class Solution:
    
    #Function to find the minimum number of swaps required to sort the array.
	def minSwaps(self, nums):
		n = len(nums)
		for i in range(n):
		    nums[i] = [nums[i], i]
		nums.sort(key = lambda x: x[0])
		i = 0
		swap = 0
		while i < n:
		    element, index = nums[i] 
		    if index != i:
		        swap += 1
		        nums[i], nums[index] = nums[index], nums[i]
		    else:
		        i += 1
        return swap
--


###################################################################################################################################################################################

-- Convert Bst to min heap

-- https://www.youtube.com/watch?v=Y9Pu7nHpeFc
-- 

steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Preorder traversal on bst array and change the values of the trees

--

--
############################################################################################################################################################################


-- Convert Bst to max heap

-- https://www.youtube.com/watch?v=zWYmcwFWp1M&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=18
-- https://www.geeksforgeeks.org/convert-bst-to-max-heap/
-- https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1


steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Postorder traversal on bst array and change the values of the tree

--
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        
'''

class Solution:
    def convertToMaxHeapUtil(self, root):
        arr = []
        def inorder(node):
            if not node:
                return None
            inorder(node.left)
            arr.append(node.data)
            inorder(node.right)
        
        def postOrder(node):
            if not node:
                return None
                
            postOrder(node.left)
            postOrder(node.right)
            node.data = arr.pop()
        
        inorder(root)
        arr.reverse()
        postOrder(root)
        return root
--


########################################################################################################################################################################

-- Minimum exchange

-- https://www.youtube.com/watch?v=nXpmRnaZqdE&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=19
-- https://practice.geeksforgeeks.org/problems/distributing-question-papers2513/1


--
class Solution:
	def MinimumExchange(self, matrix): 
	    n = len(matrix)
	    m = len(matrix[0])
	    c1 = 0
	    c2 = 0
	    for i in range(n):
	        for j in range(m):
	            element = matrix[i][j]
	            if (i + j) % 2 == 0:
	                if element == 'B':
	                    c1 += 1
	                if element == 'A':
	                    c2 += 1
	            else:
	                if element == 'B':
	                    c2 += 1
	                if element == 'A':
	                    c1 += 1
        return min(c1, c2)
--


#####################################################################################################################################################################

-- Ball coloring 

-- https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
-- https://practice.geeksforgeeks.org/problems/ball-coloring3450/1

--
class Solution:
    def noOfWays (self, n):
        # for n balls 2 + n(n - 1) ways
        # https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
        # for 0 touching => 2 ways
        # for 1 touching => ((n - 1) x 2) ways
        # for 2 tocuhing => (n - 1)(n - 2) ways
        # so total will be 2 + (n - 1) x 2 + (n - 1)(n - 2)
        
        return 2 + n * (n - 1)
-- 


#####################################################################################################################################################################

-- Count occurrences of a given word in a 2-d array

-- https://practice.geeksforgeeks.org/problems/count-occurences-of-a-given-word-in-a-2-d-array/1
-- https://www.youtube.com/watch?v=eCMiY-BUnOo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=21


--
class Solution:
    def findOccurrence(self,mat,target):
        n = len(mat)
        m = len(mat[0])
        queue = []
        def findword(mat, target, i, j, currentindex):
            if i < 0 or j < 0 or i >= n or j >= m:
                return 0
            curchar = mat[i][j]
            if target[currentindex] != curchar:
                return 0
            
            if currentindex == len(target) - 1:
                return 1
            
            mat[i][j] = '\0' # so that it wont repeat or consider the same character again
            
            count = 0
            count += findword(mat, target, i - 1, j, currentindex + 1)
            count += findword(mat, target, i + 1, j, currentindex + 1)
            count += findword(mat, target, i, j - 1, currentindex + 1)
            count += findword(mat, target, i, j + 1, currentindex + 1)
            
            mat[i][j] = curchar
            
            return count
            
        
        for i in range(n):
            for j in range(m):
                if mat[i][j] == target[0]:
                    queue.append((i, j))
                    
        
        cnt = 0            
        for i in range(n):
            for j in range(m):
                cnt += findword(mat, target, i, j, 0)
        return cnt
--

###########################################################################################################################################################################

-- Smallest number with sum of digits as N and divisible by 10 power 'N'

-- https://www.youtube.com/watch?v=B6AAvp_ba5I&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=22
-- https://practice.geeksforgeeks.org/problems/smallest-number-with-sum-of-digits-as-n-and-divisible-by-10n4032/1

--
class Solution:
	def digitsNum(self, N):
		s = ""
		if N % 9 != 0:
		    s = s + str(N % 9)
		
		for i in range(1, (N//9) + 1):
		    s += "9"
		
		for i in range(1, N + 1):
		    s+= "0"
	    return s
--

##############################################################################################################################################################################


-- Sum of k smallest elements in BST

-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/
-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=23


--

--


############################################################################################################################################################################

-- Kth smallest element in bst

-- https://practice.geeksforgeeks.org/problems/find-k-th-smallest-element-in-bst/1
-- https://leetcode.com/problems/kth-smallest-element-in-a-bst/

--
class Solution:
    # Return the Kth smallest element in the given BST 
    def KthSmallestElement(self, root, k): 
        #code here.
        count = 0
        ans = -1

        def sol(node, k):
            nonlocal count, ans
            if node is None:
                return
            sol(node.left, k)
            count += 1

            if count == k:
                ans = node.data
            sol(node.right, k)

        sol(root, k)
        return ans 
--

###############################################################################################################################################################################

-- Sum of k smallest elements in bst => O(k) complexity

-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/sum-of-k-smallest-elements-in-bst3029/1
-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/

--
# Node Class:
class Node:
    def __init__(self,val):
        self.key = val
        self.left = None
        self.right = None
'''

def summ(root, k):
    # code here
    count = 0
    ans = 0
    def sol(node, k):
        nonlocal count, ans
        if node is None:
            return 
        
        sol(node.left, k)
        
        count += 1
        if count <= k:
            ans += node.key
            
        else: return 
        
        sol(node.right, k)
        
    sol(root, k)
    return ans
--

##############################################################################################################################################################################


-- Stack permutations

-- https://www.youtube.com/watch?v=q4CbTMLogyk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=24
-- https://practice.geeksforgeeks.org/problems/stack-permutations/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
from typing import List
class Solution:
    def isStackPermutation(self, N : int, A : List[int], B : List[int]) -> int:
        # code here
        stack = []
        j = 0
        for i in range(N):
            stack.append(A[i])
            
            while len(stack) > 0 and stack[-1] == B[j]:
                stack.pop()
                j += 1
            
        if j == N and not stack:
            return 1
        return 0
-- 

###########################################################################################################################################################################

-- Minimum sum of absolute differences of pairs

-- https://www.youtube.com/watch?v=RZYkEj0iX3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/minimum-sum-of-absolute-differences-of-pairs/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def findMinSum(self, A,B,N):
        A.sort()
        B.sort()
        sum = 0
        for i in range(N):
            sum += abs(A[i] - B[i])
        return sum
--

####################################################################################################################################################################################################

-- Smallest sum contiguous subarray

-- https://www.youtube.com/watch?v=XTRFIfu2OUw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=26
-- https://practice.geeksforgeeks.org/problems/smallest-sum-contiguous-subarray/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def smallestSumSubarray(self, A, N):
        #Your code here
        minimum = float("inf")
        su = 0
        for i in range(N):
            su += A[i]
            if minimum > su:
                minimum = su
            if su > 0:
                su = 0
        
        return minimum
--

###################################################################################################################################################################################################################

-- Print the pattern 


-- https://www.geeksforgeeks.org/program-print-pattern-gfg/
-- https://www.youtube.com/watch?v=JttvX2HH7M0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=27

--
--


#########################################################################################################################################################################################################
