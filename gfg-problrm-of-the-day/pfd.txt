-- Min cost of ropes
-- https://www.youtube.com/watch?v=cL_IRO8Yzeo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=4
-- https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1

--
import heapq
class Solution:
    #Function to return the minimum cost of connecting the ropes.
    def minCost(self,arr,n) :
    
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            firstMinimumRope = heapq.heappop(arr)
            secondMinimumRope = heapq.heappop(arr)
            
            res += firstMinimumRope + secondMinimumRope
            heapq.heappush(arr, firstMinimumRope + secondMinimumRope)
            
        return res
--

################################################################################################################

-- Queries of matrix
-- https://www.youtube.com/watch?v=G2OBYDINXLU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=5
-- https://practice.geeksforgeeks.org/problems/queries-on-a-matrix0443/1

--
	def solveQueries(self, n, Queries):
	    matrix = [[0 for _ in range(n)] for _ in range(n)]
	    
	    for i in range(len(Queries)):
	        a = Queries[i][0]   # start row
	        b = Queries[i][1]   # start column
	        c = Queries[i][2]   # end row 
	        d = Queries[i][3]   # end column
	        
	        for j in range(a, c+1):
	            matrix[j][b] += 1
	            if d+1 < n:
	                matrix[j][d+1] -= 1
	    
	    for i in range(n):
	        for j in range(1, n):
	            matrix[i][j] += matrix[i][j-1]
	    return matrix

--

###############################################################################################################################

-- The bit game

-- https://practice.geeksforgeeks.org/problems/the-bit-game2313/1
-- https://www.youtube.com/watch?v=TB17AxGvAIA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=6

--
class Solution:
    def swapBitGame (self,N):
        # code here 
        # count the number of set bits first => and if the number is odd then player 1 won else player 2 won
        count = 0
        while N > 0:
            count += (N&1)
            N = N>>1
        if count % 2 == 0:
            return 2
        return 1
--

###########################################################################################################################################

-- Geek and number

-- https://practice.geeksforgeeks.org/problems/904237fa926d79126d42c437802b04287ea9d1c8/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

-- 
class Solution:
    def minLength(self, s, n):
        
        def expected(num):
            if num == '0':
                return '9'
            if num == '9':
                return '0'
            if int(num) % 2 == 0:
                return str(int(num) - 1)
            return str(int(num) + 1)
        stack = []
        for i in range(n):
            if len(stack) == 0:
                stack.append(s[i])
            elif stack[-1] == expected(s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return len(stack)
--

############################################################################################################################################

-- Tom and jerry 

-- https://practice.geeksforgeeks.org/problems/tom-and-jerry1325/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

--
class Solution:
    def numsGame(self, N):
        # code here
        # we cannot subtract the number with itself
        # for n = 1 => tom loses
        # for n = 2 => tom wins
        # for n = 3 => tom loses
        # for n = 4 => tom wins
        # 
        if N % 2 == 0:
            return 1
        else:
            return 0
--

########################################################################################################################################################

-- ipl 2021 same as => (Longest valid parenthesis) => stack problem

-- https://practice.geeksforgeeks.org/problems/3b47f0ad00f953dd514235ddec54e39fdc297dda/1
-- https://www.youtube.com/watch?v=G53_EUjUYcQ


--
class Solution:
    def findMaxLen(ob, S):
        stack = [-1]
        maximum = 0
        
        for i in range(len(S)):
            if S[i] == '(':
                stack.append(i)
            else:
                if len(stack) > 0:
                    stack.pop()
                    
                if len(stack) > 0:
                    maximum = max(maximum, abs(stack[-1]-i))
                else:
                    stack.append(i)
        return maximum  
--

########################################################################################################################################################


-- Smallest subset with greater sum

-- https://www.youtube.com/watch?v=x3xCSsCsc_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13
-- https://practice.geeksforgeeks.org/problems/smallest-subset-with-greater-sum/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
class Solution:
    def minSubset(self, A, N):
        maximumSum = 0
        for i in range(N):
            maximumSum += A[i]
        A.sort()
        res = 0
        for i in range(N):
            res += A[i] 
            maximumSum -= A[i] 
            if res>maximumSum:
                return i+1
        return N
--

########################################################################################################################################################


-- Maximum number of 2x2 sqaures

-- https://www.youtube.com/watch?v=7WrjdY08BSM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=12
-- https://practice.geeksforgeeks.org/problems/maximum-number-of-22-squares/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--

--


##################################################################################################################################################################

-- Smallest number on the left (nearest smaller to left) => using stack

--  https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1
-- youtube.com/watch?v=YRnI-HDQBSU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13

--
class Solution:
    def leftSmaller(self, n, a):
        stack = []
        ans = []
        for i in range(n):
            while stack and stack[-1] >= a[i]:
                stack.pop()
            if not stack:
                ans.append(-1)
            else:
                ans.append(stack[-1])
            stack.append(a[i])
        return ans
--

#################################################################################################################################################################


-- Composite and prime 

-- https://www.youtube.com/watch?v=vMu0chFRG7o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=14
-- https://practice.geeksforgeeks.org/problems/composite-and-prime0359/1

--
import math
class Solution:
	def Count(self, L, R):
		p = [True for _ in range(R+1)]
		p[0] = False
		p[1] = False
		for i in range(2, int(math.sqrt(R)) + 1):
		    if p[i] == False: continue
		    for j in range(i*i, R+1, i):
		        p[j] = False
		    
		prime = 0
		composite = 0
		for i in range(L, R+1):
		    if i == 1: continue
		    if p[i] == True: prime += 1
		    else:
		        composite+= 1
	    return composite - prime
--

##################################################################################################################################################################

-- Number of ways to arrive at destination

-- https://www.youtube.com/watch?v=EQ4sX6mxDsk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=15
-- https://practice.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1
-- https://www.youtube.com/watch?v=_-0mx0SmYxA


-- Incomplete solution
from collections import deque, defaultdict
from typing import List
from collections import defaultdict
import sys
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Dijkstra algo
        mod = 1e9+7
        ans = 0
        nw = 0
        graph = defaultdict(list)
        dis = [float('inf') for _ in range(n)]
        for s, d, w in roads:
            graph[s].append((d, w))
            graph[d].append((s, w))
        
        s = set([0])
        dis[0] = 0
        res = []
        while s:
            cur = s.pop()
            for node, weight in graph[cur]:
                nw = dis[cur] + weight
                if dis[cur] + weight < dis[node]:
                    dis[node] = dis[cur] + weight
                    if node == n - 1:
                        if dis[node] == nw:
                            ans = (ans + 1)%mod
                    s.add(node)
        return ans
--

#############################################################################################################################################################################

-- Minimum swaps (sheeps problem)

-- youtube.com/watch?v=6uSxQKVSP3o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=16
-- https://practice.geeksforgeeks.org/problems/minimum-swaps-1649134975/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- 
from typing import List
class Solution:
    def minimumSwaps(self,c : List[int], v : List[int],n : int,k : int,b : int, t : int) -> int:
        ans = 0
        ts = 0
        r = 0
        
        for i in range(n - 1, -1, -1):
            if r >= k:
                break
            d = v[i] * t
            if d >= (b - c[i]):
                ans += ts
                r += 1
            else:
                ts += 1
            
        if r >= k:
            return ans
        return -1
--

###################################################################################################################################################################################

-- Minimum swaps to sort 


-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://practice.geeksforgeeks.org/problems/minimum-swaps/1
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/


--
class Solution:
    
    #Function to find the minimum number of swaps required to sort the array.
	def minSwaps(self, nums):
		n = len(nums)
		for i in range(n):
		    nums[i] = [nums[i], i]
		nums.sort(key = lambda x: x[0])
		i = 0
		swap = 0
		while i < n:
		    element, index = nums[i] 
		    if index != i:
		        swap += 1
		        nums[i], nums[index] = nums[index], nums[i]
		    else:
		        i += 1
        return swap
--


###################################################################################################################################################################################

-- Convert Bst to min heap

-- https://www.youtube.com/watch?v=Y9Pu7nHpeFc
-- 

steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Preorder traversal on bst array and change the values of the trees

--

--
############################################################################################################################################################################


-- Convert Bst to max heap

-- https://www.youtube.com/watch?v=zWYmcwFWp1M&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=18
-- https://www.geeksforgeeks.org/convert-bst-to-max-heap/
-- https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1


steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Postorder traversal on bst array and change the values of the tree

--
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        
'''

class Solution:
    def convertToMaxHeapUtil(self, root):
        arr = []
        def inorder(node):
            if not node:
                return None
            inorder(node.left)
            arr.append(node.data)
            inorder(node.right)
        
        def postOrder(node):
            if not node:
                return None
                
            postOrder(node.left)
            postOrder(node.right)
            node.data = arr.pop()
        
        inorder(root)
        arr.reverse()
        postOrder(root)
        return root
--


########################################################################################################################################################################

-- Minimum exchange

-- https://www.youtube.com/watch?v=nXpmRnaZqdE&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=19
-- https://practice.geeksforgeeks.org/problems/distributing-question-papers2513/1


--
class Solution:
	def MinimumExchange(self, matrix): 
	    n = len(matrix)
	    m = len(matrix[0])
	    c1 = 0
	    c2 = 0
	    for i in range(n):
	        for j in range(m):
	            element = matrix[i][j]
	            if (i + j) % 2 == 0:
	                if element == 'B':
	                    c1 += 1
	                if element == 'A':
	                    c2 += 1
	            else:
	                if element == 'B':
	                    c2 += 1
	                if element == 'A':
	                    c1 += 1
        return min(c1, c2)
--


#####################################################################################################################################################################

-- Ball coloring 

-- https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
-- https://practice.geeksforgeeks.org/problems/ball-coloring3450/1

--
class Solution:
    def noOfWays (self, n):
        # for n balls 2 + n(n - 1) ways
        # https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
        # for 0 touching => 2 ways
        # for 1 touching => ((n - 1) x 2) ways
        # for 2 tocuhing => (n - 1)(n - 2) ways
        # so total will be 2 + (n - 1) x 2 + (n - 1)(n - 2)
        
        return 2 + n * (n - 1)
-- 


#####################################################################################################################################################################

-- Count occurrences of a given word in a 2-d array

-- https://practice.geeksforgeeks.org/problems/count-occurences-of-a-given-word-in-a-2-d-array/1
-- https://www.youtube.com/watch?v=eCMiY-BUnOo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=21


--
class Solution:
    def findOccurrence(self,mat,target):
        n = len(mat)
        m = len(mat[0])
        queue = []
        def findword(mat, target, i, j, currentindex):
            if i < 0 or j < 0 or i >= n or j >= m:
                return 0
            curchar = mat[i][j]
            if target[currentindex] != curchar:
                return 0
            
            if currentindex == len(target) - 1:
                return 1
            
            mat[i][j] = '\0' # so that it wont repeat or consider the same character again
            
            count = 0
            count += findword(mat, target, i - 1, j, currentindex + 1)
            count += findword(mat, target, i + 1, j, currentindex + 1)
            count += findword(mat, target, i, j - 1, currentindex + 1)
            count += findword(mat, target, i, j + 1, currentindex + 1)
            
            mat[i][j] = curchar
            
            return count
            
        
        for i in range(n):
            for j in range(m):
                if mat[i][j] == target[0]:
                    queue.append((i, j))
                    
        
        cnt = 0            
        for i in range(n):
            for j in range(m):
                cnt += findword(mat, target, i, j, 0)
        return cnt
--

###########################################################################################################################################################################

-- Smallest number with sum of digits as N and divisible by 10 power 'N'

-- https://www.youtube.com/watch?v=B6AAvp_ba5I&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=22
-- https://practice.geeksforgeeks.org/problems/smallest-number-with-sum-of-digits-as-n-and-divisible-by-10n4032/1

--
class Solution:
	def digitsNum(self, N):
		s = ""
		if N % 9 != 0:
		    s = s + str(N % 9)
		
		for i in range(1, (N//9) + 1):
		    s += "9"
		
		for i in range(1, N + 1):
		    s+= "0"
	    return s
--

##############################################################################################################################################################################


-- Sum of k smallest elements in BST

-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/
-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=23


--

--


############################################################################################################################################################################

-- Kth smallest element in bst

-- https://practice.geeksforgeeks.org/problems/find-k-th-smallest-element-in-bst/1
-- https://leetcode.com/problems/kth-smallest-element-in-a-bst/

--
class Solution:
    # Return the Kth smallest element in the given BST 
    def KthSmallestElement(self, root, k): 
        #code here.
        count = 0
        ans = -1

        def sol(node, k):
            nonlocal count, ans
            if node is None:
                return
            sol(node.left, k)
            count += 1

            if count == k:
                ans = node.data
            sol(node.right, k)

        sol(root, k)
        return ans 
--

###############################################################################################################################################################################

-- Sum of k smallest elements in bst => O(k) complexity

-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/sum-of-k-smallest-elements-in-bst3029/1
-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/

--
# Node Class:
class Node:
    def __init__(self,val):
        self.key = val
        self.left = None
        self.right = None
'''

def summ(root, k):
    # code here
    count = 0
    ans = 0
    def sol(node, k):
        nonlocal count, ans
        if node is None:
            return 
        
        sol(node.left, k)
        
        count += 1
        if count <= k:
            ans += node.key
            
        else: return 
        
        sol(node.right, k)
        
    sol(root, k)
    return ans
--

##############################################################################################################################################################################


-- Stack permutations

-- https://www.youtube.com/watch?v=q4CbTMLogyk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=24
-- https://practice.geeksforgeeks.org/problems/stack-permutations/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
from typing import List
class Solution:
    def isStackPermutation(self, N : int, A : List[int], B : List[int]) -> int:
        # code here
        stack = []
        j = 0
        for i in range(N):
            stack.append(A[i])
            
            while len(stack) > 0 and stack[-1] == B[j]:
                stack.pop()
                j += 1
            
        if j == N and not stack:
            return 1
        return 0
-- 

###########################################################################################################################################################################

-- Minimum sum of absolute differences of pairs

-- https://www.youtube.com/watch?v=RZYkEj0iX3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/minimum-sum-of-absolute-differences-of-pairs/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def findMinSum(self, A,B,N):
        A.sort()
        B.sort()
        sum = 0
        for i in range(N):
            sum += abs(A[i] - B[i])
        return sum
--

####################################################################################################################################################################################################

-- Smallest sum contiguous subarray

-- https://www.youtube.com/watch?v=XTRFIfu2OUw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=26
-- https://practice.geeksforgeeks.org/problems/smallest-sum-contiguous-subarray/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def smallestSumSubarray(self, A, N):
        #Your code here
        minimum = float("inf")
        su = 0
        for i in range(N):
            su += A[i]
            if minimum > su:
                minimum = su
            if su > 0:
                su = 0
        
        return minimum
--

###################################################################################################################################################################################################################

-- Print the pattern 


-- https://www.geeksforgeeks.org/program-print-pattern-gfg/
-- https://www.youtube.com/watch?v=JttvX2HH7M0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=27

--

--


#########################################################################################################################################################################################################

-- Minimum cost to cut a board into squares

-- https://www.youtube.com/watch?v=j9Pxyfp8knU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=28
-- 

##########################################################################################################################################################################################################

-- Minimum time to fulfill all orders (Binary search hard question)
#### Important


-- https://practice.geeksforgeeks.org/problems/minimum-time-to-fulfil-all-orders/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=tfch4QSfRZc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=29


--

--


#####################################################################################################################################################################################################################################

-- Find the pairs with given sum in doubly linked list

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-pairs-with-given-sum-in-doubly-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def findPairsWithGivenSum(self, target : int, head : Optional['Node']) -> List[List[int]]:
        # two pointer method
        # code here
        
        l = head
        r = head
        ans = []
        while r.next != None:
            r = r.next
        #left is at start and right is at the end
        
        # condition also works for both even and odd elements
        while (l != r) and (r.next != l):
            csum = l.data + r.data
            if csum == target:
                ans.append((l.data, r.data))
                l = l.next
                r = r.next
            elif csum < target:
                l = l.next
            else:
                r = r.prev
        return ans
--

####################################################################################################################################################################################################################################

-- Find all distinct subset or subsequence

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-all-distinct-subset-or-subsequence-sums4424/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
	def DistinctSum(self, nums):
	    dp = [[0 for _ in range(10001)] for _ in range(len(nums))]
		# Code here
		s = set()
		def sol(i, arr, s, sum):
		    if i == len(arr):
		        s.add(sum)
		        return 
		    
		    if dp[i][sum]:
		        return
		    
		    sol(i + 1, arr, s, sum)
		    sol(i+ 1, arr, s, sum + arr[i])
		    dp[i][sum] = 1
		    
		sol(0, nums, s, 0)
		return sorted(s)
--

######################################################################################################################################################################################################


-- Merging Details


-- https://practice.geeksforgeeks.org/problems/merging-details/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=8-foSocrEV4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=32


--
--

##########################################################################################################################################################################################

-- Next right node

-- https://www.youtube.com/watch?v=5SPNg4blazc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=33
-- https://practice.geeksforgeeks.org/problems/next-right-node/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
from collections import deque
class Solution:
    def nextRight(self, root, key):
        #code here
        queue = [root]
        ans = Node(-1)
        while queue:
            n = len(queue)
            for i in range(n):
                curr = queue.pop(0)
                if curr.data == key and i != n-1:
                    return queue[0]
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
        return ans
            
--

####################################################################################################################################################################################################

-- Binary tree to DLL

-- https://www.youtube.com/watch?v=wSUCZpA1LKY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=34'
-- https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    head = None
    tail = None
    def bToDLL(self,root):
        if not root: return
        self.bToDLL(root.left)
        if not self.head: 
            self.head = root
        else:
            root.left = self.tail
            self.tail.right = root
        self.tail = root
        self.bToDLL(root.right)
        return self.head
--

#####################################################################################################################################################################################################

-- Alternate positive and negative numbers

-- https://www.youtube.com/watch?v=ntt_6CCXDqI&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=35
-- 


--
class Solution:
    def rearrange(self,arr, n):
        # code here
        pos = []
        neg = []
        ans = []
        for i in range(n):
            if arr[i] > 0:
                pos.append(arr[i])
            elif arr[i] < 0:
                neg.append(arr[i])
        
        
        i, j, k, = 0, 0, 0
        while i < len(pos) or j < len(neg):
            if pos[i]:
                ans.append(pos[i])
                i+= 1
            if neg[j]:
                ans.append(neg[j])
                j += 1
        return ans
--

###################################################################################################################################################################################################

-- Count palindromic sequence

-- https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
    def countPS(self,string):
        n = len(string)
        dp = [[-1 for _ in range(n+1)] for _ in range(n+1)]
        
        def sol(i, j, string, dp):
            mod = 1e9+7
            if i == j:
                return 1
            if i > j:
                return 0
            
            if dp[i][j] != -1:
                return dp[i][j]
            
            if string[i] == string[j]:
                dp[i][j] = (1 + sol(i+1, j, string, dp) + sol(i, j-1, string, dp))%mod
            else:
                dp[i][j] = ((sol(i+1, j, string, dp) + sol(i, j - 1, string, dp) - sol(i+1, j-1, string, dp))%mod + mod)%mod
            return dp[i][j]
        
        return int(sol(0, len(string)-1, string, dp))
--



#####################################################################################################################################################################################################

-- Counting elements in two arrays


-- https://practice.geeksforgeeks.org/problems/counting-elements-in-two-arrays/1
-- https://www.youtube.com/watch?v=uLyFwNUCfmw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=37


--
class Solution:
    def countEleLessThanOrEqual(self,arr1,n1,arr2,n2):
        #returns the required output
        res = []
        arr2.sort()
        def binary(target, n2):
            low = 0
            high = n2 - 1
            ans = 0
            while (low<=high):
                mid = low + ((high - low)//2)
                if arr2[mid] > target:
                    ans = mid
                    high = mid - 1
                else:
                    if mid + 1 >= n2:
                        ans = mid + 1
                    low = mid + 1
            return ans
        
        for i in range(n1):
            index = binary(arr1[i], n2)
            res.append(index)
        return res
--

####################################################################################################################################################################################


-- Generate IP address (recursion and backtracking)

-- https://www.youtube.com/watch?v=XU4inpwKt8A&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40
-- https://practice.geeksforgeeks.org/problems/generate-ip-addresses/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=61tN4YEdiTM


--
class Solution:
    def genIp(self, s):
        res = []
        if len(s) > 12:
            return ['-1']

        def sol(i, curStr, dots):
            if dots == 4 and i == len(s):
                res.append(curStr[:-1])
            
            if dots > 4:
                return

            for j in range(i, min(len(s), i+3)):
                if int(s[i: j+1]) < 256 and (i == j or s[i] != "0"):
                    sol(j+1, curStr + s[i: j+1] + '.', dots + 1)
            
        sol(0, '', 0)
        return res
        
        
        
    def valid(self,char):
        if len(char)==0 or len(char)>3 or (char[0]=='0' and len(char)>1) or  int(char)>255:
            return False
        else:
            return True

    def genIp2(self, s):
        n=len(s)
        if len(s)>12:return ['-1']
        ans=[]
        for i in range(1,n-2):
            for j in range(i+1,n-1):
                for k in range(j+1,n):
                    a=s[0:i]
                    b=s[i:j]
                    c=s[j:k]
                    d=s[k:n]
                    if self.valid(a) and self.valid(b) and self.valid(c) and self.valid(d):
                        ans.append(a+"."+b+"."+c+"."+d)
        return ans
--

######################################################################################################################################################

-- foldable tree (Similar to mirror of the tree)

-- https://practice.geeksforgeeks.org/problems/foldable-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=C87kVZOq9Sg&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=39

--
def IsFoldable(root):
    if not root:
        return True
        
    def sol(left, right):
        if not left and not right:
            return 1
        if not left or not right:
            return 0
        return (sol(left.right, right.left) and sol(left.left, right.right))
    
    if sol(root.left, root.right):
        return True
    return False
--


###########################################################################################################################################################

-- Immediate Smaller element

-- https://www.youtube.com/watch?v=75LH0gHa4dQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40 
-- https://practice.geeksforgeeks.org/problems/immediate-smaller-element1142/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
	def immediateSmaller(self,arr,n):
		for i in range(n - 1):
		    if arr[i] > arr[i + 1]:
		        arr[i] = arr[i + 1]
		    else:
		        arr[i] = -1
		arr[n - 1] = -1
		return arr
--


##########################################################################################################################################################

-- Game with nos

-- https://www.youtube.com/watch?v=q5jY1AeOs3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=41
-- 

--
Very easy code
--

#######################################################################################################################################################################

-- Sum of two large numbers

-- https://practice.geeksforgeeks.org/problems/sum-of-numbers-or-number1219/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=-ibOwx3dfaQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44

--
class Solution:
	def findSum(self, X, Y):
		x = X[::-1]
		y = Y[::-1]
		carry = 0
		if len(y) > len(x):
		    x, y = y, x
		    
		i = 0
		j = 0
		ans = ''
		while i<len(x) and j < len(y):
		    carry += int(x[i]) + int(y[j])
		    ans += str(carry%10)
		    carry = carry / 10
		    i += 1
		    j += 1
        while i < len(x):
            carry += int(x[i])
		    ans += str(carry%10)
		    carry = carry / 10
		    i+=1
	    
	    while carry:
	        ans += str(carry%10)
	        carry = carry / 10
	   
	    return ans[::-1]
--

############################################################################################################################################################################

-- Unit area of largest region of 1s (Similar to region in binary matrix)

-- https://www.youtube.com/watch?v=2fI49mrEYmM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=43
-- https://practice.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:

    #Function to find unit area of the largest region of 1s.
	def findMaxArea(self, grid):
		n = len(grid)
		m = len(grid[0])
		ans = 0
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 1:
		            count = self.count(i, j, grid, n, m)
		            ans = max(count, ans)
	    return ans
    
    def count(self, row, col, A, n, m):
        if any([row < 0, col < 0, row >= n, col >= m]):
            return 0
        if A[row][col] == 0:
            return 0
        count = 1
        
        A[row][col] = 0 # so that it wont repeat on loop
        
        for r in range(row - 1, row + 2):
            for c in range(col - 1, col + 2):
                count += self.count(r, c, A, n, m)
        
        return count
--



#########################################################################################################################################################################

-- Longest subarray with sum k 

-- https://www.youtube.com/watch?v=yDeNqw_dAU0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44
-- https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
--


-- method 2 ( does not work for negative values)

def max_length(s, k):
    current = []
    max_len = -1 # returns -1 if there is no subsequence that adds up to k.
    for i in s:
        current.append(i)
        while sum(current) > k: # Shrink the array from the left, until the sum is <= k.
           current = current[1:]
        if sum(current) == k:
            max_len = max(max_len, len(current))

    return max_len
--



##################################################################################################################################################################

-- Number of turns in binary tree

--

--
--

##############################################################################################################################################################################

 
-- Max length chain

-- 


--
--

####################################################################################################################################################################################

-- Case Specific sorting of strings 