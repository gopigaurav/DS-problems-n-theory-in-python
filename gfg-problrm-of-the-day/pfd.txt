-- Min cost of ropes
-- https://www.youtube.com/watch?v=cL_IRO8Yzeo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=4
-- https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1

--
import heapq
class Solution:
    #Function to return the minimum cost of connecting the ropes.
    def minCost(self,arr,n) :
    
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            firstMinimumRope = heapq.heappop(arr)
            secondMinimumRope = heapq.heappop(arr)
            
            res += firstMinimumRope + secondMinimumRope
            heapq.heappush(arr, firstMinimumRope + secondMinimumRope)
            
        return res
--

################################################################################################################

-- Queries of matrix
-- https://www.youtube.com/watch?v=G2OBYDINXLU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=5
-- https://practice.geeksforgeeks.org/problems/queries-on-a-matrix0443/1

--
	def solveQueries(self, n, Queries):
	    matrix = [[0 for _ in range(n)] for _ in range(n)]
	    
	    for i in range(len(Queries)):
	        a = Queries[i][0]   # start row
	        b = Queries[i][1]   # start column
	        c = Queries[i][2]   # end row 
	        d = Queries[i][3]   # end column
	        
	        for j in range(a, c+1):
	            matrix[j][b] += 1
	            if d+1 < n:
	                matrix[j][d+1] -= 1
	    
	    for i in range(n):
	        for j in range(1, n):
	            matrix[i][j] += matrix[i][j-1]
	    return matrix

--

###############################################################################################################################

-- The bit game

-- https://practice.geeksforgeeks.org/problems/the-bit-game2313/1
-- https://www.youtube.com/watch?v=TB17AxGvAIA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=6

--
class Solution:
    def swapBitGame (self,N):
        # code here 
        # count the number of set bits first => and if the number is odd then player 1 won else player 2 won
        count = 0
        while N > 0:
            count += (N&1)
            N = N>>1
        if count % 2 == 0:
            return 2
        return 1
--

###########################################################################################################################################

-- Geek and number

-- https://practice.geeksforgeeks.org/problems/904237fa926d79126d42c437802b04287ea9d1c8/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

-- 
class Solution:
    def minLength(self, s, n):
        
        def expected(num):
            if num == '0':
                return '9'
            if num == '9':
                return '0'
            if int(num) % 2 == 0:
                return str(int(num) - 1)
            return str(int(num) + 1)
        stack = []
        for i in range(n):
            if len(stack) == 0:
                stack.append(s[i])
            elif stack[-1] == expected(s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return len(stack)
--

############################################################################################################################################

-- Tom and jerry 

-- https://practice.geeksforgeeks.org/problems/tom-and-jerry1325/1
-- https://www.youtube.com/watch?v=8bw38nAZITo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=8

--
class Solution:
    def numsGame(self, N):
        # code here
        # we cannot subtract the number with itself
        # for n = 1 => tom loses
        # for n = 2 => tom wins
        # for n = 3 => tom loses
        # for n = 4 => tom wins
        # 
        if N % 2 == 0:
            return 1
        else:
            return 0
--

########################################################################################################################################################

-- ipl 2021 same as => (Longest valid parenthesis) => stack problem

-- https://practice.geeksforgeeks.org/problems/3b47f0ad00f953dd514235ddec54e39fdc297dda/1
-- https://www.youtube.com/watch?v=G53_EUjUYcQ


--
class Solution:
    def findMaxLen(ob, S):
        stack = [-1]
        maximum = 0
        
        for i in range(len(S)):
            if S[i] == '(':
                stack.append(i)
            else:
                if len(stack) > 0:
                    stack.pop()
                    
                if len(stack) > 0:
                    maximum = max(maximum, abs(stack[-1]-i))
                else:
                    stack.append(i)
        return maximum  
--

########################################################################################################################################################


-- Smallest subset with greater sum

-- https://www.youtube.com/watch?v=x3xCSsCsc_g&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13
-- https://practice.geeksforgeeks.org/problems/smallest-subset-with-greater-sum/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
class Solution:
    def minSubset(self, A, N):
        maximumSum = 0
        for i in range(N):
            maximumSum += A[i]
        A.sort()
        res = 0
        for i in range(N):
            res += A[i] 
            maximumSum -= A[i] 
            if res>maximumSum:
                return i+1
        return N
--

########################################################################################################################################################


-- Maximum number of 2x2 sqaures

-- https://www.youtube.com/watch?v=7WrjdY08BSM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=12
-- https://practice.geeksforgeeks.org/problems/maximum-number-of-22-squares/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--

--


##################################################################################################################################################################

-- Smallest number on the left (nearest smaller to left) => using stack

--  https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1
-- youtube.com/watch?v=YRnI-HDQBSU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=13

--
class Solution:
    def leftSmaller(self, n, a):
        stack = []
        ans = []
        for i in range(n):
            while stack and stack[-1] >= a[i]:
                stack.pop()
            if not stack:
                ans.append(-1)
            else:
                ans.append(stack[-1])
            stack.append(a[i])
        return ans
--

#################################################################################################################################################################


-- Composite and prime 

-- https://www.youtube.com/watch?v=vMu0chFRG7o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=14
-- https://practice.geeksforgeeks.org/problems/composite-and-prime0359/1

--
import math
class Solution:
	def Count(self, L, R):
		p = [True for _ in range(R+1)]
		p[0] = False
		p[1] = False
		for i in range(2, int(math.sqrt(R)) + 1):
		    if p[i] == False: continue
		    for j in range(i*i, R+1, i):
		        p[j] = False
		    
		prime = 0
		composite = 0
		for i in range(L, R+1):
		    if i == 1: continue
		    if p[i] == True: prime += 1
		    else:
		        composite+= 1
	    return composite - prime
--

##################################################################################################################################################################

-- Number of ways to arrive at destination

-- https://www.youtube.com/watch?v=EQ4sX6mxDsk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=15
-- https://practice.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1
-- https://www.youtube.com/watch?v=_-0mx0SmYxA


-- Incomplete solution
from collections import deque, defaultdict
from typing import List
from collections import defaultdict
import sys
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        # Dijkstra algo
        mod = 1e9+7
        ans = 0
        nw = 0
        graph = defaultdict(list)
        dis = [float('inf') for _ in range(n)]
        for s, d, w in roads:
            graph[s].append((d, w))
            graph[d].append((s, w))
        
        s = set([0])
        dis[0] = 0
        res = []
        while s:
            cur = s.pop()
            for node, weight in graph[cur]:
                nw = dis[cur] + weight
                if dis[cur] + weight < dis[node]:
                    dis[node] = dis[cur] + weight
                    if node == n - 1:
                        if dis[node] == nw:
                            ans = (ans + 1)%mod
                    s.add(node)
        return ans
--

#############################################################################################################################################################################

-- Minimum swaps (sheeps problem)

-- youtube.com/watch?v=6uSxQKVSP3o&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=16
-- https://practice.geeksforgeeks.org/problems/minimum-swaps-1649134975/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- 
from typing import List
class Solution:
    def minimumSwaps(self,c : List[int], v : List[int],n : int,k : int,b : int, t : int) -> int:
        ans = 0
        ts = 0
        r = 0
        
        for i in range(n - 1, -1, -1):
            if r >= k:
                break
            d = v[i] * t
            if d >= (b - c[i]):
                ans += ts
                r += 1
            else:
                ts += 1
            
        if r >= k:
            return ans
        return -1
--

###################################################################################################################################################################################

-- Minimum swaps to sort 


-- https://www.youtube.com/watch?v=kFe_LRWuZjE
-- https://practice.geeksforgeeks.org/problems/minimum-swaps/1
-- https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/


--
class Solution:
    
    #Function to find the minimum number of swaps required to sort the array.
	def minSwaps(self, nums):
		n = len(nums)
		for i in range(n):
		    nums[i] = [nums[i], i]
		nums.sort(key = lambda x: x[0])
		i = 0
		swap = 0
		while i < n:
		    element, index = nums[i] 
		    if index != i:
		        swap += 1
		        nums[i], nums[index] = nums[index], nums[i]
		    else:
		        i += 1
        return swap
--


###################################################################################################################################################################################

-- Convert Bst to min heap

-- https://www.youtube.com/watch?v=Y9Pu7nHpeFc
-- 

steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Preorder traversal on bst array and change the values of the trees

--

--
############################################################################################################################################################################


-- Convert Bst to max heap

-- https://www.youtube.com/watch?v=zWYmcwFWp1M&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=18
-- https://www.geeksforgeeks.org/convert-bst-to-max-heap/
-- https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1


steps:
=> Perform inorder traversal and store all the values in an array
=> Perform Postorder traversal on bst array and change the values of the tree

--
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        
'''

class Solution:
    def convertToMaxHeapUtil(self, root):
        arr = []
        def inorder(node):
            if not node:
                return None
            inorder(node.left)
            arr.append(node.data)
            inorder(node.right)
        
        def postOrder(node):
            if not node:
                return None
                
            postOrder(node.left)
            postOrder(node.right)
            node.data = arr.pop()
        
        inorder(root)
        arr.reverse()
        postOrder(root)
        return root
--


########################################################################################################################################################################

-- Minimum exchange

-- https://www.youtube.com/watch?v=nXpmRnaZqdE&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=19
-- https://practice.geeksforgeeks.org/problems/distributing-question-papers2513/1


--
class Solution:
	def MinimumExchange(self, matrix): 
	    n = len(matrix)
	    m = len(matrix[0])
	    c1 = 0
	    c2 = 0
	    for i in range(n):
	        for j in range(m):
	            element = matrix[i][j]
	            if (i + j) % 2 == 0:
	                if element == 'B':
	                    c1 += 1
	                if element == 'A':
	                    c2 += 1
	            else:
	                if element == 'B':
	                    c2 += 1
	                if element == 'A':
	                    c1 += 1
        return min(c1, c2)
--


#####################################################################################################################################################################

-- Ball coloring 

-- https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
-- https://practice.geeksforgeeks.org/problems/ball-coloring3450/1

--
class Solution:
    def noOfWays (self, n):
        # for n balls 2 + n(n - 1) ways
        # https://www.youtube.com/watch?v=kpDZ5JOXCO4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=20
        # for 0 touching => 2 ways
        # for 1 touching => ((n - 1) x 2) ways
        # for 2 tocuhing => (n - 1)(n - 2) ways
        # so total will be 2 + (n - 1) x 2 + (n - 1)(n - 2)
        
        return 2 + n * (n - 1)
-- 


#####################################################################################################################################################################

-- Count occurrences of a given word in a 2-d array

-- https://practice.geeksforgeeks.org/problems/count-occurences-of-a-given-word-in-a-2-d-array/1
-- https://www.youtube.com/watch?v=eCMiY-BUnOo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=21


--
class Solution:
    def findOccurrence(self,mat,target):
        n = len(mat)
        m = len(mat[0])
        queue = []
        def findword(mat, target, i, j, currentindex):
            if i < 0 or j < 0 or i >= n or j >= m:
                return 0
            curchar = mat[i][j]
            if target[currentindex] != curchar:
                return 0
            
            if currentindex == len(target) - 1:
                return 1
            
            mat[i][j] = '\0' # so that it wont repeat or consider the same character again
            
            count = 0
            count += findword(mat, target, i - 1, j, currentindex + 1)
            count += findword(mat, target, i + 1, j, currentindex + 1)
            count += findword(mat, target, i, j - 1, currentindex + 1)
            count += findword(mat, target, i, j + 1, currentindex + 1)
            
            mat[i][j] = curchar
            
            return count
            
        
        for i in range(n):
            for j in range(m):
                if mat[i][j] == target[0]:
                    queue.append((i, j))
                    
        
        cnt = 0            
        for i in range(n):
            for j in range(m):
                cnt += findword(mat, target, i, j, 0)
        return cnt
--

###########################################################################################################################################################################

-- Smallest number with sum of digits as N and divisible by 10 power 'N'

-- https://www.youtube.com/watch?v=B6AAvp_ba5I&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=22
-- https://practice.geeksforgeeks.org/problems/smallest-number-with-sum-of-digits-as-n-and-divisible-by-10n4032/1

--
class Solution:
	def digitsNum(self, N):
		s = ""
		if N % 9 != 0:
		    s = s + str(N % 9)
		
		for i in range(1, (N//9) + 1):
		    s += "9"
		
		for i in range(1, N + 1):
		    s+= "0"
	    return s
--

##############################################################################################################################################################################


-- Sum of k smallest elements in BST

-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/
-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=23


--

--


############################################################################################################################################################################

-- Kth smallest element in bst

-- https://practice.geeksforgeeks.org/problems/find-k-th-smallest-element-in-bst/1
-- https://leetcode.com/problems/kth-smallest-element-in-a-bst/

--
class Solution:
    # Return the Kth smallest element in the given BST 
    def KthSmallestElement(self, root, k): 
        #code here.
        count = 0
        ans = -1

        def sol(node, k):
            nonlocal count, ans
            if node is None:
                return
            sol(node.left, k)
            count += 1

            if count == k:
                ans = node.data
            sol(node.right, k)

        sol(root, k)
        return ans 
--

###############################################################################################################################################################################

-- Sum of k smallest elements in bst => O(k) complexity

-- https://www.youtube.com/watch?v=e48rTjOSvyA&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/sum-of-k-smallest-elements-in-bst3029/1
-- https://www.geeksforgeeks.org/sum-k-smallest-elements-bst/

--
# Node Class:
class Node:
    def __init__(self,val):
        self.key = val
        self.left = None
        self.right = None
'''

def summ(root, k):
    # code here
    count = 0
    ans = 0
    def sol(node, k):
        nonlocal count, ans
        if node is None:
            return 
        
        sol(node.left, k)
        
        count += 1
        if count <= k:
            ans += node.key
            
        else: return 
        
        sol(node.right, k)
        
    sol(root, k)
    return ans
--

##############################################################################################################################################################################


-- Stack permutations

-- https://www.youtube.com/watch?v=q4CbTMLogyk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=24
-- https://practice.geeksforgeeks.org/problems/stack-permutations/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article

--
from typing import List
class Solution:
    def isStackPermutation(self, N : int, A : List[int], B : List[int]) -> int:
        # code here
        stack = []
        j = 0
        for i in range(N):
            stack.append(A[i])
            
            while len(stack) > 0 and stack[-1] == B[j]:
                stack.pop()
                j += 1
            
        if j == N and not stack:
            return 1
        return 0
-- 

###########################################################################################################################################################################

-- Minimum sum of absolute differences of pairs

-- https://www.youtube.com/watch?v=RZYkEj0iX3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=25
-- https://practice.geeksforgeeks.org/problems/minimum-sum-of-absolute-differences-of-pairs/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def findMinSum(self, A,B,N):
        A.sort()
        B.sort()
        sum = 0
        for i in range(N):
            sum += abs(A[i] - B[i])
        return sum
--

####################################################################################################################################################################################################

-- Smallest sum contiguous subarray

-- https://www.youtube.com/watch?v=XTRFIfu2OUw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=26
-- https://practice.geeksforgeeks.org/problems/smallest-sum-contiguous-subarray/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article


--
class Solution:
    def smallestSumSubarray(self, A, N):
        #Your code here
        minimum = float("inf")
        su = 0
        for i in range(N):
            su += A[i]
            if minimum > su:
                minimum = su
            if su > 0:
                su = 0
        
        return minimum
--

###################################################################################################################################################################################################################

-- Print the pattern 


-- https://www.geeksforgeeks.org/program-print-pattern-gfg/
-- https://www.youtube.com/watch?v=JttvX2HH7M0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=27

--

--


#########################################################################################################################################################################################################

-- Minimum cost to cut a board into squares

-- https://www.youtube.com/watch?v=j9Pxyfp8knU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=28
-- 

##########################################################################################################################################################################################################

-- Minimum time to fulfill all orders (Binary search hard question)
#### Important


-- https://practice.geeksforgeeks.org/problems/minimum-time-to-fulfil-all-orders/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=tfch4QSfRZc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=29


--

--


#####################################################################################################################################################################################################################################

-- Find the pairs with given sum in doubly linked list

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-pairs-with-given-sum-in-doubly-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def findPairsWithGivenSum(self, target : int, head : Optional['Node']) -> List[List[int]]:
        # two pointer method
        # code here
        
        l = head
        r = head
        ans = []
        while r.next != None:
            r = r.next
        #left is at start and right is at the end
        
        # condition also works for both even and odd elements
        while (l != r) and (r.next != l):
            csum = l.data + r.data
            if csum == target:
                ans.append((l.data, r.data))
                l = l.next
                r = r.next
            elif csum < target:
                l = l.next
            else:
                r = r.prev
        return ans
--

####################################################################################################################################################################################################################################

-- Find all distinct subset or subsequence

-- https://www.youtube.com/watch?v=evxWPp3TI3E&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=30
-- https://practice.geeksforgeeks.org/problems/find-all-distinct-subset-or-subsequence-sums4424/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
	def DistinctSum(self, nums):
	    dp = [[0 for _ in range(10001)] for _ in range(len(nums))]
		# Code here
		s = set()
		def sol(i, arr, s, sum):
		    if i == len(arr):
		        s.add(sum)
		        return 
		    
		    if dp[i][sum]:
		        return
		    
		    sol(i + 1, arr, s, sum)
		    sol(i+ 1, arr, s, sum + arr[i])
		    dp[i][sum] = 1
		    
		sol(0, nums, s, 0)
		return sorted(s)
--

######################################################################################################################################################################################################


-- Merging Details


-- https://practice.geeksforgeeks.org/problems/merging-details/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=8-foSocrEV4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=32


--
--

##########################################################################################################################################################################################

-- Next right node

-- https://www.youtube.com/watch?v=5SPNg4blazc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=33
-- https://practice.geeksforgeeks.org/problems/next-right-node/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
from collections import deque
class Solution:
    def nextRight(self, root, key):
        #code here
        queue = [root]
        ans = Node(-1)
        while queue:
            n = len(queue)
            for i in range(n):
                curr = queue.pop(0)
                if curr.data == key and i != n-1:
                    return queue[0]
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
        return ans
            
--

####################################################################################################################################################################################################

-- Binary tree to DLL

-- https://www.youtube.com/watch?v=wSUCZpA1LKY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=34'
-- https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    head = None
    tail = None
    def bToDLL(self,root):
        if not root: return
        self.bToDLL(root.left)
        if not self.head: 
            self.head = root
        else:
            root.left = self.tail
            self.tail.right = root
        self.tail = root
        self.bToDLL(root.right)
        return self.head
--

#####################################################################################################################################################################################################

-- Alternate positive and negative numbers

-- https://www.youtube.com/watch?v=ntt_6CCXDqI&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=35
-- 


--
class Solution:
    def rearrange(self,arr, n):
        # code here
        pos = []
        neg = []
        ans = []
        for i in range(n):
            if arr[i] > 0:
                pos.append(arr[i])
            elif arr[i] < 0:
                neg.append(arr[i])
        
        
        i, j, k, = 0, 0, 0
        while i < len(pos) or j < len(neg):
            if pos[i]:
                ans.append(pos[i])
                i+= 1
            if neg[j]:
                ans.append(neg[j])
                j += 1
        return ans
--

###################################################################################################################################################################################################

-- Count palindromic sequence

-- https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
    def countPS(self,string):
        n = len(string)
        dp = [[-1 for _ in range(n+1)] for _ in range(n+1)]
        
        def sol(i, j, string, dp):
            mod = 1e9+7
            if i == j:
                return 1
            if i > j:
                return 0
            
            if dp[i][j] != -1:
                return dp[i][j]
            
            if string[i] == string[j]:
                dp[i][j] = (1 + sol(i+1, j, string, dp) + sol(i, j-1, string, dp))%mod
            else:
                dp[i][j] = ((sol(i+1, j, string, dp) + sol(i, j - 1, string, dp) - sol(i+1, j-1, string, dp))%mod + mod)%mod
            return dp[i][j]
        
        return int(sol(0, len(string)-1, string, dp))
--



#####################################################################################################################################################################################################

-- Counting elements in two arrays


-- https://practice.geeksforgeeks.org/problems/counting-elements-in-two-arrays/1
-- https://www.youtube.com/watch?v=uLyFwNUCfmw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=37


--
class Solution:
    def countEleLessThanOrEqual(self,arr1,n1,arr2,n2):
        #returns the required output
        res = []
        arr2.sort()
        def binary(target, n2):
            low = 0
            high = n2 - 1
            ans = 0
            while (low<=high):
                mid = low + ((high - low)//2)
                if arr2[mid] > target:
                    ans = mid
                    high = mid - 1
                else:
                    if mid + 1 >= n2:
                        ans = mid + 1
                    low = mid + 1
            return ans
        
        for i in range(n1):
            index = binary(arr1[i], n2)
            res.append(index)
        return res
--

####################################################################################################################################################################################


-- Generate IP address (recursion and backtracking)

-- https://www.youtube.com/watch?v=XU4inpwKt8A&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40
-- https://practice.geeksforgeeks.org/problems/generate-ip-addresses/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=61tN4YEdiTM


--
class Solution:
    def genIp(self, s):
        res = []
        if len(s) > 12:
            return ['-1']

        def sol(i, curStr, dots):
            if dots == 4 and i == len(s):
                res.append(curStr[:-1])
            
            if dots > 4:
                return

            for j in range(i, min(len(s), i+3)):
                if int(s[i: j+1]) < 256 and (i == j or s[i] != "0"):
                    sol(j+1, curStr + s[i: j+1] + '.', dots + 1)
            
        sol(0, '', 0)
        return res
        
        
        
    def valid(self,char):
        if len(char)==0 or len(char)>3 or (char[0]=='0' and len(char)>1) or  int(char)>255:
            return False
        else:
            return True

    def genIp2(self, s):
        n=len(s)
        if len(s)>12:return ['-1']
        ans=[]
        for i in range(1,n-2):
            for j in range(i+1,n-1):
                for k in range(j+1,n):
                    a=s[0:i]
                    b=s[i:j]
                    c=s[j:k]
                    d=s[k:n]
                    if self.valid(a) and self.valid(b) and self.valid(c) and self.valid(d):
                        ans.append(a+"."+b+"."+c+"."+d)
        return ans
--

######################################################################################################################################################

-- foldable tree (Similar to mirror of the tree)

-- https://practice.geeksforgeeks.org/problems/foldable-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=C87kVZOq9Sg&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=39

--
def IsFoldable(root):
    if not root:
        return True
        
    def sol(left, right):
        if not left and not right:
            return 1
        if not left or not right:
            return 0
        return (sol(left.right, right.left) and sol(left.left, right.right))
    
    if sol(root.left, root.right):
        return True
    return False
--


###########################################################################################################################################################

-- Immediate Smaller element

-- https://www.youtube.com/watch?v=75LH0gHa4dQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=40 
-- https://practice.geeksforgeeks.org/problems/immediate-smaller-element1142/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
	def immediateSmaller(self,arr,n):
		for i in range(n - 1):
		    if arr[i] > arr[i + 1]:
		        arr[i] = arr[i + 1]
		    else:
		        arr[i] = -1
		arr[n - 1] = -1
		return arr
--


##########################################################################################################################################################

-- Game with nos

-- https://www.youtube.com/watch?v=q5jY1AeOs3U&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=41
-- 

--
Very easy code
--

#######################################################################################################################################################################

-- Sum of two large numbers

-- https://practice.geeksforgeeks.org/problems/sum-of-numbers-or-number1219/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=-ibOwx3dfaQ&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44

--
class Solution:
	def findSum(self, X, Y):
		x = X[::-1]
		y = Y[::-1]
		carry = 0
		if len(y) > len(x):
		    x, y = y, x
		    
		i = 0
		j = 0
		ans = ''
		while i<len(x) and j < len(y):
		    carry += int(x[i]) + int(y[j])
		    ans += str(carry%10)
		    carry = carry / 10
		    i += 1
		    j += 1
        while i < len(x):
            carry += int(x[i])
		    ans += str(carry%10)
		    carry = carry / 10
		    i+=1
	    
	    while carry:
	        ans += str(carry%10)
	        carry = carry / 10
	   
	    return ans[::-1]
--

############################################################################################################################################################################

-- Unit area of largest region of 1s (Similar to region in binary matrix)

-- https://www.youtube.com/watch?v=2fI49mrEYmM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=43
-- https://practice.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:

    #Function to find unit area of the largest region of 1s.
	def findMaxArea(self, grid):
		n = len(grid)
		m = len(grid[0])
		ans = 0
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 1:
		            count = self.count(i, j, grid, n, m)
		            ans = max(count, ans)
	    return ans
    
    def count(self, row, col, A, n, m):
        if any([row < 0, col < 0, row >= n, col >= m]):
            return 0
        if A[row][col] == 0:
            return 0
        count = 1
        
        A[row][col] = 0 # so that it wont repeat on loop
        
        for r in range(row - 1, row + 2):
            for c in range(col - 1, col + 2):
                count += self.count(r, c, A, n, m)
        
        return count
--



#########################################################################################################################################################################

-- Longest subarray with sum k (two pointer and sliding window)

-- https://www.youtube.com/watch?v=yDeNqw_dAU0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=44
-- https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

-- method 1 ( works for both positive and negative values) ( use this method for all neg and pos numbers)

=> find prefix sum
=> check for sum - kin dict()

class Solution:
    def lenOfLongSubarr (self, arr, n, k) : 
        m = dict()
        m[0] = -1 # if k = 0 then it might differ like if subarray starts from 0
        l = 0
        curSum = 0
        for i in range(n):
            curSum += arr[i]
            
            if (curSum - k) in m:
                l = max(l, i - m[curSum - k])
            
            if curSum not in m:
                m[curSum] = i
        
        return l
--


-- method 2 ( does not work for negative values)

def max_length(s, k):
    current = []
    max_len = -1 # returns -1 if there is no subsequence that adds up to k.
    for i in s:
        current.append(i)
        while sum(current) > k: # Shrink the array from the left, until the sum is <= k.
           current = current[1:]
        if sum(current) == k:
            max_len = max(max_len, len(current))

    return max_len
--



##################################################################################################################################################################

-- Number of turns in binary tree

-- https://www.youtube.com/watch?v=qWrIMKA3Vm4&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=45
-- https://practice.geeksforgeeks.org/problems/number-of-turns-in-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--  Incomplete code

class Solution:
    def NumberOFTurns(self, root, first, second):
        #return the number of turns required to go from first node to second node
        lca = self.lowestCommonAncestor(root, first, second)
        
        
        
    
    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root.data == p or root.data == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        
        if not right:
            return left
        
        else:
            return root
--

##############################################################################################################################################################################

 
-- Max length chain

-- 


--


--

####################################################################################################################################################################################

-- Subarrays sum equals k ( get the number of subarrays equal to k)

-- https://leetcode.com/problems/subarray-sum-equals-k/description/


--
class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:

		ans=0
		prefsum=0
		d={0:1}

		for num in nums:
			prefsum = prefsum + num

			if prefsum-k in d:
				ans = ans + d[prefsum-k]

			if prefsum not in d:
				d[prefsum] = 1
			else:
				d[prefsum] = d[prefsum]+1

		return ans
--


####################################################################################################################################################################

-- Max length chain (greedy)

-- https://practice.geeksforgeeks.org/problems/max-length-chain/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=UTOKMABq4Zs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=46

--
class Solution:
    def maxChainLen(self, Parr, n):
        Parr.sort(key=lambda x:x.b)
        
        result = 1
        end = Parr[0].b
        for pair in Parr:
            if pair.a > end:
                result+=1
                end = pair.b
        return result 
--


#############################################################################################################################################################################


-- Lowest Common Ancestor


-- https://www.youtube.com/watch?v=_-QHfMDde90
-- https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/926531691/


--
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        
        if not right:
            return left
        
        else:
            return root
--

##############################################################################################################################################################################


--  Case specific sorting of strings

-- https://www.youtube.com/watch?v=synFG_49iC0&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=48
-- https://practice.geeksforgeeks.org/problems/case-specific-sorting-of-strings4845/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.geeksforgeeks.org/case-specific-sorting-of-strings/

--
class Solution:

    #Function to perform case-specific sorting of strings.
    def caseSort(self,s,n):
        #code here
        lower = [0 for _ in range(50)]
        upper = [0 for _ in range(50)]
        res = ''
        l = 0
        u = 0
        for character in s:
            if ord(character) >= ord('a') and ord(character) <= ord('z'):
                lower[abs(ord(character) - ord('a'))] += 1
            else:
                upper[abs(ord(character) - ord('A'))] += 1
        
        for i in range(n):
            if ord(s[i]) >= ord('a') and ord(s[i]) <= ord('z'):
                while lower[l] == 0:
                    l += 1
                
                res += (chr(ord('a') + l))
                lower[l] -= 1
            else:
                while upper[u] == 0:
                    u += 1
                
                res += chr(ord('A') + u)
                upper[u] -= 1
                
        return res
--

##############################################################################################################################################################################

-- knight walk

-- https://www.youtube.com/watch?v=n4RbVQxvEXc&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=48
-- https://practice.geeksforgeeks.org/problems/knight-walk4521/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
	def minStepToReachTarget(self, KnightPos, TargetPos, N):
		#Code here
		
		vis = [[0 for i in range(N+1)] for _ in range(N+1)]
		queue = [(KnightPos[0], KnightPos[1], 0)]

        if KnightPos == TargetPos:
            return 0
        
        dx = [1, 1, -1, -1, 2, 2, -2, -2] # moves for knight in x direction
        dy = [2, -2, 2, -2, 1, -1, 1, -1] # moves for knight in y direction
        
        while queue:
            x, y, moves = queue.pop(0)
            
            if (x == TargetPos[0] and y == TargetPos[1]):
                return moves
            
            for k in range(8):
                nx = dx[k] + x 
                ny = dy[k] + y
                
                if nx >= 1 and ny >= 1 and ny <= N and nx <= N and vis[nx][ny] == 0:
                    vis[nx][ny] = 1
                    queue.append((nx, ny, moves + 1))
                    
                 
        return -1
--

====================================================================================================================================================================================

-- gcd  *****


-- https://www.programiz.com/python-programming/examples/hcf
-- https://www.youtube.com/watch?v=DePWIOK1STg


--
--

####################################################################################################################################################################################

-- Fact Digit Sum


-- https://www.youtube.com/watch?v=cAWhCK6s89w&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=49
-- https://practice.geeksforgeeks.org/problems/fact-digit-sum4125/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
	def FactDigit(self, N):
		# Code here
		
		f = [1 for _ in range(10)]
		ans = []
		
		for i in range(1, 10):
		    f[i] = f[i - 1] * i
		
	    for i in range(9, -1, -1):
	        while f[i] <= N:
	            N -= f[i]
	            ans.append(i)
	    
	    return ans[::-1]
--

#################################################################################################################################################################


-- Pots of Gold (Recursion with dp)


-- https://www.youtube.com/watch?v=lgu2KrAcoVY&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=50
-- https://practice.geeksforgeeks.org/problems/pots-of-gold-game/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


Steps:

	can chosse from left side or right side
	if choose from left then  (l+1, r) will be left
	if choose from right then (l, r+1) will be left 
--
class Solution:
    def maxCoins(self,arr, n):
        # Code here
        
        d = [[-1 for _ in range(n)] for _ in range(n)]
        return self.recursion(0, n-1, arr, d)
        
    
    def recursion(self, l, r, arr, d):
        if l > r:
            return 0
        
        if d[l][r] != -1:
            return d[l][r]
        
        left = arr[l] + min(self.recursion(l+2, r, arr, d), self.recursion(l+1, r-1, arr, d))
        right = arr[r] + min(self.recursion(l+1, r-1, arr, d), self.recursion(l, r-2, arr, d))
        
        ans = max(left, right)
        d[l][r] = ans
        return ans
--


#####################################################################################################################################################################

-- M - coloring  (recursion and backtracking)

-- https://www.youtube.com/watch?v=W2UtRi2N1cg&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=51
-- https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--

-> try it with all possible ways
   
	--> recursion with backtracking

--



############################################################################################################################################################################################ 


-- Nine Divisors (Simple math)
 

-- https://www.youtube.com/watch?v=VyFxFoKi9_k&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=52

-- https://practice.geeksforgeeks.org/problems/nine-divisors3751/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
import math


#User function Template for python3
class Solution:
    def nineDivisors(self, N):
        # code here 
        
        # if we have a2 and b2 when both are prime then we have 7 combinations and plus for the 1 and number itself
        
        # a**2 x b**2  -> (p1**2 and p2**2) <= N
        # 1, p**8 -> prime number to the power 8
        
        # steps
        # find all prime <= sqrt(N)
        
        limit = math.sqrt(N) + 1
-- 

#########################################################################################################################

-- Josepheus problem (Recursion)

-- https://www.youtube.com/watch?v=HEQN_dejrbw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=53
-- https://practice.geeksforgeeks.org/problems/josephus-problem/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def josephus(self,n,k):
        #Your code here
        
        arr = [i+1 for i in range(n)]
        
        def rec(arr, index, k):
            if len(arr) == 1:
                return
        
            index = (index + k - 1 ) % len(arr)
            del arr[index]
            rec(arr, index, k)
        
        rec(arr, 0, k)
        return arr[0]
--


##############################################################################################################################

-- Quick sort on doubly linked list  (Lomuto and Hoares algorithmn)

-- https://www.youtube.com/watch?v=ms_rjPaUNqs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=55
-- https://practice.geeksforgeeks.org/problems/quicksort-on-doubly-linked-list/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


Ways to partition the array

1. Naive
2. Lomuto
3. Hoares


--  Lomuto method used
class Solution:
    def partition(self, l, h):
        # Your code goes here
        
        
        # using the lomuto method
        
        
        # first assign high element to pivot and (low - 1) element to i
        
        # In loop Compare the j and pivot 
        
        pivot = h.data
        i = l.prev
        
        j = l
        
        while j != h:
            if j.data <= pivot:
                if i is not None:
                    i = i.next
                else:
                    i = l
                i.data, j.data = j.data, i.data
                
            j = j.next
            
        if i is not None:
            i = i.next
        else:
            i = l
        
        i.data, h.data = h.data, i.data 
        return i
--


############################################################################################################################################

-- X total shapes

-- https://www.youtube.com/watch?v=Hu1ahbUTBmk&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=56
-- https://practice.geeksforgeeks.org/problems/x-total-shapes3617/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--
class Solution:
    
    #Function to find the number of 'X' total shapes.
    def dfs(self, row, col, n, m, grid):
        if row < 0 or col < 0 or row >= n or col >= m or grid[row][col] == 'O':
            return
        
        grid[row][col] = 'O'
        
        self.dfs(row - 1, col, n, m, grid)
        self.dfs(row + 1, col, n, m, grid)
        self.dfs(row, col - 1, n, m, grid)
        self.dfs(row, col + 1, n, m, grid)
        
        
	def xShape(self, grid):
		#Code here
		n = len(grid)
		m = len(grid[0])
		count = 0
		
		
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 'X':
		            count += 1
		            self.dfs(i, j, n, m, grid)
	
	    return count
--



####################################################################################################################################################


-- PreOrder to BST


-- https://www.youtube.com/watch?v=-XnqvzYGQGs&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=57
-- https://practice.geeksforgeeks.org/problems/preorder-to-postorder4423/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


-- Two method 
	1. build the BST by traversing the array one by one O(N**2)
	2. we need Preorder and Inorder traversal 
		-> Inorder traversal is the ascending order of the BST  O(logN) max
	3. have range for particular node in BST separately


--
#User function Template for python3

class Node:

    def __init__(self, data=0):
        self.data = data
        self.left = None
        self.right = None

#Function that constructs BST from its preorder traversal.
    

def rec(pre, n, i, mi, mx):
    
    if i >= n: 
        return None
    
    if mi > pre[i] or pre[i] > mx:
        return None
    
    root = Node(pre[i])
    
    i = i + 1
    
    root.left = rec(pre, n, i, mi, root.data - 1)
    root.right = rec(pre, n, i, root.data - 1, mx)
    
    return root
    

def post_order(pre, size) -> Node:
    #code here
    
    i = 0
    mi = float('-inf')
    mx = float('inf')
    
    root = rec(pre, size, i, mi, mx)
    
    return root
--



############################################################################################################################################

-- Complete Binary tree


-- For a complete binary tree 
	-> All the levels are filled except the lowest level
	-> filled from left

-- https://www.youtube.com/watch?v=eu0mbmfHgyM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=58
-- https://practice.geeksforgeeks.org/problems/complete-binary-tree/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day

--

class Solution():
    def isCompleteBT(self, root):
        #Add Code Here
        
        # first go to left to right if left child is not present then it is not complete binary tree
        
        # Use level order traversal
        # BFS (level order traversal) using queue
        
        
        if root is None:
            return 1
        
        ok = 0
        
        queue = [root]
        
        while len(queue)>0:
            node = queue.pop(0)
            
            if node.left:
                if ok:
                    return 0
                else:
                    queue.append(node.left)
            else:
                ok = 1
                
            if node.right:
                if ok:
                    return 0
                else:
                    queue.append(node.right)
            else:
                ok = 1
            
        return 1
--


######################################################################################################################################################


-- Delete nodes greater than k


-- https://www.youtube.com/watch?v=eu0mbmfHgyM&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=58
-- https://practice.geeksforgeeks.org/problems/delete-nodes-greater-than-k/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    # your task is to complete this function
    # function should delete all the Nodes greater than or equal to k
    # function should return the new head to pointer
    def deleteNode(self, root, k):
        # Code here
        
        # use post order traversal
        
        if root is None:
            return None
            
        root.left = self.deleteNode(root.left, k)
        root.right = self.deleteNode(root.right, k)
        if root.data >= k:
            temp = root.left
            del root
            return temp
        return root
--


######################################################################################################################################################

-- Egg droping puzzle (dp and recursion)

-- https://www.youtube.com/watch?v=siViBAILDi8&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=60
-- https://practice.geeksforgeeks.org/problems/elements-in-the-range2834/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/


## Here u need to take the minimum of worst cases

--
class Solution:
    
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self,n, k):
        # code here
        
        
        # two chances if u drop from the floor
            # either egg breaks -> then n-1 and go down (i - 1, n - 1)
            # egg doesnot break -> then n and go up ( k - i, n)
            
        def rec(n, k, dp):
            if n == 1 or k == 0 or k == 1:
                return k
                
            if dp[n][k] != -1:
                return dp[n][k]
            
            
            ans = float('inf')
            
            for i in range(1, k + 1):
                
                c1 = rec(n - 1, i - 1, dp) # egg breaks
                c2 = rec(n, k - i, dp) # if egg does not break
                
                
                worst = 1 + max(c1, c2)
                ans = min(ans, worst)
                
            dp[n][k] = ans
            return dp[n][k]
                
                
        dp = [[-1 for x in range(k + 1)] for _ in range(n + 1)]
        return rec(n , k, dp)
--



########################################################################################################################################################


-- Elements in the range


-- https://www.youtube.com/watch?v=Ykp4ZIlBNfw&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=61
-- https://practice.geeksforgeeks.org/problems/elements-in-the-range2834/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day


--
class Solution:
    def check_elements(self, arr, n, A, B):
        # Your code goes here
        
        
        # for eg from 2 to 5 
        # to get the index of 4 in range 2 to 5 -> take 4 and substrat with 2
        # so the index of 4 is -> 4 - 2 => 2 
        # same goes for all others 
        
        
        # get the index and then if present make the index of the array neg
        # later traverse the array till the number of elements like 2 - 5 + 1 then check the neg elements array 
        
        
        ranges = B - A
        for i in range(n):
            
            if abs(arr[i]) <= B and abs(arr[i]) >= A:
                temp = abs(arr[i]) - A
                 
                if temp < n and arr[temp] > 0:
                    arr[temp] *= -1
                
        count = 0
        
        for i in range(0, ranges + 1):
            if i < n:
                if arr[i] > 0:
                    return False
                else:
                    count += 1
        
        return True if count == (ranges + 1) else False
--



#################################################################################################################################################################################

-- Repeated Character


-- https://practice.geeksforgeeks.org/problems/repeated-character2058/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day
-- https://www.youtube.com/watch?v=D0IQVwa5wOU&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=62

--
class Solution:
    def firstRep(self, s):
        # code here
        
        # hashing
        
        # we need the array of 26 to hash the value a[26]
        
        n = len(s)
        a = [(n + 2) for _ in range(27)]
        pos = n + 1
        ans = "#"
        
        for i in range(n):
            if a[ord(s[i]) - ord("a")] < pos:
                pos = a[ord(s[i]) - ord("a")]
                ans = s[i]
            
            else:
                a[ord(s[i]) - ord("a")] = i
        return ans
        
--

########################################################################################################################################################

-- Geek and knots (DP) (Hard can be solved by pascals triangle)

--  https://www.youtube.com/watch?v=Nk2RLImBXCo&list=PLM68oyaqFM7R1dbnc2dvgkPojmU5PciOS&index=63
-- https://practice.geeksforgeeks.org/problems/little-murph-and-knots0402/1?utm_source=youtube&utm_medium=courseteam_practice_desc&utm_campaign=problem_of_the_day



--
class Solution:
    mod = 1000000007
    def ncr(self, n, r):
        if r == 0 or r == n:
            return 1
        
        return ncr(n-1, r-1) + ncr(n-1, r-1)
        
    def knots(self, M, N, K):
        # code here
        
        # try to use the pascals triangle method using permutation and combination
        
        # using dp
        
        dp = [[0 for _ in range(max(M, N)+1)] for _ in range(max(M, N) + 1)]
        
        for i in range(max(M, N) + 1):
            dp[i][0] = 1
            dp[i][i] = 1
            
            for j in range(1, i):
                dp[i][j] = (dp[i-1][j -1]%self.mod + dp[i-1][j]%self.mod)%self.mod
                
        ans = ((dp[N][K]%self.mod) * (dp[M][K]%self.mod) )%self.mod
        return int(ans)
            
--


###########################################################################################################################################################








