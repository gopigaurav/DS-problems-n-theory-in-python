-- Symmetric tree

-- https://practice.geeksforgeeks.org/problems/symmetric-tree/1/#
-- https://www.geeksforgeeks.org/symmetric-tree-tree-which-is-mirror-image-of-itself/
-- Kashish mahindrata
-- https://www.youtube.com/watch?v=kgAAfIB_358&list=PLNxqWc8Uj2LRbsOlBiPJZAyZpaUwdDepd



class Solution:
    # return true/false denoting whether the tree is Symmetric or not
    def isSymmetric(self, root):
        if not root: return True
        def mirror(l,r):
            if not l and not r: return True
            if not l or not r: return False
            if l.data != r.data: return False
            
            return (mirror(l.left,r.right) and mirror(l.right,r.left))
        return mirror(root.left,root.right)


-- method 2

# Python program to check if a
# given Binary Tree is symmetric or not

# Node structure


class Node:

  # Utility function to create new node
  def __init__(self, key):
    self.key = key
    self.left = None
    self.right = None

# Returns True if trees
#with roots as root1 and root 2 are mirror


def isMirror(root1, root2):
  # If both trees are empty, then they are mirror images
  if root1 is None and root2 is None:
    return True

  """ For two trees to be mirror images,
    the following three conditions must be true
    1 - Their root node's key must be same
    2 - left subtree of left tree and right subtree
    of the right tree have to be mirror images
    3 - right subtree of left tree and left subtree
    of right tree have to be mirror images
  """
  if (root1 is not None and root2 is not None):
    if root1.key == root2.key:
      return (isMirror(root1.left, root2.right)and
          isMirror(root1.right, root2.left))

  # If none of the above conditions is true then root1
  # and root2 are not mirror images
  return False


def isSymmetric(root):

  # Check if tree is mirror of itself
  return isMirror(root, root)


# Driver Code
# Let's construct the tree show in the above figure
root = Node(1)
root.left = Node(2)
root.right = Node(2)
root.left.left = Node(3)
root.left.right = Node(4)
root.right.left = Node(4)
root.right.right = Node(3)
print ("Symmetric" if isSymmetric(root) == True else "Not symmetric")

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)




=========================================================================================================

-- Zig Zag traversal



-- https://www.geeksforgeeks.org/zigzag-tree-traversal/
-- https://www.youtube.com/watch?v=iJT9JrrFQ44&list=PLNxqWc8Uj2LRbsOlBiPJZAyZpaUwdDepd&index=6
-- https://practice.geeksforgeeks.org/problems/zigzag-tree-traversal/1/#

# two stacks used here
class Solution:
    #Function to store the zig zag order traversal of tree in a list.
    def zigZagTraversal(self, root):
        res = []
        s1 = []
        s2 = []
        s1.append(root)
        while len(s1) or len(s2):
            while s1:
                temp = s1.pop()
                res.append(temp.data)
                if temp.left: s2.append(temp.left)
                if temp.right: s2.append(temp.right)
            while s2:
                temp = s2.pop()
                res.append(temp.data)
                if temp.right: s1.append(temp.right)
                if temp.left: s1.append(temp.left)
        return res



========================================================================================================================

-- Balanced Binary Tree

-- https://www.interviewbit.com/problems/balanced-binary-tree/
-- https://www.geeksforgeeks.org/how-to-determine-if-a-binary-tree-is-balanced/
-- https://www.youtube.com/watch?v=5q42f32rvLs&list=PLNxqWc8Uj2LRbsOlBiPJZAyZpaUwdDepd&index=9
-- https://practice.geeksforgeeks.org/problems/check-for-balanced-tree/1/#


=================================================================================================================================================================

-- Diameter of BT

-- https://www.geeksforgeeks.org/diameter-of-a-binary-tree/
-- https://practice.geeksforgeeks.org/problems/diameter-of-binary-tree/1

-- refer this
-- https://leetcode.com/problems/diameter-of-binary-tree/submissions/

--

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def height(root):
            nonlocal diameter
            if not root:
                return 0
            
            left = height(root.left)
            right = height(root.right)
            diameter = max(diameter, left + right)
            return max(left, right) + 1
        
        diameter = 0
        height(root)
        return diameter

=======================================================================================================================================

-- check if Binary tree is identical

-- https://practice.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1/
-- https://www.geeksforgeeks.org/write-c-code-to-determine-if-two-trees-are-identical/
--
class Solution:
    #Function to check if two trees are identical.
    def isIdentical(self,root1, root2):
        if not root1 and not root2: return True
        if not root2 or not root1: return False
        if root1.data != root2.data: return False
        return (self.isIdentical(root1.left,root2.left) and self.isIdentical(root1.right,root2.right))


================================================================================================================================

-- Min depth of BT

-- https://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/
-- https://www.interviewbit.com/problems/min-depth-of-binary-tree/


class Solution:
    def minDepth(self, root):
        if root.left is None and root.right is None:
            return 1
            
        if root.right is None:
            return 1 + self.minDepth(root.left)
            
        if root.left is None:
            return 1 + self.minDepth(root.right)
            
        return min(self.minDepth(root.left), self.minDepth(root.right)) +1


-- 
def minimumDepth(root, level):
    if (root == None):
        return level;
 
    level += 1;
     
    return min(minimumDepth(root.left, level),
                        minimumDepth(root.right, level))
=============================================================================================================================================

 


-- Check for subtree

-- https://practice.geeksforgeeks.org/problems/check-if-subtree/1/
-- https://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/

class Solution:
    def isSubTree(self, root, S):
        q = []
        q.append(root)
        
        
        def isIdentical(A,B):
            if not A and not B: return True
            if not A or not B: return False
            if A.data != B.data: return False
            return (isIdentical(A.left, B.left) and isIdentical(A.right, B.right))
            
        while q:
            temp = q.pop(0)
            if(temp.data == S.data):
                if isIdentical(temp,S):
                    return True
            if temp.left: q.append(temp.left)
            if temp.right: q.append(temp.right)
        return False

=======================================================================================================================================================

-- Inorder traversal

-- https://www.interviewbit.com/problems/inorder-traversal/
-- https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/

-- iterative and  recursive


lass Solution:
    def inorderTraversal(self, root):
        self.values = []
        #self.traverse(root)
        #return self.values
        
        return self.iterative(root)
        
    def iterative(self,root):
        res = []
        stack = []
        cur = root
        while True:
            if cur is not None:
                stack.append(cur)
                cur = cur.left
            elif stack:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
            else:
                break
        return res
        
    def traverse(self, root):
        if root.left is None and root.right is None:
            self.values.append(root.val)
            return
        
        if root.left:    
            self.traverse(root.left)
        self.values.append(root.val)
        if root.right:
            self.traverse(root.right)



=========================================================================================================================================

-- Preorder iterative
-- https://www.geeksforgeeks.org/iterative-preorder-traversal/
-- https://www.interviewbit.com/problems/preorder-traversal/


-- 

class Solution:
    def preorderTraversal(self, root):
        self.values = []
        #self.traverse(root)
        #return self.values
        return self.iterative(root)
        
    def iterative(self,root):
        if not root: return []
        stack = []
        res = []
        stack.append(root)
        
        while stack:
            temp = stack.pop()
            res.append(temp.val)
            if temp.right:
                stack.append(temp.right)
            if temp.left:
                stack.append(temp.left)
        return res
        
        

    def traverse(self, root):
        if root is None:
            return

        self.values.append(root.val)
        self.traverse(root.left)
        self.traverse(root.right)

==================================================================================================================


-- Postorder


-- https://www.geeksforgeeks.org/iterative-postorder-traversal/
-- https://www.interviewbit.com/problems/postorder-traversal/


class Solution:
    def postorderTraversal(self, root):
        self.values = []
        #self.traverse(root)
        #return self.values
        return self.iterative(root)
        
    def iterative(self,root):
        if not root: return []
        stack1 = []
        stack2 =[]
        res = []
        stack1.append(root)
        
        while stack1:
            temp = stack1.pop()
            stack2.append(temp)
            if temp.left:
                stack1.append(temp.left)
            if temp.right:
                stack1.append(temp.right)
        while stack2:
            temp = stack2.pop()
            res.append(temp.val)
            
        return res
        
    def traverse(self, root):
        if root.left is None and root.right is None:
            self.values.append(root.val)
            return
        
        if root.left:    
            self.traverse(root.left)
        
        if root.right:
            self.traverse(root.right)
        self.values.append(root.val)


=================================================================================================

-- Vertical order traversal

-- https://www.interviewbit.com/problems/vertical-order-traversal-of-binary-tree/
-- https://www.geeksforgeeks.org/print-binary-tree-vertical-order/

-- 


import collections
class Solution:
    # @param A : root node of tree
    # @return a list of list of integers
    def verticalOrderTraversal(self, root):
        cols = collections.defaultdict(list)
        queue = [(root, 0)]
        for node, i in queue:
            if node:
                cols[i].append(node.val)
                queue += [(node.left, i - 1), (node.right, i + 1)]
        return [cols[i] for i in sorted(cols)]


==================================================================================================================




